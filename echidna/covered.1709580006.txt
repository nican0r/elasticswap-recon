/Users/nelsonpereira/Documents/GitHub/Auditing/Fuzzy/Blogs/ElasticSwap_Recon/elasticswap-recon/lib/chimera/src/Asserts.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity ^0.8.0;
  3 |     | 
  4 |     | abstract contract Asserts {
  5 |     |     function gt(uint256 a, uint256 b, string memory reason) internal virtual;
  6 |     | 
  7 |     |     function gte(uint256 a, uint256 b, string memory reason) internal virtual;
  8 |     | 
  9 |     |     function lt(uint256 a, uint256 b, string memory reason) internal virtual;
 10 |     | 
 11 |     |     function lte(uint256 a, uint256 b, string memory reason) internal virtual;
 12 |     | 
 13 |     |     function eq(uint256 a, uint256 b, string memory reason) internal virtual;
 14 |     | 
 15 |     |     function t(bool b, string memory reason) internal virtual;
 16 |     | 
 17 |     |     function between(uint256 value, uint256 low, uint256 high) internal virtual returns (uint256);
 18 |     | 
 19 |     |     function between(int256 value, int256 low, int256 high) internal virtual returns (int256);
 20 |     | 
 21 |     |     function precondition(bool p) internal virtual;
 22 |     | }
 23 |     | 

/Users/nelsonpereira/Documents/GitHub/Auditing/Fuzzy/Blogs/ElasticSwap_Recon/elasticswap-recon/lib/chimera/src/BaseProperties.sol
 1 |     | // SPDX-License-Identifier: MIT
 2 |     | pragma solidity ^0.8.0;
 3 |     | 
 4 |     | import {BaseSetup} from "./BaseSetup.sol";
 5 |     | 
 6 |     | abstract contract BaseProperties is BaseSetup {}
 7 |     | 

/Users/nelsonpereira/Documents/GitHub/Auditing/Fuzzy/Blogs/ElasticSwap_Recon/elasticswap-recon/lib/chimera/src/BaseSetup.sol
 1 |     | // SPDX-License-Identifier: MIT
 2 |     | pragma solidity ^0.8.0;
 3 |     | 
 4 |     | abstract contract BaseSetup {
 5 |     |     function setup() internal virtual;
 6 |     | }
 7 |     | 

/Users/nelsonpereira/Documents/GitHub/Auditing/Fuzzy/Blogs/ElasticSwap_Recon/elasticswap-recon/lib/chimera/src/BaseTargetFunctions.sol
 1 |     | // SPDX-License-Identifier: MIT
 2 |     | pragma solidity ^0.8.0;
 3 |     | 
 4 |     | import {BaseProperties} from "./BaseProperties.sol";
 5 |     | import {Asserts} from "./Asserts.sol";
 6 |     | 
 7 |     | abstract contract BaseTargetFunctions is BaseProperties, Asserts {}
 8 |     | 

/Users/nelsonpereira/Documents/GitHub/Auditing/Fuzzy/Blogs/ElasticSwap_Recon/elasticswap-recon/lib/chimera/src/CryticAsserts.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity ^0.8.0;
  3 |     | 
  4 |     | import {Asserts} from "./Asserts.sol";
  5 |     | 
  6 |     | contract CryticAsserts is Asserts {
  7 |     |     event Log(string);
  8 |     | 
  9 |     |     function gt(uint256 a, uint256 b, string memory reason) internal virtual override {
 10 |     |         emit Log(reason);
 11 |     |         assert(a > b);
 12 |     |     }
 13 |     | 
 14 |     |     function gte(uint256 a, uint256 b, string memory reason) internal virtual override {
 15 |     |         emit Log(reason);
 16 |     |         assert(a >= b);
 17 |     |     }
 18 |     | 
 19 |     |     function lt(uint256 a, uint256 b, string memory reason) internal virtual override {
 20 |     |         emit Log(reason);
 21 |     |         assert(a < b);
 22 |     |     }
 23 |     | 
 24 |     |     function lte(uint256 a, uint256 b, string memory reason) internal virtual override {
 25 |     |         emit Log(reason);
 26 |     |         assert(a <= b);
 27 |     |     }
 28 |     | 
 29 |     |     function eq(uint256 a, uint256 b, string memory reason) internal virtual override {
 30 |     |         emit Log(reason);
 31 |     |         assert(a == b);
 32 |     |     }
 33 |     | 
 34 |     |     function t(bool b, string memory reason) internal virtual override {
 35 |     |         emit Log(reason);
 36 |     |         assert(b);
 37 |     |     }
 38 |     | 
 39 |     |     function between(uint256 value, uint256 low, uint256 high) internal virtual override returns (uint256) {
 40 |     |         if (value < low || value > high) {
 41 |     |             uint256 ans = low + (value % (high - low + 1));
 42 |     |             return ans;
 43 |     |         }
 44 |     |         return value;
 45 |     |     }
 46 |     | 
 47 |     |     function between(int256 value, int256 low, int256 high) internal virtual override returns (int256) {
 48 |     |         if (value < low || value > high) {
 49 |     |             int256 range = high - low + 1;
 50 |     |             int256 clamped = (value - low) % (range);
 51 |     |             if (clamped < 0) clamped += range;
 52 |     |             int256 ans = low + clamped;
 53 |     |             return ans;
 54 |     |         }
 55 |     |         return value;
 56 |     |     }
 57 |     | 
 58 |     |     function precondition(bool p) internal virtual override {
 59 |     |         require(p);
 60 |     |     }
 61 |     | }
 62 |     | 

/Users/nelsonpereira/Documents/GitHub/Auditing/Fuzzy/Blogs/ElasticSwap_Recon/elasticswap-recon/lib/chimera/src/Hevm.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity ^0.8.0;
  3 |     | 
  4 |     | interface IHevm {
  5 |     |     // Set block.timestamp to newTimestamp
  6 |     |     function warp(uint256 newTimestamp) external;
  7 |     | 
  8 |     |     // Set block.number to newNumber
  9 |     |     function roll(uint256 newNumber) external;
 10 |     | 
 11 |     |     // Loads a storage slot from an address
 12 |     |     function load(address where, bytes32 slot) external returns (bytes32);
 13 |     | 
 14 |     |     // Stores a value to an address' storage slot
 15 |     |     function store(address where, bytes32 slot, bytes32 value) external;
 16 |     | 
 17 |     |     // Signs data (privateKey, digest) => (r, v, s)
 18 |     |     function sign(uint256 privateKey, bytes32 digest) external returns (uint8 r, bytes32 v, bytes32 s);
 19 |     | 
 20 |     |     // Gets address for a given private key
 21 |     |     function addr(uint256 privateKey) external returns (address account);
 22 |     | 
 23 |     |     // Performs a foreign function call via terminal
 24 |     |     function ffi(string[] calldata inputs) external returns (bytes memory result);
 25 |     | 
 26 |     |     // Performs the next smart contract call with specified `msg.sender`
 27 |     |     function prank(address newSender) external;
 28 |     | }
 29 |     | 
 30 |     | IHevm constant vm = IHevm(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D);
 31 |     | 

/Users/nelsonpereira/Documents/GitHub/Auditing/Fuzzy/Blogs/ElasticSwap_Recon/elasticswap-recon/lib/forge-std/src/console.sol
    1 |     | // SPDX-License-Identifier: MIT
    2 |     | pragma solidity >=0.4.22 <0.9.0;
    3 |     | 
    4 |     | library console {
    5 |     |     address constant CONSOLE_ADDRESS = address(0x000000000000000000636F6e736F6c652e6c6f67);
    6 |     | 
    7 |     |     function _sendLogPayload(bytes memory payload) private view {
    8 |     |         uint256 payloadLength = payload.length;
    9 |     |         address consoleAddress = CONSOLE_ADDRESS;
   10 |     |         /// @solidity memory-safe-assembly
   11 |     |         assembly {
   12 |     |             let payloadStart := add(payload, 32)
   13 |     |             let r := staticcall(gas(), consoleAddress, payloadStart, payloadLength, 0, 0)
   14 |     |         }
   15 |     |     }
   16 |     | 
   17 |     |     function log() internal view {
   18 |     |         _sendLogPayload(abi.encodeWithSignature("log()"));
   19 |     |     }
   20 |     | 
   21 |     |     function logInt(int p0) internal view {
   22 |     |         _sendLogPayload(abi.encodeWithSignature("log(int)", p0));
   23 |     |     }
   24 |     | 
   25 |     |     function logUint(uint p0) internal view {
   26 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint)", p0));
   27 |     |     }
   28 |     | 
   29 |     |     function logString(string memory p0) internal view {
   30 |     |         _sendLogPayload(abi.encodeWithSignature("log(string)", p0));
   31 |     |     }
   32 |     | 
   33 |     |     function logBool(bool p0) internal view {
   34 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool)", p0));
   35 |     |     }
   36 |     | 
   37 |     |     function logAddress(address p0) internal view {
   38 |     |         _sendLogPayload(abi.encodeWithSignature("log(address)", p0));
   39 |     |     }
   40 |     | 
   41 |     |     function logBytes(bytes memory p0) internal view {
   42 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes)", p0));
   43 |     |     }
   44 |     | 
   45 |     |     function logBytes1(bytes1 p0) internal view {
   46 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes1)", p0));
   47 |     |     }
   48 |     | 
   49 |     |     function logBytes2(bytes2 p0) internal view {
   50 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes2)", p0));
   51 |     |     }
   52 |     | 
   53 |     |     function logBytes3(bytes3 p0) internal view {
   54 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes3)", p0));
   55 |     |     }
   56 |     | 
   57 |     |     function logBytes4(bytes4 p0) internal view {
   58 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes4)", p0));
   59 |     |     }
   60 |     | 
   61 |     |     function logBytes5(bytes5 p0) internal view {
   62 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes5)", p0));
   63 |     |     }
   64 |     | 
   65 |     |     function logBytes6(bytes6 p0) internal view {
   66 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes6)", p0));
   67 |     |     }
   68 |     | 
   69 |     |     function logBytes7(bytes7 p0) internal view {
   70 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes7)", p0));
   71 |     |     }
   72 |     | 
   73 |     |     function logBytes8(bytes8 p0) internal view {
   74 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes8)", p0));
   75 |     |     }
   76 |     | 
   77 |     |     function logBytes9(bytes9 p0) internal view {
   78 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes9)", p0));
   79 |     |     }
   80 |     | 
   81 |     |     function logBytes10(bytes10 p0) internal view {
   82 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes10)", p0));
   83 |     |     }
   84 |     | 
   85 |     |     function logBytes11(bytes11 p0) internal view {
   86 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes11)", p0));
   87 |     |     }
   88 |     | 
   89 |     |     function logBytes12(bytes12 p0) internal view {
   90 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes12)", p0));
   91 |     |     }
   92 |     | 
   93 |     |     function logBytes13(bytes13 p0) internal view {
   94 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes13)", p0));
   95 |     |     }
   96 |     | 
   97 |     |     function logBytes14(bytes14 p0) internal view {
   98 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes14)", p0));
   99 |     |     }
  100 |     | 
  101 |     |     function logBytes15(bytes15 p0) internal view {
  102 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes15)", p0));
  103 |     |     }
  104 |     | 
  105 |     |     function logBytes16(bytes16 p0) internal view {
  106 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes16)", p0));
  107 |     |     }
  108 |     | 
  109 |     |     function logBytes17(bytes17 p0) internal view {
  110 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes17)", p0));
  111 |     |     }
  112 |     | 
  113 |     |     function logBytes18(bytes18 p0) internal view {
  114 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes18)", p0));
  115 |     |     }
  116 |     | 
  117 |     |     function logBytes19(bytes19 p0) internal view {
  118 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes19)", p0));
  119 |     |     }
  120 |     | 
  121 |     |     function logBytes20(bytes20 p0) internal view {
  122 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes20)", p0));
  123 |     |     }
  124 |     | 
  125 |     |     function logBytes21(bytes21 p0) internal view {
  126 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes21)", p0));
  127 |     |     }
  128 |     | 
  129 |     |     function logBytes22(bytes22 p0) internal view {
  130 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes22)", p0));
  131 |     |     }
  132 |     | 
  133 |     |     function logBytes23(bytes23 p0) internal view {
  134 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes23)", p0));
  135 |     |     }
  136 |     | 
  137 |     |     function logBytes24(bytes24 p0) internal view {
  138 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes24)", p0));
  139 |     |     }
  140 |     | 
  141 |     |     function logBytes25(bytes25 p0) internal view {
  142 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes25)", p0));
  143 |     |     }
  144 |     | 
  145 |     |     function logBytes26(bytes26 p0) internal view {
  146 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes26)", p0));
  147 |     |     }
  148 |     | 
  149 |     |     function logBytes27(bytes27 p0) internal view {
  150 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes27)", p0));
  151 |     |     }
  152 |     | 
  153 |     |     function logBytes28(bytes28 p0) internal view {
  154 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes28)", p0));
  155 |     |     }
  156 |     | 
  157 |     |     function logBytes29(bytes29 p0) internal view {
  158 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes29)", p0));
  159 |     |     }
  160 |     | 
  161 |     |     function logBytes30(bytes30 p0) internal view {
  162 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes30)", p0));
  163 |     |     }
  164 |     | 
  165 |     |     function logBytes31(bytes31 p0) internal view {
  166 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes31)", p0));
  167 |     |     }
  168 |     | 
  169 |     |     function logBytes32(bytes32 p0) internal view {
  170 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes32)", p0));
  171 |     |     }
  172 |     | 
  173 |     |     function log(uint p0) internal view {
  174 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint)", p0));
  175 |     |     }
  176 |     | 
  177 |     |     function log(string memory p0) internal view {
  178 |     |         _sendLogPayload(abi.encodeWithSignature("log(string)", p0));
  179 |     |     }
  180 |     | 
  181 |     |     function log(bool p0) internal view {
  182 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool)", p0));
  183 |     |     }
  184 |     | 
  185 |     |     function log(address p0) internal view {
  186 |     |         _sendLogPayload(abi.encodeWithSignature("log(address)", p0));
  187 |     |     }
  188 |     | 
  189 |     |     function log(uint p0, uint p1) internal view {
  190 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,uint)", p0, p1));
  191 |     |     }
  192 |     | 
  193 |     |     function log(uint p0, string memory p1) internal view {
  194 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,string)", p0, p1));
  195 |     |     }
  196 |     | 
  197 |     |     function log(uint p0, bool p1) internal view {
  198 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,bool)", p0, p1));
  199 |     |     }
  200 |     | 
  201 |     |     function log(uint p0, address p1) internal view {
  202 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,address)", p0, p1));
  203 |     |     }
  204 |     | 
  205 |     |     function log(string memory p0, uint p1) internal view {
  206 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint)", p0, p1));
  207 |     |     }
  208 |     | 
  209 |     |     function log(string memory p0, string memory p1) internal view {
  210 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string)", p0, p1));
  211 |     |     }
  212 |     | 
  213 |     |     function log(string memory p0, bool p1) internal view {
  214 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool)", p0, p1));
  215 |     |     }
  216 |     | 
  217 |     |     function log(string memory p0, address p1) internal view {
  218 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address)", p0, p1));
  219 |     |     }
  220 |     | 
  221 |     |     function log(bool p0, uint p1) internal view {
  222 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint)", p0, p1));
  223 |     |     }
  224 |     | 
  225 |     |     function log(bool p0, string memory p1) internal view {
  226 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string)", p0, p1));
  227 |     |     }
  228 |     | 
  229 |     |     function log(bool p0, bool p1) internal view {
  230 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool)", p0, p1));
  231 |     |     }
  232 |     | 
  233 |     |     function log(bool p0, address p1) internal view {
  234 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address)", p0, p1));
  235 |     |     }
  236 |     | 
  237 |     |     function log(address p0, uint p1) internal view {
  238 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint)", p0, p1));
  239 |     |     }
  240 |     | 
  241 |     |     function log(address p0, string memory p1) internal view {
  242 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string)", p0, p1));
  243 |     |     }
  244 |     | 
  245 |     |     function log(address p0, bool p1) internal view {
  246 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool)", p0, p1));
  247 |     |     }
  248 |     | 
  249 |     |     function log(address p0, address p1) internal view {
  250 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address)", p0, p1));
  251 |     |     }
  252 |     | 
  253 |     |     function log(uint p0, uint p1, uint p2) internal view {
  254 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,uint,uint)", p0, p1, p2));
  255 |     |     }
  256 |     | 
  257 |     |     function log(uint p0, uint p1, string memory p2) internal view {
  258 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,uint,string)", p0, p1, p2));
  259 |     |     }
  260 |     | 
  261 |     |     function log(uint p0, uint p1, bool p2) internal view {
  262 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,uint,bool)", p0, p1, p2));
  263 |     |     }
  264 |     | 
  265 |     |     function log(uint p0, uint p1, address p2) internal view {
  266 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,uint,address)", p0, p1, p2));
  267 |     |     }
  268 |     | 
  269 |     |     function log(uint p0, string memory p1, uint p2) internal view {
  270 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,string,uint)", p0, p1, p2));
  271 |     |     }
  272 |     | 
  273 |     |     function log(uint p0, string memory p1, string memory p2) internal view {
  274 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,string,string)", p0, p1, p2));
  275 |     |     }
  276 |     | 
  277 |     |     function log(uint p0, string memory p1, bool p2) internal view {
  278 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,string,bool)", p0, p1, p2));
  279 |     |     }
  280 |     | 
  281 |     |     function log(uint p0, string memory p1, address p2) internal view {
  282 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,string,address)", p0, p1, p2));
  283 |     |     }
  284 |     | 
  285 |     |     function log(uint p0, bool p1, uint p2) internal view {
  286 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,bool,uint)", p0, p1, p2));
  287 |     |     }
  288 |     | 
  289 |     |     function log(uint p0, bool p1, string memory p2) internal view {
  290 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,bool,string)", p0, p1, p2));
  291 |     |     }
  292 |     | 
  293 |     |     function log(uint p0, bool p1, bool p2) internal view {
  294 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,bool,bool)", p0, p1, p2));
  295 |     |     }
  296 |     | 
  297 |     |     function log(uint p0, bool p1, address p2) internal view {
  298 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,bool,address)", p0, p1, p2));
  299 |     |     }
  300 |     | 
  301 |     |     function log(uint p0, address p1, uint p2) internal view {
  302 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,address,uint)", p0, p1, p2));
  303 |     |     }
  304 |     | 
  305 |     |     function log(uint p0, address p1, string memory p2) internal view {
  306 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,address,string)", p0, p1, p2));
  307 |     |     }
  308 |     | 
  309 |     |     function log(uint p0, address p1, bool p2) internal view {
  310 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,address,bool)", p0, p1, p2));
  311 |     |     }
  312 |     | 
  313 |     |     function log(uint p0, address p1, address p2) internal view {
  314 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,address,address)", p0, p1, p2));
  315 |     |     }
  316 |     | 
  317 |     |     function log(string memory p0, uint p1, uint p2) internal view {
  318 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint,uint)", p0, p1, p2));
  319 |     |     }
  320 |     | 
  321 |     |     function log(string memory p0, uint p1, string memory p2) internal view {
  322 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint,string)", p0, p1, p2));
  323 |     |     }
  324 |     | 
  325 |     |     function log(string memory p0, uint p1, bool p2) internal view {
  326 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint,bool)", p0, p1, p2));
  327 |     |     }
  328 |     | 
  329 |     |     function log(string memory p0, uint p1, address p2) internal view {
  330 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint,address)", p0, p1, p2));
  331 |     |     }
  332 |     | 
  333 |     |     function log(string memory p0, string memory p1, uint p2) internal view {
  334 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,uint)", p0, p1, p2));
  335 |     |     }
  336 |     | 
  337 |     |     function log(string memory p0, string memory p1, string memory p2) internal view {
  338 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,string)", p0, p1, p2));
  339 |     |     }
  340 |     | 
  341 |     |     function log(string memory p0, string memory p1, bool p2) internal view {
  342 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,bool)", p0, p1, p2));
  343 |     |     }
  344 |     | 
  345 |     |     function log(string memory p0, string memory p1, address p2) internal view {
  346 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,address)", p0, p1, p2));
  347 |     |     }
  348 |     | 
  349 |     |     function log(string memory p0, bool p1, uint p2) internal view {
  350 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,uint)", p0, p1, p2));
  351 |     |     }
  352 |     | 
  353 |     |     function log(string memory p0, bool p1, string memory p2) internal view {
  354 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,string)", p0, p1, p2));
  355 |     |     }
  356 |     | 
  357 |     |     function log(string memory p0, bool p1, bool p2) internal view {
  358 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,bool)", p0, p1, p2));
  359 |     |     }
  360 |     | 
  361 |     |     function log(string memory p0, bool p1, address p2) internal view {
  362 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,address)", p0, p1, p2));
  363 |     |     }
  364 |     | 
  365 |     |     function log(string memory p0, address p1, uint p2) internal view {
  366 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,uint)", p0, p1, p2));
  367 |     |     }
  368 |     | 
  369 |     |     function log(string memory p0, address p1, string memory p2) internal view {
  370 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,string)", p0, p1, p2));
  371 |     |     }
  372 |     | 
  373 |     |     function log(string memory p0, address p1, bool p2) internal view {
  374 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,bool)", p0, p1, p2));
  375 |     |     }
  376 |     | 
  377 |     |     function log(string memory p0, address p1, address p2) internal view {
  378 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,address)", p0, p1, p2));
  379 |     |     }
  380 |     | 
  381 |     |     function log(bool p0, uint p1, uint p2) internal view {
  382 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint,uint)", p0, p1, p2));
  383 |     |     }
  384 |     | 
  385 |     |     function log(bool p0, uint p1, string memory p2) internal view {
  386 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint,string)", p0, p1, p2));
  387 |     |     }
  388 |     | 
  389 |     |     function log(bool p0, uint p1, bool p2) internal view {
  390 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint,bool)", p0, p1, p2));
  391 |     |     }
  392 |     | 
  393 |     |     function log(bool p0, uint p1, address p2) internal view {
  394 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint,address)", p0, p1, p2));
  395 |     |     }
  396 |     | 
  397 |     |     function log(bool p0, string memory p1, uint p2) internal view {
  398 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,uint)", p0, p1, p2));
  399 |     |     }
  400 |     | 
  401 |     |     function log(bool p0, string memory p1, string memory p2) internal view {
  402 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,string)", p0, p1, p2));
  403 |     |     }
  404 |     | 
  405 |     |     function log(bool p0, string memory p1, bool p2) internal view {
  406 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,bool)", p0, p1, p2));
  407 |     |     }
  408 |     | 
  409 |     |     function log(bool p0, string memory p1, address p2) internal view {
  410 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,address)", p0, p1, p2));
  411 |     |     }
  412 |     | 
  413 |     |     function log(bool p0, bool p1, uint p2) internal view {
  414 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,uint)", p0, p1, p2));
  415 |     |     }
  416 |     | 
  417 |     |     function log(bool p0, bool p1, string memory p2) internal view {
  418 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,string)", p0, p1, p2));
  419 |     |     }
  420 |     | 
  421 |     |     function log(bool p0, bool p1, bool p2) internal view {
  422 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,bool)", p0, p1, p2));
  423 |     |     }
  424 |     | 
  425 |     |     function log(bool p0, bool p1, address p2) internal view {
  426 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,address)", p0, p1, p2));
  427 |     |     }
  428 |     | 
  429 |     |     function log(bool p0, address p1, uint p2) internal view {
  430 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,uint)", p0, p1, p2));
  431 |     |     }
  432 |     | 
  433 |     |     function log(bool p0, address p1, string memory p2) internal view {
  434 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,string)", p0, p1, p2));
  435 |     |     }
  436 |     | 
  437 |     |     function log(bool p0, address p1, bool p2) internal view {
  438 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,bool)", p0, p1, p2));
  439 |     |     }
  440 |     | 
  441 |     |     function log(bool p0, address p1, address p2) internal view {
  442 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,address)", p0, p1, p2));
  443 |     |     }
  444 |     | 
  445 |     |     function log(address p0, uint p1, uint p2) internal view {
  446 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint,uint)", p0, p1, p2));
  447 |     |     }
  448 |     | 
  449 |     |     function log(address p0, uint p1, string memory p2) internal view {
  450 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint,string)", p0, p1, p2));
  451 |     |     }
  452 |     | 
  453 |     |     function log(address p0, uint p1, bool p2) internal view {
  454 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint,bool)", p0, p1, p2));
  455 |     |     }
  456 |     | 
  457 |     |     function log(address p0, uint p1, address p2) internal view {
  458 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint,address)", p0, p1, p2));
  459 |     |     }
  460 |     | 
  461 |     |     function log(address p0, string memory p1, uint p2) internal view {
  462 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,uint)", p0, p1, p2));
  463 |     |     }
  464 |     | 
  465 |     |     function log(address p0, string memory p1, string memory p2) internal view {
  466 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,string)", p0, p1, p2));
  467 |     |     }
  468 |     | 
  469 |     |     function log(address p0, string memory p1, bool p2) internal view {
  470 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,bool)", p0, p1, p2));
  471 |     |     }
  472 |     | 
  473 |     |     function log(address p0, string memory p1, address p2) internal view {
  474 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,address)", p0, p1, p2));
  475 |     |     }
  476 |     | 
  477 |     |     function log(address p0, bool p1, uint p2) internal view {
  478 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,uint)", p0, p1, p2));
  479 |     |     }
  480 |     | 
  481 |     |     function log(address p0, bool p1, string memory p2) internal view {
  482 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,string)", p0, p1, p2));
  483 |     |     }
  484 |     | 
  485 |     |     function log(address p0, bool p1, bool p2) internal view {
  486 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,bool)", p0, p1, p2));
  487 |     |     }
  488 |     | 
  489 |     |     function log(address p0, bool p1, address p2) internal view {
  490 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,address)", p0, p1, p2));
  491 |     |     }
  492 |     | 
  493 |     |     function log(address p0, address p1, uint p2) internal view {
  494 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,uint)", p0, p1, p2));
  495 |     |     }
  496 |     | 
  497 |     |     function log(address p0, address p1, string memory p2) internal view {
  498 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,string)", p0, p1, p2));
  499 |     |     }
  500 |     | 
  501 |     |     function log(address p0, address p1, bool p2) internal view {
  502 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,bool)", p0, p1, p2));
  503 |     |     }
  504 |     | 
  505 |     |     function log(address p0, address p1, address p2) internal view {
  506 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,address)", p0, p1, p2));
  507 |     |     }
  508 |     | 
  509 |     |     function log(uint p0, uint p1, uint p2, uint p3) internal view {
  510 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,uint,uint,uint)", p0, p1, p2, p3));
  511 |     |     }
  512 |     | 
  513 |     |     function log(uint p0, uint p1, uint p2, string memory p3) internal view {
  514 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,uint,uint,string)", p0, p1, p2, p3));
  515 |     |     }
  516 |     | 
  517 |     |     function log(uint p0, uint p1, uint p2, bool p3) internal view {
  518 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,uint,uint,bool)", p0, p1, p2, p3));
  519 |     |     }
  520 |     | 
  521 |     |     function log(uint p0, uint p1, uint p2, address p3) internal view {
  522 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,uint,uint,address)", p0, p1, p2, p3));
  523 |     |     }
  524 |     | 
  525 |     |     function log(uint p0, uint p1, string memory p2, uint p3) internal view {
  526 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,uint,string,uint)", p0, p1, p2, p3));
  527 |     |     }
  528 |     | 
  529 |     |     function log(uint p0, uint p1, string memory p2, string memory p3) internal view {
  530 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,uint,string,string)", p0, p1, p2, p3));
  531 |     |     }
  532 |     | 
  533 |     |     function log(uint p0, uint p1, string memory p2, bool p3) internal view {
  534 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,uint,string,bool)", p0, p1, p2, p3));
  535 |     |     }
  536 |     | 
  537 |     |     function log(uint p0, uint p1, string memory p2, address p3) internal view {
  538 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,uint,string,address)", p0, p1, p2, p3));
  539 |     |     }
  540 |     | 
  541 |     |     function log(uint p0, uint p1, bool p2, uint p3) internal view {
  542 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,uint,bool,uint)", p0, p1, p2, p3));
  543 |     |     }
  544 |     | 
  545 |     |     function log(uint p0, uint p1, bool p2, string memory p3) internal view {
  546 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,uint,bool,string)", p0, p1, p2, p3));
  547 |     |     }
  548 |     | 
  549 |     |     function log(uint p0, uint p1, bool p2, bool p3) internal view {
  550 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,uint,bool,bool)", p0, p1, p2, p3));
  551 |     |     }
  552 |     | 
  553 |     |     function log(uint p0, uint p1, bool p2, address p3) internal view {
  554 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,uint,bool,address)", p0, p1, p2, p3));
  555 |     |     }
  556 |     | 
  557 |     |     function log(uint p0, uint p1, address p2, uint p3) internal view {
  558 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,uint,address,uint)", p0, p1, p2, p3));
  559 |     |     }
  560 |     | 
  561 |     |     function log(uint p0, uint p1, address p2, string memory p3) internal view {
  562 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,uint,address,string)", p0, p1, p2, p3));
  563 |     |     }
  564 |     | 
  565 |     |     function log(uint p0, uint p1, address p2, bool p3) internal view {
  566 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,uint,address,bool)", p0, p1, p2, p3));
  567 |     |     }
  568 |     | 
  569 |     |     function log(uint p0, uint p1, address p2, address p3) internal view {
  570 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,uint,address,address)", p0, p1, p2, p3));
  571 |     |     }
  572 |     | 
  573 |     |     function log(uint p0, string memory p1, uint p2, uint p3) internal view {
  574 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,string,uint,uint)", p0, p1, p2, p3));
  575 |     |     }
  576 |     | 
  577 |     |     function log(uint p0, string memory p1, uint p2, string memory p3) internal view {
  578 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,string,uint,string)", p0, p1, p2, p3));
  579 |     |     }
  580 |     | 
  581 |     |     function log(uint p0, string memory p1, uint p2, bool p3) internal view {
  582 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,string,uint,bool)", p0, p1, p2, p3));
  583 |     |     }
  584 |     | 
  585 |     |     function log(uint p0, string memory p1, uint p2, address p3) internal view {
  586 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,string,uint,address)", p0, p1, p2, p3));
  587 |     |     }
  588 |     | 
  589 |     |     function log(uint p0, string memory p1, string memory p2, uint p3) internal view {
  590 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,string,string,uint)", p0, p1, p2, p3));
  591 |     |     }
  592 |     | 
  593 |     |     function log(uint p0, string memory p1, string memory p2, string memory p3) internal view {
  594 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,string,string,string)", p0, p1, p2, p3));
  595 |     |     }
  596 |     | 
  597 |     |     function log(uint p0, string memory p1, string memory p2, bool p3) internal view {
  598 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,string,string,bool)", p0, p1, p2, p3));
  599 |     |     }
  600 |     | 
  601 |     |     function log(uint p0, string memory p1, string memory p2, address p3) internal view {
  602 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,string,string,address)", p0, p1, p2, p3));
  603 |     |     }
  604 |     | 
  605 |     |     function log(uint p0, string memory p1, bool p2, uint p3) internal view {
  606 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,string,bool,uint)", p0, p1, p2, p3));
  607 |     |     }
  608 |     | 
  609 |     |     function log(uint p0, string memory p1, bool p2, string memory p3) internal view {
  610 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,string,bool,string)", p0, p1, p2, p3));
  611 |     |     }
  612 |     | 
  613 |     |     function log(uint p0, string memory p1, bool p2, bool p3) internal view {
  614 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,string,bool,bool)", p0, p1, p2, p3));
  615 |     |     }
  616 |     | 
  617 |     |     function log(uint p0, string memory p1, bool p2, address p3) internal view {
  618 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,string,bool,address)", p0, p1, p2, p3));
  619 |     |     }
  620 |     | 
  621 |     |     function log(uint p0, string memory p1, address p2, uint p3) internal view {
  622 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,string,address,uint)", p0, p1, p2, p3));
  623 |     |     }
  624 |     | 
  625 |     |     function log(uint p0, string memory p1, address p2, string memory p3) internal view {
  626 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,string,address,string)", p0, p1, p2, p3));
  627 |     |     }
  628 |     | 
  629 |     |     function log(uint p0, string memory p1, address p2, bool p3) internal view {
  630 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,string,address,bool)", p0, p1, p2, p3));
  631 |     |     }
  632 |     | 
  633 |     |     function log(uint p0, string memory p1, address p2, address p3) internal view {
  634 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,string,address,address)", p0, p1, p2, p3));
  635 |     |     }
  636 |     | 
  637 |     |     function log(uint p0, bool p1, uint p2, uint p3) internal view {
  638 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,bool,uint,uint)", p0, p1, p2, p3));
  639 |     |     }
  640 |     | 
  641 |     |     function log(uint p0, bool p1, uint p2, string memory p3) internal view {
  642 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,bool,uint,string)", p0, p1, p2, p3));
  643 |     |     }
  644 |     | 
  645 |     |     function log(uint p0, bool p1, uint p2, bool p3) internal view {
  646 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,bool,uint,bool)", p0, p1, p2, p3));
  647 |     |     }
  648 |     | 
  649 |     |     function log(uint p0, bool p1, uint p2, address p3) internal view {
  650 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,bool,uint,address)", p0, p1, p2, p3));
  651 |     |     }
  652 |     | 
  653 |     |     function log(uint p0, bool p1, string memory p2, uint p3) internal view {
  654 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,bool,string,uint)", p0, p1, p2, p3));
  655 |     |     }
  656 |     | 
  657 |     |     function log(uint p0, bool p1, string memory p2, string memory p3) internal view {
  658 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,bool,string,string)", p0, p1, p2, p3));
  659 |     |     }
  660 |     | 
  661 |     |     function log(uint p0, bool p1, string memory p2, bool p3) internal view {
  662 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,bool,string,bool)", p0, p1, p2, p3));
  663 |     |     }
  664 |     | 
  665 |     |     function log(uint p0, bool p1, string memory p2, address p3) internal view {
  666 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,bool,string,address)", p0, p1, p2, p3));
  667 |     |     }
  668 |     | 
  669 |     |     function log(uint p0, bool p1, bool p2, uint p3) internal view {
  670 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,bool,bool,uint)", p0, p1, p2, p3));
  671 |     |     }
  672 |     | 
  673 |     |     function log(uint p0, bool p1, bool p2, string memory p3) internal view {
  674 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,bool,bool,string)", p0, p1, p2, p3));
  675 |     |     }
  676 |     | 
  677 |     |     function log(uint p0, bool p1, bool p2, bool p3) internal view {
  678 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,bool,bool,bool)", p0, p1, p2, p3));
  679 |     |     }
  680 |     | 
  681 |     |     function log(uint p0, bool p1, bool p2, address p3) internal view {
  682 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,bool,bool,address)", p0, p1, p2, p3));
  683 |     |     }
  684 |     | 
  685 |     |     function log(uint p0, bool p1, address p2, uint p3) internal view {
  686 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,bool,address,uint)", p0, p1, p2, p3));
  687 |     |     }
  688 |     | 
  689 |     |     function log(uint p0, bool p1, address p2, string memory p3) internal view {
  690 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,bool,address,string)", p0, p1, p2, p3));
  691 |     |     }
  692 |     | 
  693 |     |     function log(uint p0, bool p1, address p2, bool p3) internal view {
  694 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,bool,address,bool)", p0, p1, p2, p3));
  695 |     |     }
  696 |     | 
  697 |     |     function log(uint p0, bool p1, address p2, address p3) internal view {
  698 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,bool,address,address)", p0, p1, p2, p3));
  699 |     |     }
  700 |     | 
  701 |     |     function log(uint p0, address p1, uint p2, uint p3) internal view {
  702 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,address,uint,uint)", p0, p1, p2, p3));
  703 |     |     }
  704 |     | 
  705 |     |     function log(uint p0, address p1, uint p2, string memory p3) internal view {
  706 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,address,uint,string)", p0, p1, p2, p3));
  707 |     |     }
  708 |     | 
  709 |     |     function log(uint p0, address p1, uint p2, bool p3) internal view {
  710 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,address,uint,bool)", p0, p1, p2, p3));
  711 |     |     }
  712 |     | 
  713 |     |     function log(uint p0, address p1, uint p2, address p3) internal view {
  714 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,address,uint,address)", p0, p1, p2, p3));
  715 |     |     }
  716 |     | 
  717 |     |     function log(uint p0, address p1, string memory p2, uint p3) internal view {
  718 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,address,string,uint)", p0, p1, p2, p3));
  719 |     |     }
  720 |     | 
  721 |     |     function log(uint p0, address p1, string memory p2, string memory p3) internal view {
  722 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,address,string,string)", p0, p1, p2, p3));
  723 |     |     }
  724 |     | 
  725 |     |     function log(uint p0, address p1, string memory p2, bool p3) internal view {
  726 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,address,string,bool)", p0, p1, p2, p3));
  727 |     |     }
  728 |     | 
  729 |     |     function log(uint p0, address p1, string memory p2, address p3) internal view {
  730 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,address,string,address)", p0, p1, p2, p3));
  731 |     |     }
  732 |     | 
  733 |     |     function log(uint p0, address p1, bool p2, uint p3) internal view {
  734 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,address,bool,uint)", p0, p1, p2, p3));
  735 |     |     }
  736 |     | 
  737 |     |     function log(uint p0, address p1, bool p2, string memory p3) internal view {
  738 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,address,bool,string)", p0, p1, p2, p3));
  739 |     |     }
  740 |     | 
  741 |     |     function log(uint p0, address p1, bool p2, bool p3) internal view {
  742 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,address,bool,bool)", p0, p1, p2, p3));
  743 |     |     }
  744 |     | 
  745 |     |     function log(uint p0, address p1, bool p2, address p3) internal view {
  746 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,address,bool,address)", p0, p1, p2, p3));
  747 |     |     }
  748 |     | 
  749 |     |     function log(uint p0, address p1, address p2, uint p3) internal view {
  750 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,address,address,uint)", p0, p1, p2, p3));
  751 |     |     }
  752 |     | 
  753 |     |     function log(uint p0, address p1, address p2, string memory p3) internal view {
  754 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,address,address,string)", p0, p1, p2, p3));
  755 |     |     }
  756 |     | 
  757 |     |     function log(uint p0, address p1, address p2, bool p3) internal view {
  758 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,address,address,bool)", p0, p1, p2, p3));
  759 |     |     }
  760 |     | 
  761 |     |     function log(uint p0, address p1, address p2, address p3) internal view {
  762 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,address,address,address)", p0, p1, p2, p3));
  763 |     |     }
  764 |     | 
  765 |     |     function log(string memory p0, uint p1, uint p2, uint p3) internal view {
  766 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint,uint,uint)", p0, p1, p2, p3));
  767 |     |     }
  768 |     | 
  769 |     |     function log(string memory p0, uint p1, uint p2, string memory p3) internal view {
  770 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint,uint,string)", p0, p1, p2, p3));
  771 |     |     }
  772 |     | 
  773 |     |     function log(string memory p0, uint p1, uint p2, bool p3) internal view {
  774 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint,uint,bool)", p0, p1, p2, p3));
  775 |     |     }
  776 |     | 
  777 |     |     function log(string memory p0, uint p1, uint p2, address p3) internal view {
  778 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint,uint,address)", p0, p1, p2, p3));
  779 |     |     }
  780 |     | 
  781 |     |     function log(string memory p0, uint p1, string memory p2, uint p3) internal view {
  782 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint,string,uint)", p0, p1, p2, p3));
  783 |     |     }
  784 |     | 
  785 |     |     function log(string memory p0, uint p1, string memory p2, string memory p3) internal view {
  786 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint,string,string)", p0, p1, p2, p3));
  787 |     |     }
  788 |     | 
  789 |     |     function log(string memory p0, uint p1, string memory p2, bool p3) internal view {
  790 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint,string,bool)", p0, p1, p2, p3));
  791 |     |     }
  792 |     | 
  793 |     |     function log(string memory p0, uint p1, string memory p2, address p3) internal view {
  794 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint,string,address)", p0, p1, p2, p3));
  795 |     |     }
  796 |     | 
  797 |     |     function log(string memory p0, uint p1, bool p2, uint p3) internal view {
  798 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint,bool,uint)", p0, p1, p2, p3));
  799 |     |     }
  800 |     | 
  801 |     |     function log(string memory p0, uint p1, bool p2, string memory p3) internal view {
  802 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint,bool,string)", p0, p1, p2, p3));
  803 |     |     }
  804 |     | 
  805 |     |     function log(string memory p0, uint p1, bool p2, bool p3) internal view {
  806 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint,bool,bool)", p0, p1, p2, p3));
  807 |     |     }
  808 |     | 
  809 |     |     function log(string memory p0, uint p1, bool p2, address p3) internal view {
  810 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint,bool,address)", p0, p1, p2, p3));
  811 |     |     }
  812 |     | 
  813 |     |     function log(string memory p0, uint p1, address p2, uint p3) internal view {
  814 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint,address,uint)", p0, p1, p2, p3));
  815 |     |     }
  816 |     | 
  817 |     |     function log(string memory p0, uint p1, address p2, string memory p3) internal view {
  818 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint,address,string)", p0, p1, p2, p3));
  819 |     |     }
  820 |     | 
  821 |     |     function log(string memory p0, uint p1, address p2, bool p3) internal view {
  822 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint,address,bool)", p0, p1, p2, p3));
  823 |     |     }
  824 |     | 
  825 |     |     function log(string memory p0, uint p1, address p2, address p3) internal view {
  826 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint,address,address)", p0, p1, p2, p3));
  827 |     |     }
  828 |     | 
  829 |     |     function log(string memory p0, string memory p1, uint p2, uint p3) internal view {
  830 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,uint,uint)", p0, p1, p2, p3));
  831 |     |     }
  832 |     | 
  833 |     |     function log(string memory p0, string memory p1, uint p2, string memory p3) internal view {
  834 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,uint,string)", p0, p1, p2, p3));
  835 |     |     }
  836 |     | 
  837 |     |     function log(string memory p0, string memory p1, uint p2, bool p3) internal view {
  838 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,uint,bool)", p0, p1, p2, p3));
  839 |     |     }
  840 |     | 
  841 |     |     function log(string memory p0, string memory p1, uint p2, address p3) internal view {
  842 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,uint,address)", p0, p1, p2, p3));
  843 |     |     }
  844 |     | 
  845 |     |     function log(string memory p0, string memory p1, string memory p2, uint p3) internal view {
  846 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,string,uint)", p0, p1, p2, p3));
  847 |     |     }
  848 |     | 
  849 |     |     function log(string memory p0, string memory p1, string memory p2, string memory p3) internal view {
  850 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,string,string)", p0, p1, p2, p3));
  851 |     |     }
  852 |     | 
  853 |     |     function log(string memory p0, string memory p1, string memory p2, bool p3) internal view {
  854 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,string,bool)", p0, p1, p2, p3));
  855 |     |     }
  856 |     | 
  857 |     |     function log(string memory p0, string memory p1, string memory p2, address p3) internal view {
  858 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,string,address)", p0, p1, p2, p3));
  859 |     |     }
  860 |     | 
  861 |     |     function log(string memory p0, string memory p1, bool p2, uint p3) internal view {
  862 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,bool,uint)", p0, p1, p2, p3));
  863 |     |     }
  864 |     | 
  865 |     |     function log(string memory p0, string memory p1, bool p2, string memory p3) internal view {
  866 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,bool,string)", p0, p1, p2, p3));
  867 |     |     }
  868 |     | 
  869 |     |     function log(string memory p0, string memory p1, bool p2, bool p3) internal view {
  870 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,bool,bool)", p0, p1, p2, p3));
  871 |     |     }
  872 |     | 
  873 |     |     function log(string memory p0, string memory p1, bool p2, address p3) internal view {
  874 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,bool,address)", p0, p1, p2, p3));
  875 |     |     }
  876 |     | 
  877 |     |     function log(string memory p0, string memory p1, address p2, uint p3) internal view {
  878 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,address,uint)", p0, p1, p2, p3));
  879 |     |     }
  880 |     | 
  881 |     |     function log(string memory p0, string memory p1, address p2, string memory p3) internal view {
  882 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,address,string)", p0, p1, p2, p3));
  883 |     |     }
  884 |     | 
  885 |     |     function log(string memory p0, string memory p1, address p2, bool p3) internal view {
  886 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,address,bool)", p0, p1, p2, p3));
  887 |     |     }
  888 |     | 
  889 |     |     function log(string memory p0, string memory p1, address p2, address p3) internal view {
  890 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,address,address)", p0, p1, p2, p3));
  891 |     |     }
  892 |     | 
  893 |     |     function log(string memory p0, bool p1, uint p2, uint p3) internal view {
  894 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,uint,uint)", p0, p1, p2, p3));
  895 |     |     }
  896 |     | 
  897 |     |     function log(string memory p0, bool p1, uint p2, string memory p3) internal view {
  898 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,uint,string)", p0, p1, p2, p3));
  899 |     |     }
  900 |     | 
  901 |     |     function log(string memory p0, bool p1, uint p2, bool p3) internal view {
  902 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,uint,bool)", p0, p1, p2, p3));
  903 |     |     }
  904 |     | 
  905 |     |     function log(string memory p0, bool p1, uint p2, address p3) internal view {
  906 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,uint,address)", p0, p1, p2, p3));
  907 |     |     }
  908 |     | 
  909 |     |     function log(string memory p0, bool p1, string memory p2, uint p3) internal view {
  910 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,string,uint)", p0, p1, p2, p3));
  911 |     |     }
  912 |     | 
  913 |     |     function log(string memory p0, bool p1, string memory p2, string memory p3) internal view {
  914 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,string,string)", p0, p1, p2, p3));
  915 |     |     }
  916 |     | 
  917 |     |     function log(string memory p0, bool p1, string memory p2, bool p3) internal view {
  918 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,string,bool)", p0, p1, p2, p3));
  919 |     |     }
  920 |     | 
  921 |     |     function log(string memory p0, bool p1, string memory p2, address p3) internal view {
  922 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,string,address)", p0, p1, p2, p3));
  923 |     |     }
  924 |     | 
  925 |     |     function log(string memory p0, bool p1, bool p2, uint p3) internal view {
  926 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,bool,uint)", p0, p1, p2, p3));
  927 |     |     }
  928 |     | 
  929 |     |     function log(string memory p0, bool p1, bool p2, string memory p3) internal view {
  930 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,bool,string)", p0, p1, p2, p3));
  931 |     |     }
  932 |     | 
  933 |     |     function log(string memory p0, bool p1, bool p2, bool p3) internal view {
  934 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,bool,bool)", p0, p1, p2, p3));
  935 |     |     }
  936 |     | 
  937 |     |     function log(string memory p0, bool p1, bool p2, address p3) internal view {
  938 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,bool,address)", p0, p1, p2, p3));
  939 |     |     }
  940 |     | 
  941 |     |     function log(string memory p0, bool p1, address p2, uint p3) internal view {
  942 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,address,uint)", p0, p1, p2, p3));
  943 |     |     }
  944 |     | 
  945 |     |     function log(string memory p0, bool p1, address p2, string memory p3) internal view {
  946 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,address,string)", p0, p1, p2, p3));
  947 |     |     }
  948 |     | 
  949 |     |     function log(string memory p0, bool p1, address p2, bool p3) internal view {
  950 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,address,bool)", p0, p1, p2, p3));
  951 |     |     }
  952 |     | 
  953 |     |     function log(string memory p0, bool p1, address p2, address p3) internal view {
  954 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,address,address)", p0, p1, p2, p3));
  955 |     |     }
  956 |     | 
  957 |     |     function log(string memory p0, address p1, uint p2, uint p3) internal view {
  958 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,uint,uint)", p0, p1, p2, p3));
  959 |     |     }
  960 |     | 
  961 |     |     function log(string memory p0, address p1, uint p2, string memory p3) internal view {
  962 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,uint,string)", p0, p1, p2, p3));
  963 |     |     }
  964 |     | 
  965 |     |     function log(string memory p0, address p1, uint p2, bool p3) internal view {
  966 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,uint,bool)", p0, p1, p2, p3));
  967 |     |     }
  968 |     | 
  969 |     |     function log(string memory p0, address p1, uint p2, address p3) internal view {
  970 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,uint,address)", p0, p1, p2, p3));
  971 |     |     }
  972 |     | 
  973 |     |     function log(string memory p0, address p1, string memory p2, uint p3) internal view {
  974 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,string,uint)", p0, p1, p2, p3));
  975 |     |     }
  976 |     | 
  977 |     |     function log(string memory p0, address p1, string memory p2, string memory p3) internal view {
  978 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,string,string)", p0, p1, p2, p3));
  979 |     |     }
  980 |     | 
  981 |     |     function log(string memory p0, address p1, string memory p2, bool p3) internal view {
  982 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,string,bool)", p0, p1, p2, p3));
  983 |     |     }
  984 |     | 
  985 |     |     function log(string memory p0, address p1, string memory p2, address p3) internal view {
  986 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,string,address)", p0, p1, p2, p3));
  987 |     |     }
  988 |     | 
  989 |     |     function log(string memory p0, address p1, bool p2, uint p3) internal view {
  990 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,bool,uint)", p0, p1, p2, p3));
  991 |     |     }
  992 |     | 
  993 |     |     function log(string memory p0, address p1, bool p2, string memory p3) internal view {
  994 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,bool,string)", p0, p1, p2, p3));
  995 |     |     }
  996 |     | 
  997 |     |     function log(string memory p0, address p1, bool p2, bool p3) internal view {
  998 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,bool,bool)", p0, p1, p2, p3));
  999 |     |     }
 1000 |     | 
 1001 |     |     function log(string memory p0, address p1, bool p2, address p3) internal view {
 1002 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,bool,address)", p0, p1, p2, p3));
 1003 |     |     }
 1004 |     | 
 1005 |     |     function log(string memory p0, address p1, address p2, uint p3) internal view {
 1006 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,address,uint)", p0, p1, p2, p3));
 1007 |     |     }
 1008 |     | 
 1009 |     |     function log(string memory p0, address p1, address p2, string memory p3) internal view {
 1010 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,address,string)", p0, p1, p2, p3));
 1011 |     |     }
 1012 |     | 
 1013 |     |     function log(string memory p0, address p1, address p2, bool p3) internal view {
 1014 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,address,bool)", p0, p1, p2, p3));
 1015 |     |     }
 1016 |     | 
 1017 |     |     function log(string memory p0, address p1, address p2, address p3) internal view {
 1018 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,address,address)", p0, p1, p2, p3));
 1019 |     |     }
 1020 |     | 
 1021 |     |     function log(bool p0, uint p1, uint p2, uint p3) internal view {
 1022 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint,uint,uint)", p0, p1, p2, p3));
 1023 |     |     }
 1024 |     | 
 1025 |     |     function log(bool p0, uint p1, uint p2, string memory p3) internal view {
 1026 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint,uint,string)", p0, p1, p2, p3));
 1027 |     |     }
 1028 |     | 
 1029 |     |     function log(bool p0, uint p1, uint p2, bool p3) internal view {
 1030 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint,uint,bool)", p0, p1, p2, p3));
 1031 |     |     }
 1032 |     | 
 1033 |     |     function log(bool p0, uint p1, uint p2, address p3) internal view {
 1034 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint,uint,address)", p0, p1, p2, p3));
 1035 |     |     }
 1036 |     | 
 1037 |     |     function log(bool p0, uint p1, string memory p2, uint p3) internal view {
 1038 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint,string,uint)", p0, p1, p2, p3));
 1039 |     |     }
 1040 |     | 
 1041 |     |     function log(bool p0, uint p1, string memory p2, string memory p3) internal view {
 1042 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint,string,string)", p0, p1, p2, p3));
 1043 |     |     }
 1044 |     | 
 1045 |     |     function log(bool p0, uint p1, string memory p2, bool p3) internal view {
 1046 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint,string,bool)", p0, p1, p2, p3));
 1047 |     |     }
 1048 |     | 
 1049 |     |     function log(bool p0, uint p1, string memory p2, address p3) internal view {
 1050 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint,string,address)", p0, p1, p2, p3));
 1051 |     |     }
 1052 |     | 
 1053 |     |     function log(bool p0, uint p1, bool p2, uint p3) internal view {
 1054 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint,bool,uint)", p0, p1, p2, p3));
 1055 |     |     }
 1056 |     | 
 1057 |     |     function log(bool p0, uint p1, bool p2, string memory p3) internal view {
 1058 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint,bool,string)", p0, p1, p2, p3));
 1059 |     |     }
 1060 |     | 
 1061 |     |     function log(bool p0, uint p1, bool p2, bool p3) internal view {
 1062 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint,bool,bool)", p0, p1, p2, p3));
 1063 |     |     }
 1064 |     | 
 1065 |     |     function log(bool p0, uint p1, bool p2, address p3) internal view {
 1066 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint,bool,address)", p0, p1, p2, p3));
 1067 |     |     }
 1068 |     | 
 1069 |     |     function log(bool p0, uint p1, address p2, uint p3) internal view {
 1070 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint,address,uint)", p0, p1, p2, p3));
 1071 |     |     }
 1072 |     | 
 1073 |     |     function log(bool p0, uint p1, address p2, string memory p3) internal view {
 1074 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint,address,string)", p0, p1, p2, p3));
 1075 |     |     }
 1076 |     | 
 1077 |     |     function log(bool p0, uint p1, address p2, bool p3) internal view {
 1078 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint,address,bool)", p0, p1, p2, p3));
 1079 |     |     }
 1080 |     | 
 1081 |     |     function log(bool p0, uint p1, address p2, address p3) internal view {
 1082 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint,address,address)", p0, p1, p2, p3));
 1083 |     |     }
 1084 |     | 
 1085 |     |     function log(bool p0, string memory p1, uint p2, uint p3) internal view {
 1086 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,uint,uint)", p0, p1, p2, p3));
 1087 |     |     }
 1088 |     | 
 1089 |     |     function log(bool p0, string memory p1, uint p2, string memory p3) internal view {
 1090 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,uint,string)", p0, p1, p2, p3));
 1091 |     |     }
 1092 |     | 
 1093 |     |     function log(bool p0, string memory p1, uint p2, bool p3) internal view {
 1094 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,uint,bool)", p0, p1, p2, p3));
 1095 |     |     }
 1096 |     | 
 1097 |     |     function log(bool p0, string memory p1, uint p2, address p3) internal view {
 1098 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,uint,address)", p0, p1, p2, p3));
 1099 |     |     }
 1100 |     | 
 1101 |     |     function log(bool p0, string memory p1, string memory p2, uint p3) internal view {
 1102 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,string,uint)", p0, p1, p2, p3));
 1103 |     |     }
 1104 |     | 
 1105 |     |     function log(bool p0, string memory p1, string memory p2, string memory p3) internal view {
 1106 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,string,string)", p0, p1, p2, p3));
 1107 |     |     }
 1108 |     | 
 1109 |     |     function log(bool p0, string memory p1, string memory p2, bool p3) internal view {
 1110 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,string,bool)", p0, p1, p2, p3));
 1111 |     |     }
 1112 |     | 
 1113 |     |     function log(bool p0, string memory p1, string memory p2, address p3) internal view {
 1114 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,string,address)", p0, p1, p2, p3));
 1115 |     |     }
 1116 |     | 
 1117 |     |     function log(bool p0, string memory p1, bool p2, uint p3) internal view {
 1118 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,bool,uint)", p0, p1, p2, p3));
 1119 |     |     }
 1120 |     | 
 1121 |     |     function log(bool p0, string memory p1, bool p2, string memory p3) internal view {
 1122 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,bool,string)", p0, p1, p2, p3));
 1123 |     |     }
 1124 |     | 
 1125 |     |     function log(bool p0, string memory p1, bool p2, bool p3) internal view {
 1126 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,bool,bool)", p0, p1, p2, p3));
 1127 |     |     }
 1128 |     | 
 1129 |     |     function log(bool p0, string memory p1, bool p2, address p3) internal view {
 1130 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,bool,address)", p0, p1, p2, p3));
 1131 |     |     }
 1132 |     | 
 1133 |     |     function log(bool p0, string memory p1, address p2, uint p3) internal view {
 1134 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,address,uint)", p0, p1, p2, p3));
 1135 |     |     }
 1136 |     | 
 1137 |     |     function log(bool p0, string memory p1, address p2, string memory p3) internal view {
 1138 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,address,string)", p0, p1, p2, p3));
 1139 |     |     }
 1140 |     | 
 1141 |     |     function log(bool p0, string memory p1, address p2, bool p3) internal view {
 1142 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,address,bool)", p0, p1, p2, p3));
 1143 |     |     }
 1144 |     | 
 1145 |     |     function log(bool p0, string memory p1, address p2, address p3) internal view {
 1146 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,address,address)", p0, p1, p2, p3));
 1147 |     |     }
 1148 |     | 
 1149 |     |     function log(bool p0, bool p1, uint p2, uint p3) internal view {
 1150 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,uint,uint)", p0, p1, p2, p3));
 1151 |     |     }
 1152 |     | 
 1153 |     |     function log(bool p0, bool p1, uint p2, string memory p3) internal view {
 1154 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,uint,string)", p0, p1, p2, p3));
 1155 |     |     }
 1156 |     | 
 1157 |     |     function log(bool p0, bool p1, uint p2, bool p3) internal view {
 1158 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,uint,bool)", p0, p1, p2, p3));
 1159 |     |     }
 1160 |     | 
 1161 |     |     function log(bool p0, bool p1, uint p2, address p3) internal view {
 1162 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,uint,address)", p0, p1, p2, p3));
 1163 |     |     }
 1164 |     | 
 1165 |     |     function log(bool p0, bool p1, string memory p2, uint p3) internal view {
 1166 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,string,uint)", p0, p1, p2, p3));
 1167 |     |     }
 1168 |     | 
 1169 |     |     function log(bool p0, bool p1, string memory p2, string memory p3) internal view {
 1170 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,string,string)", p0, p1, p2, p3));
 1171 |     |     }
 1172 |     | 
 1173 |     |     function log(bool p0, bool p1, string memory p2, bool p3) internal view {
 1174 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,string,bool)", p0, p1, p2, p3));
 1175 |     |     }
 1176 |     | 
 1177 |     |     function log(bool p0, bool p1, string memory p2, address p3) internal view {
 1178 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,string,address)", p0, p1, p2, p3));
 1179 |     |     }
 1180 |     | 
 1181 |     |     function log(bool p0, bool p1, bool p2, uint p3) internal view {
 1182 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,bool,uint)", p0, p1, p2, p3));
 1183 |     |     }
 1184 |     | 
 1185 |     |     function log(bool p0, bool p1, bool p2, string memory p3) internal view {
 1186 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,bool,string)", p0, p1, p2, p3));
 1187 |     |     }
 1188 |     | 
 1189 |     |     function log(bool p0, bool p1, bool p2, bool p3) internal view {
 1190 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,bool,bool)", p0, p1, p2, p3));
 1191 |     |     }
 1192 |     | 
 1193 |     |     function log(bool p0, bool p1, bool p2, address p3) internal view {
 1194 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,bool,address)", p0, p1, p2, p3));
 1195 |     |     }
 1196 |     | 
 1197 |     |     function log(bool p0, bool p1, address p2, uint p3) internal view {
 1198 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,address,uint)", p0, p1, p2, p3));
 1199 |     |     }
 1200 |     | 
 1201 |     |     function log(bool p0, bool p1, address p2, string memory p3) internal view {
 1202 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,address,string)", p0, p1, p2, p3));
 1203 |     |     }
 1204 |     | 
 1205 |     |     function log(bool p0, bool p1, address p2, bool p3) internal view {
 1206 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,address,bool)", p0, p1, p2, p3));
 1207 |     |     }
 1208 |     | 
 1209 |     |     function log(bool p0, bool p1, address p2, address p3) internal view {
 1210 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,address,address)", p0, p1, p2, p3));
 1211 |     |     }
 1212 |     | 
 1213 |     |     function log(bool p0, address p1, uint p2, uint p3) internal view {
 1214 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,uint,uint)", p0, p1, p2, p3));
 1215 |     |     }
 1216 |     | 
 1217 |     |     function log(bool p0, address p1, uint p2, string memory p3) internal view {
 1218 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,uint,string)", p0, p1, p2, p3));
 1219 |     |     }
 1220 |     | 
 1221 |     |     function log(bool p0, address p1, uint p2, bool p3) internal view {
 1222 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,uint,bool)", p0, p1, p2, p3));
 1223 |     |     }
 1224 |     | 
 1225 |     |     function log(bool p0, address p1, uint p2, address p3) internal view {
 1226 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,uint,address)", p0, p1, p2, p3));
 1227 |     |     }
 1228 |     | 
 1229 |     |     function log(bool p0, address p1, string memory p2, uint p3) internal view {
 1230 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,string,uint)", p0, p1, p2, p3));
 1231 |     |     }
 1232 |     | 
 1233 |     |     function log(bool p0, address p1, string memory p2, string memory p3) internal view {
 1234 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,string,string)", p0, p1, p2, p3));
 1235 |     |     }
 1236 |     | 
 1237 |     |     function log(bool p0, address p1, string memory p2, bool p3) internal view {
 1238 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,string,bool)", p0, p1, p2, p3));
 1239 |     |     }
 1240 |     | 
 1241 |     |     function log(bool p0, address p1, string memory p2, address p3) internal view {
 1242 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,string,address)", p0, p1, p2, p3));
 1243 |     |     }
 1244 |     | 
 1245 |     |     function log(bool p0, address p1, bool p2, uint p3) internal view {
 1246 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,bool,uint)", p0, p1, p2, p3));
 1247 |     |     }
 1248 |     | 
 1249 |     |     function log(bool p0, address p1, bool p2, string memory p3) internal view {
 1250 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,bool,string)", p0, p1, p2, p3));
 1251 |     |     }
 1252 |     | 
 1253 |     |     function log(bool p0, address p1, bool p2, bool p3) internal view {
 1254 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,bool,bool)", p0, p1, p2, p3));
 1255 |     |     }
 1256 |     | 
 1257 |     |     function log(bool p0, address p1, bool p2, address p3) internal view {
 1258 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,bool,address)", p0, p1, p2, p3));
 1259 |     |     }
 1260 |     | 
 1261 |     |     function log(bool p0, address p1, address p2, uint p3) internal view {
 1262 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,address,uint)", p0, p1, p2, p3));
 1263 |     |     }
 1264 |     | 
 1265 |     |     function log(bool p0, address p1, address p2, string memory p3) internal view {
 1266 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,address,string)", p0, p1, p2, p3));
 1267 |     |     }
 1268 |     | 
 1269 |     |     function log(bool p0, address p1, address p2, bool p3) internal view {
 1270 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,address,bool)", p0, p1, p2, p3));
 1271 |     |     }
 1272 |     | 
 1273 |     |     function log(bool p0, address p1, address p2, address p3) internal view {
 1274 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,address,address)", p0, p1, p2, p3));
 1275 |     |     }
 1276 |     | 
 1277 |     |     function log(address p0, uint p1, uint p2, uint p3) internal view {
 1278 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint,uint,uint)", p0, p1, p2, p3));
 1279 |     |     }
 1280 |     | 
 1281 |     |     function log(address p0, uint p1, uint p2, string memory p3) internal view {
 1282 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint,uint,string)", p0, p1, p2, p3));
 1283 |     |     }
 1284 |     | 
 1285 |     |     function log(address p0, uint p1, uint p2, bool p3) internal view {
 1286 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint,uint,bool)", p0, p1, p2, p3));
 1287 |     |     }
 1288 |     | 
 1289 |     |     function log(address p0, uint p1, uint p2, address p3) internal view {
 1290 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint,uint,address)", p0, p1, p2, p3));
 1291 |     |     }
 1292 |     | 
 1293 |     |     function log(address p0, uint p1, string memory p2, uint p3) internal view {
 1294 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint,string,uint)", p0, p1, p2, p3));
 1295 |     |     }
 1296 |     | 
 1297 |     |     function log(address p0, uint p1, string memory p2, string memory p3) internal view {
 1298 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint,string,string)", p0, p1, p2, p3));
 1299 |     |     }
 1300 |     | 
 1301 |     |     function log(address p0, uint p1, string memory p2, bool p3) internal view {
 1302 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint,string,bool)", p0, p1, p2, p3));
 1303 |     |     }
 1304 |     | 
 1305 |     |     function log(address p0, uint p1, string memory p2, address p3) internal view {
 1306 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint,string,address)", p0, p1, p2, p3));
 1307 |     |     }
 1308 |     | 
 1309 |     |     function log(address p0, uint p1, bool p2, uint p3) internal view {
 1310 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint,bool,uint)", p0, p1, p2, p3));
 1311 |     |     }
 1312 |     | 
 1313 |     |     function log(address p0, uint p1, bool p2, string memory p3) internal view {
 1314 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint,bool,string)", p0, p1, p2, p3));
 1315 |     |     }
 1316 |     | 
 1317 |     |     function log(address p0, uint p1, bool p2, bool p3) internal view {
 1318 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint,bool,bool)", p0, p1, p2, p3));
 1319 |     |     }
 1320 |     | 
 1321 |     |     function log(address p0, uint p1, bool p2, address p3) internal view {
 1322 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint,bool,address)", p0, p1, p2, p3));
 1323 |     |     }
 1324 |     | 
 1325 |     |     function log(address p0, uint p1, address p2, uint p3) internal view {
 1326 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint,address,uint)", p0, p1, p2, p3));
 1327 |     |     }
 1328 |     | 
 1329 |     |     function log(address p0, uint p1, address p2, string memory p3) internal view {
 1330 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint,address,string)", p0, p1, p2, p3));
 1331 |     |     }
 1332 |     | 
 1333 |     |     function log(address p0, uint p1, address p2, bool p3) internal view {
 1334 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint,address,bool)", p0, p1, p2, p3));
 1335 |     |     }
 1336 |     | 
 1337 |     |     function log(address p0, uint p1, address p2, address p3) internal view {
 1338 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint,address,address)", p0, p1, p2, p3));
 1339 |     |     }
 1340 |     | 
 1341 |     |     function log(address p0, string memory p1, uint p2, uint p3) internal view {
 1342 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,uint,uint)", p0, p1, p2, p3));
 1343 |     |     }
 1344 |     | 
 1345 |     |     function log(address p0, string memory p1, uint p2, string memory p3) internal view {
 1346 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,uint,string)", p0, p1, p2, p3));
 1347 |     |     }
 1348 |     | 
 1349 |     |     function log(address p0, string memory p1, uint p2, bool p3) internal view {
 1350 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,uint,bool)", p0, p1, p2, p3));
 1351 |     |     }
 1352 |     | 
 1353 |     |     function log(address p0, string memory p1, uint p2, address p3) internal view {
 1354 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,uint,address)", p0, p1, p2, p3));
 1355 |     |     }
 1356 |     | 
 1357 |     |     function log(address p0, string memory p1, string memory p2, uint p3) internal view {
 1358 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,string,uint)", p0, p1, p2, p3));
 1359 |     |     }
 1360 |     | 
 1361 |     |     function log(address p0, string memory p1, string memory p2, string memory p3) internal view {
 1362 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,string,string)", p0, p1, p2, p3));
 1363 |     |     }
 1364 |     | 
 1365 |     |     function log(address p0, string memory p1, string memory p2, bool p3) internal view {
 1366 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,string,bool)", p0, p1, p2, p3));
 1367 |     |     }
 1368 |     | 
 1369 |     |     function log(address p0, string memory p1, string memory p2, address p3) internal view {
 1370 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,string,address)", p0, p1, p2, p3));
 1371 |     |     }
 1372 |     | 
 1373 |     |     function log(address p0, string memory p1, bool p2, uint p3) internal view {
 1374 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,bool,uint)", p0, p1, p2, p3));
 1375 |     |     }
 1376 |     | 
 1377 |     |     function log(address p0, string memory p1, bool p2, string memory p3) internal view {
 1378 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,bool,string)", p0, p1, p2, p3));
 1379 |     |     }
 1380 |     | 
 1381 |     |     function log(address p0, string memory p1, bool p2, bool p3) internal view {
 1382 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,bool,bool)", p0, p1, p2, p3));
 1383 |     |     }
 1384 |     | 
 1385 |     |     function log(address p0, string memory p1, bool p2, address p3) internal view {
 1386 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,bool,address)", p0, p1, p2, p3));
 1387 |     |     }
 1388 |     | 
 1389 |     |     function log(address p0, string memory p1, address p2, uint p3) internal view {
 1390 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,address,uint)", p0, p1, p2, p3));
 1391 |     |     }
 1392 |     | 
 1393 |     |     function log(address p0, string memory p1, address p2, string memory p3) internal view {
 1394 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,address,string)", p0, p1, p2, p3));
 1395 |     |     }
 1396 |     | 
 1397 |     |     function log(address p0, string memory p1, address p2, bool p3) internal view {
 1398 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,address,bool)", p0, p1, p2, p3));
 1399 |     |     }
 1400 |     | 
 1401 |     |     function log(address p0, string memory p1, address p2, address p3) internal view {
 1402 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,address,address)", p0, p1, p2, p3));
 1403 |     |     }
 1404 |     | 
 1405 |     |     function log(address p0, bool p1, uint p2, uint p3) internal view {
 1406 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,uint,uint)", p0, p1, p2, p3));
 1407 |     |     }
 1408 |     | 
 1409 |     |     function log(address p0, bool p1, uint p2, string memory p3) internal view {
 1410 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,uint,string)", p0, p1, p2, p3));
 1411 |     |     }
 1412 |     | 
 1413 |     |     function log(address p0, bool p1, uint p2, bool p3) internal view {
 1414 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,uint,bool)", p0, p1, p2, p3));
 1415 |     |     }
 1416 |     | 
 1417 |     |     function log(address p0, bool p1, uint p2, address p3) internal view {
 1418 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,uint,address)", p0, p1, p2, p3));
 1419 |     |     }
 1420 |     | 
 1421 |     |     function log(address p0, bool p1, string memory p2, uint p3) internal view {
 1422 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,string,uint)", p0, p1, p2, p3));
 1423 |     |     }
 1424 |     | 
 1425 |     |     function log(address p0, bool p1, string memory p2, string memory p3) internal view {
 1426 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,string,string)", p0, p1, p2, p3));
 1427 |     |     }
 1428 |     | 
 1429 |     |     function log(address p0, bool p1, string memory p2, bool p3) internal view {
 1430 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,string,bool)", p0, p1, p2, p3));
 1431 |     |     }
 1432 |     | 
 1433 |     |     function log(address p0, bool p1, string memory p2, address p3) internal view {
 1434 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,string,address)", p0, p1, p2, p3));
 1435 |     |     }
 1436 |     | 
 1437 |     |     function log(address p0, bool p1, bool p2, uint p3) internal view {
 1438 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,bool,uint)", p0, p1, p2, p3));
 1439 |     |     }
 1440 |     | 
 1441 |     |     function log(address p0, bool p1, bool p2, string memory p3) internal view {
 1442 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,bool,string)", p0, p1, p2, p3));
 1443 |     |     }
 1444 |     | 
 1445 |     |     function log(address p0, bool p1, bool p2, bool p3) internal view {
 1446 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,bool,bool)", p0, p1, p2, p3));
 1447 |     |     }
 1448 |     | 
 1449 |     |     function log(address p0, bool p1, bool p2, address p3) internal view {
 1450 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,bool,address)", p0, p1, p2, p3));
 1451 |     |     }
 1452 |     | 
 1453 |     |     function log(address p0, bool p1, address p2, uint p3) internal view {
 1454 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,address,uint)", p0, p1, p2, p3));
 1455 |     |     }
 1456 |     | 
 1457 |     |     function log(address p0, bool p1, address p2, string memory p3) internal view {
 1458 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,address,string)", p0, p1, p2, p3));
 1459 |     |     }
 1460 |     | 
 1461 |     |     function log(address p0, bool p1, address p2, bool p3) internal view {
 1462 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,address,bool)", p0, p1, p2, p3));
 1463 |     |     }
 1464 |     | 
 1465 |     |     function log(address p0, bool p1, address p2, address p3) internal view {
 1466 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,address,address)", p0, p1, p2, p3));
 1467 |     |     }
 1468 |     | 
 1469 |     |     function log(address p0, address p1, uint p2, uint p3) internal view {
 1470 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,uint,uint)", p0, p1, p2, p3));
 1471 |     |     }
 1472 |     | 
 1473 |     |     function log(address p0, address p1, uint p2, string memory p3) internal view {
 1474 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,uint,string)", p0, p1, p2, p3));
 1475 |     |     }
 1476 |     | 
 1477 |     |     function log(address p0, address p1, uint p2, bool p3) internal view {
 1478 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,uint,bool)", p0, p1, p2, p3));
 1479 |     |     }
 1480 |     | 
 1481 |     |     function log(address p0, address p1, uint p2, address p3) internal view {
 1482 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,uint,address)", p0, p1, p2, p3));
 1483 |     |     }
 1484 |     | 
 1485 |     |     function log(address p0, address p1, string memory p2, uint p3) internal view {
 1486 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,string,uint)", p0, p1, p2, p3));
 1487 |     |     }
 1488 |     | 
 1489 |     |     function log(address p0, address p1, string memory p2, string memory p3) internal view {
 1490 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,string,string)", p0, p1, p2, p3));
 1491 |     |     }
 1492 |     | 
 1493 |     |     function log(address p0, address p1, string memory p2, bool p3) internal view {
 1494 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,string,bool)", p0, p1, p2, p3));
 1495 |     |     }
 1496 |     | 
 1497 |     |     function log(address p0, address p1, string memory p2, address p3) internal view {
 1498 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,string,address)", p0, p1, p2, p3));
 1499 |     |     }
 1500 |     | 
 1501 |     |     function log(address p0, address p1, bool p2, uint p3) internal view {
 1502 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,bool,uint)", p0, p1, p2, p3));
 1503 |     |     }
 1504 |     | 
 1505 |     |     function log(address p0, address p1, bool p2, string memory p3) internal view {
 1506 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,bool,string)", p0, p1, p2, p3));
 1507 |     |     }
 1508 |     | 
 1509 |     |     function log(address p0, address p1, bool p2, bool p3) internal view {
 1510 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,bool,bool)", p0, p1, p2, p3));
 1511 |     |     }
 1512 |     | 
 1513 |     |     function log(address p0, address p1, bool p2, address p3) internal view {
 1514 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,bool,address)", p0, p1, p2, p3));
 1515 |     |     }
 1516 |     | 
 1517 |     |     function log(address p0, address p1, address p2, uint p3) internal view {
 1518 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,address,uint)", p0, p1, p2, p3));
 1519 |     |     }
 1520 |     | 
 1521 |     |     function log(address p0, address p1, address p2, string memory p3) internal view {
 1522 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,address,string)", p0, p1, p2, p3));
 1523 |     |     }
 1524 |     | 
 1525 |     |     function log(address p0, address p1, address p2, bool p3) internal view {
 1526 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,address,bool)", p0, p1, p2, p3));
 1527 |     |     }
 1528 |     | 
 1529 |     |     function log(address p0, address p1, address p2, address p3) internal view {
 1530 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,address,address)", p0, p1, p2, p3));
 1531 |     |     }
 1532 |     | 
 1533 |     | }

/Users/nelsonpereira/Documents/GitHub/Auditing/Fuzzy/Blogs/ElasticSwap_Recon/elasticswap-recon/node_modules/@openzeppelin/contracts/access/Ownable.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable.sol)
  3 |     | 
  4 |     | pragma solidity ^0.8.0;
  5 |     | 
  6 |     | import "../utils/Context.sol";
  7 |     | 
  8 |     | /**
  9 |     |  * @dev Contract module which provides a basic access control mechanism, where
 10 |     |  * there is an account (an owner) that can be granted exclusive access to
 11 |     |  * specific functions.
 12 |     |  *
 13 |     |  * By default, the owner account will be the one that deploys the contract. This
 14 |     |  * can later be changed with {transferOwnership}.
 15 |     |  *
 16 |     |  * This module is used through inheritance. It will make available the modifier
 17 |     |  * `onlyOwner`, which can be applied to your functions to restrict their use to
 18 |     |  * the owner.
 19 |     |  */
 20 |     | abstract contract Ownable is Context {
 21 |     |     address private _owner;
 22 |     | 
 23 |     |     event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);
 24 |     | 
 25 |     |     /**
 26 |     |      * @dev Initializes the contract setting the deployer as the initial owner.
 27 |     |      */
 28 |     |     constructor() {
 29 |     |         _transferOwnership(_msgSender());
 30 |     |     }
 31 |     | 
 32 |     |     /**
 33 |     |      * @dev Throws if called by any account other than the owner.
 34 |     |      */
 35 |     |     modifier onlyOwner() {
 36 |     |         _checkOwner();
 37 |     |         _;
 38 |     |     }
 39 |     | 
 40 |     |     /**
 41 |     |      * @dev Returns the address of the current owner.
 42 |     |      */
 43 |     |     function owner() public view virtual returns (address) {
 44 |     |         return _owner;
 45 |     |     }
 46 |     | 
 47 |     |     /**
 48 |     |      * @dev Throws if the sender is not the owner.
 49 |     |      */
 50 |     |     function _checkOwner() internal view virtual {
 51 |     |         require(owner() == _msgSender(), "Ownable: caller is not the owner");
 52 |     |     }
 53 |     | 
 54 |     |     /**
 55 |     |      * @dev Leaves the contract without owner. It will not be possible to call
 56 |     |      * `onlyOwner` functions. Can only be called by the current owner.
 57 |     |      *
 58 |     |      * NOTE: Renouncing ownership will leave the contract without an owner,
 59 |     |      * thereby disabling any functionality that is only available to the owner.
 60 |     |      */
 61 |     |     function renounceOwnership() public virtual onlyOwner {
 62 |     |         _transferOwnership(address(0));
 63 |     |     }
 64 |     | 
 65 |     |     /**
 66 |     |      * @dev Transfers ownership of the contract to a new account (`newOwner`).
 67 |     |      * Can only be called by the current owner.
 68 |     |      */
 69 |     |     function transferOwnership(address newOwner) public virtual onlyOwner {
 70 |     |         require(newOwner != address(0), "Ownable: new owner is the zero address");
 71 |     |         _transferOwnership(newOwner);
 72 |     |     }
 73 |     | 
 74 |     |     /**
 75 |     |      * @dev Transfers ownership of the contract to a new account (`newOwner`).
 76 |     |      * Internal function without access restriction.
 77 |     |      */
 78 | *   |     function _transferOwnership(address newOwner) internal virtual {
 79 | *   |         address oldOwner = _owner;
 80 | *   |         _owner = newOwner;
 81 |     |         emit OwnershipTransferred(oldOwner, newOwner);
 82 |     |     }
 83 |     | }
 84 |     | 

/Users/nelsonpereira/Documents/GitHub/Auditing/Fuzzy/Blogs/ElasticSwap_Recon/elasticswap-recon/node_modules/@openzeppelin/contracts/security/ReentrancyGuard.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // OpenZeppelin Contracts (last updated v4.9.0) (security/ReentrancyGuard.sol)
  3 |     | 
  4 |     | pragma solidity ^0.8.0;
  5 |     | 
  6 |     | /**
  7 |     |  * @dev Contract module that helps prevent reentrant calls to a function.
  8 |     |  *
  9 |     |  * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier
 10 |     |  * available, which can be applied to functions to make sure there are no nested
 11 |     |  * (reentrant) calls to them.
 12 |     |  *
 13 |     |  * Note that because there is a single `nonReentrant` guard, functions marked as
 14 |     |  * `nonReentrant` may not call one another. This can be worked around by making
 15 |     |  * those functions `private`, and then adding `external` `nonReentrant` entry
 16 |     |  * points to them.
 17 |     |  *
 18 |     |  * TIP: If you would like to learn more about reentrancy and alternative ways
 19 |     |  * to protect against it, check out our blog post
 20 |     |  * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].
 21 |     |  */
 22 |     | abstract contract ReentrancyGuard {
 23 |     |     // Booleans are more expensive than uint256 or any type that takes up a full
 24 |     |     // word because each write operation emits an extra SLOAD to first read the
 25 |     |     // slot's contents, replace the bits taken up by the boolean, and then write
 26 |     |     // back. This is the compiler's defense against contract upgrades and
 27 |     |     // pointer aliasing, and it cannot be disabled.
 28 |     | 
 29 |     |     // The values being non-zero value makes deployment a bit more expensive,
 30 |     |     // but in exchange the refund on every call to nonReentrant will be lower in
 31 |     |     // amount. Since refunds are capped to a percentage of the total
 32 |     |     // transaction's gas, it is best to keep them low in cases like this one, to
 33 |     |     // increase the likelihood of the full refund coming into effect.
 34 |     |     uint256 private constant _NOT_ENTERED = 1;
 35 | *   |     uint256 private constant _ENTERED = 2;
 36 |     | 
 37 |     |     uint256 private _status;
 38 |     | 
 39 |     |     constructor() {
 40 |     |         _status = _NOT_ENTERED;
 41 |     |     }
 42 |     | 
 43 |     |     /**
 44 |     |      * @dev Prevents a contract from calling itself, directly or indirectly.
 45 |     |      * Calling a `nonReentrant` function from another `nonReentrant`
 46 |     |      * function is not supported. It is possible to prevent this from happening
 47 |     |      * by making the `nonReentrant` function external, and making it call a
 48 |     |      * `private` function that does the actual work.
 49 |     |      */
 50 |     |     modifier nonReentrant() {
 51 | *   |         _nonReentrantBefore();
 52 |     |         _;
 53 | *   |         _nonReentrantAfter();
 54 |     |     }
 55 |     | 
 56 | *   |     function _nonReentrantBefore() private {
 57 |     |         // On the first call to nonReentrant, _status will be _NOT_ENTERED
 58 | *   |         require(_status != _ENTERED, "ReentrancyGuard: reentrant call");
 59 |     | 
 60 |     |         // Any calls to nonReentrant after this point will fail
 61 | *   |         _status = _ENTERED;
 62 |     |     }
 63 |     | 
 64 | *   |     function _nonReentrantAfter() private {
 65 |     |         // By storing the original value once again, a refund is triggered (see
 66 |     |         // https://eips.ethereum.org/EIPS/eip-2200)
 67 | *   |         _status = _NOT_ENTERED;
 68 |     |     }
 69 |     | 
 70 |     |     /**
 71 |     |      * @dev Returns true if the reentrancy guard is currently set to "entered", which indicates there is a
 72 |     |      * `nonReentrant` function in the call stack.
 73 |     |      */
 74 |     |     function _reentrancyGuardEntered() internal view returns (bool) {
 75 |     |         return _status == _ENTERED;
 76 |     |     }
 77 |     | }
 78 |     | 

/Users/nelsonpereira/Documents/GitHub/Auditing/Fuzzy/Blogs/ElasticSwap_Recon/elasticswap-recon/node_modules/@openzeppelin/contracts/token/ERC20/ERC20.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | // OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/ERC20.sol)
   3 |     | 
   4 |     | pragma solidity ^0.8.0;
   5 |     | 
   6 |     | import "./IERC20.sol";
   7 |     | import "./extensions/IERC20Metadata.sol";
   8 |     | import "../../utils/Context.sol";
   9 |     | 
  10 |     | /**
  11 |     |  * @dev Implementation of the {IERC20} interface.
  12 |     |  *
  13 |     |  * This implementation is agnostic to the way tokens are created. This means
  14 |     |  * that a supply mechanism has to be added in a derived contract using {_mint}.
  15 |     |  * For a generic mechanism see {ERC20PresetMinterPauser}.
  16 |     |  *
  17 |     |  * TIP: For a detailed writeup see our guide
  18 |     |  * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How
  19 |     |  * to implement supply mechanisms].
  20 |     |  *
  21 |     |  * The default value of {decimals} is 18. To change this, you should override
  22 |     |  * this function so it returns a different value.
  23 |     |  *
  24 |     |  * We have followed general OpenZeppelin Contracts guidelines: functions revert
  25 |     |  * instead returning `false` on failure. This behavior is nonetheless
  26 |     |  * conventional and does not conflict with the expectations of ERC20
  27 |     |  * applications.
  28 |     |  *
  29 |     |  * Additionally, an {Approval} event is emitted on calls to {transferFrom}.
  30 |     |  * This allows applications to reconstruct the allowance for all accounts just
  31 |     |  * by listening to said events. Other implementations of the EIP may not emit
  32 |     |  * these events, as it isn't required by the specification.
  33 |     |  *
  34 |     |  * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}
  35 |     |  * functions have been added to mitigate the well-known issues around setting
  36 |     |  * allowances. See {IERC20-approve}.
  37 |     |  */
  38 |     | contract ERC20 is Context, IERC20, IERC20Metadata {
  39 |     |     mapping(address => uint256) private _balances;
  40 |     | 
  41 |     |     mapping(address => mapping(address => uint256)) private _allowances;
  42 |     | 
  43 |     |     uint256 private _totalSupply;
  44 |     | 
  45 |     |     string private _name;
  46 |     |     string private _symbol;
  47 |     | 
  48 |     |     /**
  49 |     |      * @dev Sets the values for {name} and {symbol}.
  50 |     |      *
  51 |     |      * All two of these values are immutable: they can only be set once during
  52 |     |      * construction.
  53 |     |      */
  54 |     |     constructor(string memory name_, string memory symbol_) {
  55 |     |         _name = name_;
  56 |     |         _symbol = symbol_;
  57 |     |     }
  58 |     | 
  59 |     |     /**
  60 |     |      * @dev Returns the name of the token.
  61 |     |      */
  62 | *   |     function name() public view virtual override returns (string memory) {
  63 | *   |         return _name;
  64 |     |     }
  65 |     | 
  66 |     |     /**
  67 |     |      * @dev Returns the symbol of the token, usually a shorter version of the
  68 |     |      * name.
  69 |     |      */
  70 | *   |     function symbol() public view virtual override returns (string memory) {
  71 | *   |         return _symbol;
  72 |     |     }
  73 |     | 
  74 |     |     /**
  75 |     |      * @dev Returns the number of decimals used to get its user representation.
  76 |     |      * For example, if `decimals` equals `2`, a balance of `505` tokens should
  77 |     |      * be displayed to a user as `5.05` (`505 / 10 ** 2`).
  78 |     |      *
  79 |     |      * Tokens usually opt for a value of 18, imitating the relationship between
  80 |     |      * Ether and Wei. This is the default value returned by this function, unless
  81 |     |      * it's overridden.
  82 |     |      *
  83 |     |      * NOTE: This information is only used for _display_ purposes: it in
  84 |     |      * no way affects any of the arithmetic of the contract, including
  85 |     |      * {IERC20-balanceOf} and {IERC20-transfer}.
  86 |     |      */
  87 |     |     function decimals() public view virtual override returns (uint8) {
  88 |     |         return 18;
  89 |     |     }
  90 |     | 
  91 |     |     /**
  92 |     |      * @dev See {IERC20-totalSupply}.
  93 |     |      */
  94 | *   |     function totalSupply() public view virtual override returns (uint256) {
  95 | *   |         return _totalSupply;
  96 |     |     }
  97 |     | 
  98 |     |     /**
  99 |     |      * @dev See {IERC20-balanceOf}.
 100 |     |      */
 101 | *   |     function balanceOf(address account) public view virtual override returns (uint256) {
 102 | *   |         return _balances[account];
 103 |     |     }
 104 |     | 
 105 |     |     /**
 106 |     |      * @dev See {IERC20-transfer}.
 107 |     |      *
 108 |     |      * Requirements:
 109 |     |      *
 110 |     |      * - `to` cannot be the zero address.
 111 |     |      * - the caller must have a balance of at least `amount`.
 112 |     |      */
 113 | *   |     function transfer(address to, uint256 amount) public virtual override returns (bool) {
 114 |     |         address owner = _msgSender();
 115 | *   |         _transfer(owner, to, amount);
 116 |     |         return true;
 117 |     |     }
 118 |     | 
 119 |     |     /**
 120 |     |      * @dev See {IERC20-allowance}.
 121 |     |      */
 122 | *   |     function allowance(address owner, address spender) public view virtual override returns (uint256) {
 123 | *   |         return _allowances[owner][spender];
 124 |     |     }
 125 |     | 
 126 |     |     /**
 127 |     |      * @dev See {IERC20-approve}.
 128 |     |      *
 129 |     |      * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on
 130 |     |      * `transferFrom`. This is semantically equivalent to an infinite approval.
 131 |     |      *
 132 |     |      * Requirements:
 133 |     |      *
 134 |     |      * - `spender` cannot be the zero address.
 135 |     |      */
 136 | *   |     function approve(address spender, uint256 amount) public virtual override returns (bool) {
 137 |     |         address owner = _msgSender();
 138 | *   |         _approve(owner, spender, amount);
 139 | *   |         return true;
 140 |     |     }
 141 |     | 
 142 |     |     /**
 143 |     |      * @dev See {IERC20-transferFrom}.
 144 |     |      *
 145 |     |      * Emits an {Approval} event indicating the updated allowance. This is not
 146 |     |      * required by the EIP. See the note at the beginning of {ERC20}.
 147 |     |      *
 148 |     |      * NOTE: Does not update the allowance if the current allowance
 149 |     |      * is the maximum `uint256`.
 150 |     |      *
 151 |     |      * Requirements:
 152 |     |      *
 153 |     |      * - `from` and `to` cannot be the zero address.
 154 |     |      * - `from` must have a balance of at least `amount`.
 155 |     |      * - the caller must have allowance for ``from``'s tokens of at least
 156 |     |      * `amount`.
 157 |     |      */
 158 | *   |     function transferFrom(address from, address to, uint256 amount) public virtual override returns (bool) {
 159 |     |         address spender = _msgSender();
 160 | *   |         _spendAllowance(from, spender, amount);
 161 |     |         _transfer(from, to, amount);
 162 | *   |         return true;
 163 |     |     }
 164 |     | 
 165 |     |     /**
 166 |     |      * @dev Atomically increases the allowance granted to `spender` by the caller.
 167 |     |      *
 168 |     |      * This is an alternative to {approve} that can be used as a mitigation for
 169 |     |      * problems described in {IERC20-approve}.
 170 |     |      *
 171 |     |      * Emits an {Approval} event indicating the updated allowance.
 172 |     |      *
 173 |     |      * Requirements:
 174 |     |      *
 175 |     |      * - `spender` cannot be the zero address.
 176 |     |      */
 177 |     |     function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {
 178 |     |         address owner = _msgSender();
 179 |     |         _approve(owner, spender, allowance(owner, spender) + addedValue);
 180 |     |         return true;
 181 |     |     }
 182 |     | 
 183 |     |     /**
 184 |     |      * @dev Atomically decreases the allowance granted to `spender` by the caller.
 185 |     |      *
 186 |     |      * This is an alternative to {approve} that can be used as a mitigation for
 187 |     |      * problems described in {IERC20-approve}.
 188 |     |      *
 189 |     |      * Emits an {Approval} event indicating the updated allowance.
 190 |     |      *
 191 |     |      * Requirements:
 192 |     |      *
 193 |     |      * - `spender` cannot be the zero address.
 194 |     |      * - `spender` must have allowance for the caller of at least
 195 |     |      * `subtractedValue`.
 196 |     |      */
 197 | *   |     function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {
 198 |     |         address owner = _msgSender();
 199 |     |         uint256 currentAllowance = allowance(owner, spender);
 200 | *   |         require(currentAllowance >= subtractedValue, "ERC20: decreased allowance below zero");
 201 |     |         unchecked {
 202 | *   |             _approve(owner, spender, currentAllowance - subtractedValue);
 203 |     |         }
 204 |     | 
 205 |     |         return true;
 206 |     |     }
 207 |     | 
 208 |     |     /**
 209 |     |      * @dev Moves `amount` of tokens from `from` to `to`.
 210 |     |      *
 211 |     |      * This internal function is equivalent to {transfer}, and can be used to
 212 |     |      * e.g. implement automatic token fees, slashing mechanisms, etc.
 213 |     |      *
 214 |     |      * Emits a {Transfer} event.
 215 |     |      *
 216 |     |      * Requirements:
 217 |     |      *
 218 |     |      * - `from` cannot be the zero address.
 219 |     |      * - `to` cannot be the zero address.
 220 |     |      * - `from` must have a balance of at least `amount`.
 221 |     |      */
 222 | *   |     function _transfer(address from, address to, uint256 amount) internal virtual {
 223 | *   |         require(from != address(0), "ERC20: transfer from the zero address");
 224 | *   |         require(to != address(0), "ERC20: transfer to the zero address");
 225 |     | 
 226 |     |         _beforeTokenTransfer(from, to, amount);
 227 |     | 
 228 | *   |         uint256 fromBalance = _balances[from];
 229 | *   |         require(fromBalance >= amount, "ERC20: transfer amount exceeds balance");
 230 |     |         unchecked {
 231 | *   |             _balances[from] = fromBalance - amount;
 232 |     |             // Overflow not possible: the sum of all balances is capped by totalSupply, and the sum is preserved by
 233 |     |             // decrementing then incrementing.
 234 | *   |             _balances[to] += amount;
 235 |     |         }
 236 |     | 
 237 | *   |         emit Transfer(from, to, amount);
 238 |     | 
 239 | *   |         _afterTokenTransfer(from, to, amount);
 240 |     |     }
 241 |     | 
 242 |     |     /** @dev Creates `amount` tokens and assigns them to `account`, increasing
 243 |     |      * the total supply.
 244 |     |      *
 245 |     |      * Emits a {Transfer} event with `from` set to the zero address.
 246 |     |      *
 247 |     |      * Requirements:
 248 |     |      *
 249 |     |      * - `account` cannot be the zero address.
 250 |     |      */
 251 | *   |     function _mint(address account, uint256 amount) internal virtual {
 252 | *   |         require(account != address(0), "ERC20: mint to the zero address");
 253 |     | 
 254 |     |         _beforeTokenTransfer(address(0), account, amount);
 255 |     | 
 256 | *   |         _totalSupply += amount;
 257 |     |         unchecked {
 258 |     |             // Overflow not possible: balance + amount is at most totalSupply + amount, which is checked above.
 259 |     |             _balances[account] += amount;
 260 |     |         }
 261 | *   |         emit Transfer(address(0), account, amount);
 262 |     | 
 263 |     |         _afterTokenTransfer(address(0), account, amount);
 264 |     |     }
 265 |     | 
 266 |     |     /**
 267 |     |      * @dev Destroys `amount` tokens from `account`, reducing the
 268 |     |      * total supply.
 269 |     |      *
 270 |     |      * Emits a {Transfer} event with `to` set to the zero address.
 271 |     |      *
 272 |     |      * Requirements:
 273 |     |      *
 274 |     |      * - `account` cannot be the zero address.
 275 |     |      * - `account` must have at least `amount` tokens.
 276 |     |      */
 277 |     |     function _burn(address account, uint256 amount) internal virtual {
 278 | *   |         require(account != address(0), "ERC20: burn from the zero address");
 279 |     | 
 280 |     |         _beforeTokenTransfer(account, address(0), amount);
 281 |     | 
 282 | *   |         uint256 accountBalance = _balances[account];
 283 | *   |         require(accountBalance >= amount, "ERC20: burn amount exceeds balance");
 284 |     |         unchecked {
 285 | *   |             _balances[account] = accountBalance - amount;
 286 |     |             // Overflow not possible: amount <= accountBalance <= totalSupply.
 287 | *   |             _totalSupply -= amount;
 288 |     |         }
 289 |     | 
 290 | *   |         emit Transfer(account, address(0), amount);
 291 |     | 
 292 |     |         _afterTokenTransfer(account, address(0), amount);
 293 |     |     }
 294 |     | 
 295 |     |     /**
 296 |     |      * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.
 297 |     |      *
 298 |     |      * This internal function is equivalent to `approve`, and can be used to
 299 |     |      * e.g. set automatic allowances for certain subsystems, etc.
 300 |     |      *
 301 |     |      * Emits an {Approval} event.
 302 |     |      *
 303 |     |      * Requirements:
 304 |     |      *
 305 |     |      * - `owner` cannot be the zero address.
 306 |     |      * - `spender` cannot be the zero address.
 307 |     |      */
 308 | *   |     function _approve(address owner, address spender, uint256 amount) internal virtual {
 309 | *   |         require(owner != address(0), "ERC20: approve from the zero address");
 310 | *   |         require(spender != address(0), "ERC20: approve to the zero address");
 311 |     | 
 312 | *   |         _allowances[owner][spender] = amount;
 313 | *   |         emit Approval(owner, spender, amount);
 314 |     |     }
 315 |     | 
 316 |     |     /**
 317 |     |      * @dev Updates `owner` s allowance for `spender` based on spent `amount`.
 318 |     |      *
 319 |     |      * Does not update the allowance amount in case of infinite allowance.
 320 |     |      * Revert if not enough allowance is available.
 321 |     |      *
 322 |     |      * Might emit an {Approval} event.
 323 |     |      */
 324 | *   |     function _spendAllowance(address owner, address spender, uint256 amount) internal virtual {
 325 | *   |         uint256 currentAllowance = allowance(owner, spender);
 326 |     |         if (currentAllowance != type(uint256).max) {
 327 | *   |             require(currentAllowance >= amount, "ERC20: insufficient allowance");
 328 |     |             unchecked {
 329 | *   |                 _approve(owner, spender, currentAllowance - amount);
 330 |     |             }
 331 |     |         }
 332 |     |     }
 333 |     | 
 334 |     |     /**
 335 |     |      * @dev Hook that is called before any transfer of tokens. This includes
 336 |     |      * minting and burning.
 337 |     |      *
 338 |     |      * Calling conditions:
 339 |     |      *
 340 |     |      * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens
 341 |     |      * will be transferred to `to`.
 342 |     |      * - when `from` is zero, `amount` tokens will be minted for `to`.
 343 |     |      * - when `to` is zero, `amount` of ``from``'s tokens will be burned.
 344 |     |      * - `from` and `to` are never both zero.
 345 |     |      *
 346 |     |      * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].
 347 |     |      */
 348 |     |     function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual {}
 349 |     | 
 350 |     |     /**
 351 |     |      * @dev Hook that is called after any transfer of tokens. This includes
 352 |     |      * minting and burning.
 353 |     |      *
 354 |     |      * Calling conditions:
 355 |     |      *
 356 |     |      * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens
 357 |     |      * has been transferred to `to`.
 358 |     |      * - when `from` is zero, `amount` tokens have been minted for `to`.
 359 |     |      * - when `to` is zero, `amount` of ``from``'s tokens have been burned.
 360 |     |      * - `from` and `to` are never both zero.
 361 |     |      *
 362 |     |      * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].
 363 |     |      */
 364 |     |     function _afterTokenTransfer(address from, address to, uint256 amount) internal virtual {}
 365 |     | }
 366 |     | 

/Users/nelsonpereira/Documents/GitHub/Auditing/Fuzzy/Blogs/ElasticSwap_Recon/elasticswap-recon/node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)
  3 |     | 
  4 |     | pragma solidity ^0.8.0;
  5 |     | 
  6 |     | /**
  7 |     |  * @dev Interface of the ERC20 standard as defined in the EIP.
  8 |     |  */
  9 |     | interface IERC20 {
 10 |     |     /**
 11 |     |      * @dev Emitted when `value` tokens are moved from one account (`from`) to
 12 |     |      * another (`to`).
 13 |     |      *
 14 |     |      * Note that `value` may be zero.
 15 |     |      */
 16 |     |     event Transfer(address indexed from, address indexed to, uint256 value);
 17 |     | 
 18 |     |     /**
 19 |     |      * @dev Emitted when the allowance of a `spender` for an `owner` is set by
 20 |     |      * a call to {approve}. `value` is the new allowance.
 21 |     |      */
 22 |     |     event Approval(address indexed owner, address indexed spender, uint256 value);
 23 |     | 
 24 |     |     /**
 25 |     |      * @dev Returns the amount of tokens in existence.
 26 |     |      */
 27 |     |     function totalSupply() external view returns (uint256);
 28 |     | 
 29 |     |     /**
 30 |     |      * @dev Returns the amount of tokens owned by `account`.
 31 |     |      */
 32 |     |     function balanceOf(address account) external view returns (uint256);
 33 |     | 
 34 |     |     /**
 35 |     |      * @dev Moves `amount` tokens from the caller's account to `to`.
 36 |     |      *
 37 |     |      * Returns a boolean value indicating whether the operation succeeded.
 38 |     |      *
 39 |     |      * Emits a {Transfer} event.
 40 |     |      */
 41 |     |     function transfer(address to, uint256 amount) external returns (bool);
 42 |     | 
 43 |     |     /**
 44 |     |      * @dev Returns the remaining number of tokens that `spender` will be
 45 |     |      * allowed to spend on behalf of `owner` through {transferFrom}. This is
 46 |     |      * zero by default.
 47 |     |      *
 48 |     |      * This value changes when {approve} or {transferFrom} are called.
 49 |     |      */
 50 |     |     function allowance(address owner, address spender) external view returns (uint256);
 51 |     | 
 52 |     |     /**
 53 |     |      * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.
 54 |     |      *
 55 |     |      * Returns a boolean value indicating whether the operation succeeded.
 56 |     |      *
 57 |     |      * IMPORTANT: Beware that changing an allowance with this method brings the risk
 58 |     |      * that someone may use both the old and the new allowance by unfortunate
 59 |     |      * transaction ordering. One possible solution to mitigate this race
 60 |     |      * condition is to first reduce the spender's allowance to 0 and set the
 61 |     |      * desired value afterwards:
 62 |     |      * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
 63 |     |      *
 64 |     |      * Emits an {Approval} event.
 65 |     |      */
 66 |     |     function approve(address spender, uint256 amount) external returns (bool);
 67 |     | 
 68 |     |     /**
 69 |     |      * @dev Moves `amount` tokens from `from` to `to` using the
 70 |     |      * allowance mechanism. `amount` is then deducted from the caller's
 71 |     |      * allowance.
 72 |     |      *
 73 |     |      * Returns a boolean value indicating whether the operation succeeded.
 74 |     |      *
 75 |     |      * Emits a {Transfer} event.
 76 |     |      */
 77 |     |     function transferFrom(address from, address to, uint256 amount) external returns (bool);
 78 |     | }
 79 |     | 

/Users/nelsonpereira/Documents/GitHub/Auditing/Fuzzy/Blogs/ElasticSwap_Recon/elasticswap-recon/node_modules/@openzeppelin/contracts/token/ERC20/extensions/ERC20Burnable.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/extensions/ERC20Burnable.sol)
  3 |     | 
  4 |     | pragma solidity ^0.8.0;
  5 |     | 
  6 |     | import "../ERC20.sol";
  7 |     | import "../../../utils/Context.sol";
  8 |     | 
  9 |     | /**
 10 |     |  * @dev Extension of {ERC20} that allows token holders to destroy both their own
 11 |     |  * tokens and those that they have an allowance for, in a way that can be
 12 |     |  * recognized off-chain (via event analysis).
 13 |     |  */
 14 |     | abstract contract ERC20Burnable is Context, ERC20 {
 15 |     |     /**
 16 |     |      * @dev Destroys `amount` tokens from the caller.
 17 |     |      *
 18 |     |      * See {ERC20-_burn}.
 19 |     |      */
 20 |     |     function burn(uint256 amount) public virtual {
 21 |     |         _burn(_msgSender(), amount);
 22 |     |     }
 23 |     | 
 24 |     |     /**
 25 |     |      * @dev Destroys `amount` tokens from `account`, deducting from the caller's
 26 |     |      * allowance.
 27 |     |      *
 28 |     |      * See {ERC20-_burn} and {ERC20-allowance}.
 29 |     |      *
 30 |     |      * Requirements:
 31 |     |      *
 32 |     |      * - the caller must have allowance for ``accounts``'s tokens of at least
 33 |     |      * `amount`.
 34 |     |      */
 35 |     |     function burnFrom(address account, uint256 amount) public virtual {
 36 |     |         _spendAllowance(account, _msgSender(), amount);
 37 | *   |         _burn(account, amount);
 38 |     |     }
 39 |     | }
 40 |     | 

/Users/nelsonpereira/Documents/GitHub/Auditing/Fuzzy/Blogs/ElasticSwap_Recon/elasticswap-recon/node_modules/@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)
  3 |     | 
  4 |     | pragma solidity ^0.8.0;
  5 |     | 
  6 |     | import "../IERC20.sol";
  7 |     | 
  8 |     | /**
  9 |     |  * @dev Interface for the optional metadata functions from the ERC20 standard.
 10 |     |  *
 11 |     |  * _Available since v4.1._
 12 |     |  */
 13 |     | interface IERC20Metadata is IERC20 {
 14 |     |     /**
 15 |     |      * @dev Returns the name of the token.
 16 |     |      */
 17 |     |     function name() external view returns (string memory);
 18 |     | 
 19 |     |     /**
 20 |     |      * @dev Returns the symbol of the token.
 21 |     |      */
 22 |     |     function symbol() external view returns (string memory);
 23 |     | 
 24 |     |     /**
 25 |     |      * @dev Returns the decimals places of the token.
 26 |     |      */
 27 |     |     function decimals() external view returns (uint8);
 28 |     | }
 29 |     | 

/Users/nelsonpereira/Documents/GitHub/Auditing/Fuzzy/Blogs/ElasticSwap_Recon/elasticswap-recon/node_modules/@openzeppelin/contracts/token/ERC20/extensions/IERC20Permit.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // OpenZeppelin Contracts (last updated v4.9.4) (token/ERC20/extensions/IERC20Permit.sol)
  3 |     | 
  4 |     | pragma solidity ^0.8.0;
  5 |     | 
  6 |     | /**
  7 |     |  * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in
  8 |     |  * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].
  9 |     |  *
 10 |     |  * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by
 11 |     |  * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't
 12 |     |  * need to send a transaction, and thus is not required to hold Ether at all.
 13 |     |  *
 14 |     |  * ==== Security Considerations
 15 |     |  *
 16 |     |  * There are two important considerations concerning the use of `permit`. The first is that a valid permit signature
 17 |     |  * expresses an allowance, and it should not be assumed to convey additional meaning. In particular, it should not be
 18 |     |  * considered as an intention to spend the allowance in any specific way. The second is that because permits have
 19 |     |  * built-in replay protection and can be submitted by anyone, they can be frontrun. A protocol that uses permits should
 20 |     |  * take this into consideration and allow a `permit` call to fail. Combining these two aspects, a pattern that may be
 21 |     |  * generally recommended is:
 22 |     |  *
 23 |     |  * ```solidity
 24 |     |  * function doThingWithPermit(..., uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) public {
 25 |     |  *     try token.permit(msg.sender, address(this), value, deadline, v, r, s) {} catch {}
 26 |     |  *     doThing(..., value);
 27 |     |  * }
 28 |     |  *
 29 |     |  * function doThing(..., uint256 value) public {
 30 |     |  *     token.safeTransferFrom(msg.sender, address(this), value);
 31 |     |  *     ...
 32 |     |  * }
 33 |     |  * ```
 34 |     |  *
 35 |     |  * Observe that: 1) `msg.sender` is used as the owner, leaving no ambiguity as to the signer intent, and 2) the use of
 36 |     |  * `try/catch` allows the permit to fail and makes the code tolerant to frontrunning. (See also
 37 |     |  * {SafeERC20-safeTransferFrom}).
 38 |     |  *
 39 |     |  * Additionally, note that smart contract wallets (such as Argent or Safe) are not able to produce permit signatures, so
 40 |     |  * contracts should have entry points that don't rely on permit.
 41 |     |  */
 42 |     | interface IERC20Permit {
 43 |     |     /**
 44 |     |      * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,
 45 |     |      * given ``owner``'s signed approval.
 46 |     |      *
 47 |     |      * IMPORTANT: The same issues {IERC20-approve} has related to transaction
 48 |     |      * ordering also apply here.
 49 |     |      *
 50 |     |      * Emits an {Approval} event.
 51 |     |      *
 52 |     |      * Requirements:
 53 |     |      *
 54 |     |      * - `spender` cannot be the zero address.
 55 |     |      * - `deadline` must be a timestamp in the future.
 56 |     |      * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`
 57 |     |      * over the EIP712-formatted function arguments.
 58 |     |      * - the signature must use ``owner``'s current nonce (see {nonces}).
 59 |     |      *
 60 |     |      * For more information on the signature format, see the
 61 |     |      * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP
 62 |     |      * section].
 63 |     |      *
 64 |     |      * CAUTION: See Security Considerations above.
 65 |     |      */
 66 |     |     function permit(
 67 |     |         address owner,
 68 |     |         address spender,
 69 |     |         uint256 value,
 70 |     |         uint256 deadline,
 71 |     |         uint8 v,
 72 |     |         bytes32 r,
 73 |     |         bytes32 s
 74 |     |     ) external;
 75 |     | 
 76 |     |     /**
 77 |     |      * @dev Returns the current nonce for `owner`. This value must be
 78 |     |      * included whenever a signature is generated for {permit}.
 79 |     |      *
 80 |     |      * Every successful call to {permit} increases ``owner``'s nonce by one. This
 81 |     |      * prevents a signature from being used multiple times.
 82 |     |      */
 83 |     |     function nonces(address owner) external view returns (uint256);
 84 |     | 
 85 |     |     /**
 86 |     |      * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.
 87 |     |      */
 88 |     |     // solhint-disable-next-line func-name-mixedcase
 89 |     |     function DOMAIN_SEPARATOR() external view returns (bytes32);
 90 |     | }
 91 |     | 

/Users/nelsonpereira/Documents/GitHub/Auditing/Fuzzy/Blogs/ElasticSwap_Recon/elasticswap-recon/node_modules/@openzeppelin/contracts/token/ERC20/presets/ERC20PresetFixedSupply.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/presets/ERC20PresetFixedSupply.sol)
  3 |     | pragma solidity ^0.8.0;
  4 |     | 
  5 |     | import "../extensions/ERC20Burnable.sol";
  6 |     | 
  7 |     | /**
  8 |     |  * @dev {ERC20} token, including:
  9 |     |  *
 10 |     |  *  - Preminted initial supply
 11 |     |  *  - Ability for holders to burn (destroy) their tokens
 12 |     |  *  - No access control mechanism (for minting/pausing) and hence no governance
 13 |     |  *
 14 |     |  * This contract uses {ERC20Burnable} to include burn capabilities - head to
 15 |     |  * its documentation for details.
 16 |     |  *
 17 |     |  * _Available since v3.4._
 18 |     |  *
 19 |     |  * _Deprecated in favor of https://wizard.openzeppelin.com/[Contracts Wizard]._
 20 |     |  */
 21 |     | contract ERC20PresetFixedSupply is ERC20Burnable {
 22 |     |     /**
 23 |     |      * @dev Mints `initialSupply` amount of token and transfers them to `owner`.
 24 |     |      *
 25 |     |      * See {ERC20-constructor}.
 26 |     |      */
 27 |     |     constructor(string memory name, string memory symbol, uint256 initialSupply, address owner) ERC20(name, symbol) {
 28 |     |         _mint(owner, initialSupply);
 29 |     |     }
 30 |     | }
 31 |     | 

/Users/nelsonpereira/Documents/GitHub/Auditing/Fuzzy/Blogs/ElasticSwap_Recon/elasticswap-recon/node_modules/@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | // OpenZeppelin Contracts (last updated v4.9.3) (token/ERC20/utils/SafeERC20.sol)
   3 |     | 
   4 |     | pragma solidity ^0.8.0;
   5 |     | 
   6 |     | import "../IERC20.sol";
   7 |     | import "../extensions/IERC20Permit.sol";
   8 |     | import "../../../utils/Address.sol";
   9 |     | 
  10 |     | /**
  11 |     |  * @title SafeERC20
  12 |     |  * @dev Wrappers around ERC20 operations that throw on failure (when the token
  13 |     |  * contract returns false). Tokens that return no value (and instead revert or
  14 |     |  * throw on failure) are also supported, non-reverting calls are assumed to be
  15 |     |  * successful.
  16 |     |  * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,
  17 |     |  * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.
  18 |     |  */
  19 |     | library SafeERC20 {
  20 |     |     using Address for address;
  21 |     | 
  22 |     |     /**
  23 |     |      * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,
  24 |     |      * non-reverting calls are assumed to be successful.
  25 |     |      */
  26 | *   |     function safeTransfer(IERC20 token, address to, uint256 value) internal {
  27 | *   |         _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));
  28 |     |     }
  29 |     | 
  30 |     |     /**
  31 |     |      * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the
  32 |     |      * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.
  33 |     |      */
  34 |     |     function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {
  35 | *   |         _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));
  36 |     |     }
  37 |     | 
  38 |     |     /**
  39 |     |      * @dev Deprecated. This function has issues similar to the ones found in
  40 |     |      * {IERC20-approve}, and its usage is discouraged.
  41 |     |      *
  42 |     |      * Whenever possible, use {safeIncreaseAllowance} and
  43 |     |      * {safeDecreaseAllowance} instead.
  44 |     |      */
  45 |     |     function safeApprove(IERC20 token, address spender, uint256 value) internal {
  46 |     |         // safeApprove should only be called when setting an initial allowance,
  47 |     |         // or when resetting it to zero. To increase and decrease it, use
  48 |     |         // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'
  49 |     |         require(
  50 |     |             (value == 0) || (token.allowance(address(this), spender) == 0),
  51 |     |             "SafeERC20: approve from non-zero to non-zero allowance"
  52 |     |         );
  53 |     |         _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));
  54 |     |     }
  55 |     | 
  56 |     |     /**
  57 |     |      * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,
  58 |     |      * non-reverting calls are assumed to be successful.
  59 |     |      */
  60 |     |     function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {
  61 |     |         uint256 oldAllowance = token.allowance(address(this), spender);
  62 |     |         _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance + value));
  63 |     |     }
  64 |     | 
  65 |     |     /**
  66 |     |      * @dev Decrease the calling contract's allowance toward `spender` by `value`. If `token` returns no value,
  67 |     |      * non-reverting calls are assumed to be successful.
  68 |     |      */
  69 |     |     function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {
  70 |     |         unchecked {
  71 |     |             uint256 oldAllowance = token.allowance(address(this), spender);
  72 |     |             require(oldAllowance >= value, "SafeERC20: decreased allowance below zero");
  73 |     |             _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance - value));
  74 |     |         }
  75 |     |     }
  76 |     | 
  77 |     |     /**
  78 |     |      * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,
  79 |     |      * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval
  80 |     |      * to be set to zero before setting it to a non-zero value, such as USDT.
  81 |     |      */
  82 |     |     function forceApprove(IERC20 token, address spender, uint256 value) internal {
  83 |     |         bytes memory approvalCall = abi.encodeWithSelector(token.approve.selector, spender, value);
  84 |     | 
  85 |     |         if (!_callOptionalReturnBool(token, approvalCall)) {
  86 |     |             _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, 0));
  87 |     |             _callOptionalReturn(token, approvalCall);
  88 |     |         }
  89 |     |     }
  90 |     | 
  91 |     |     /**
  92 |     |      * @dev Use a ERC-2612 signature to set the `owner` approval toward `spender` on `token`.
  93 |     |      * Revert on invalid signature.
  94 |     |      */
  95 |     |     function safePermit(
  96 |     |         IERC20Permit token,
  97 |     |         address owner,
  98 |     |         address spender,
  99 |     |         uint256 value,
 100 |     |         uint256 deadline,
 101 |     |         uint8 v,
 102 |     |         bytes32 r,
 103 |     |         bytes32 s
 104 |     |     ) internal {
 105 |     |         uint256 nonceBefore = token.nonces(owner);
 106 |     |         token.permit(owner, spender, value, deadline, v, r, s);
 107 |     |         uint256 nonceAfter = token.nonces(owner);
 108 |     |         require(nonceAfter == nonceBefore + 1, "SafeERC20: permit did not succeed");
 109 |     |     }
 110 |     | 
 111 |     |     /**
 112 |     |      * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement
 113 |     |      * on the return value: the return value is optional (but if data is returned, it must not be false).
 114 |     |      * @param token The token targeted by the call.
 115 |     |      * @param data The call data (encoded using abi.encode or one of its variants).
 116 |     |      */
 117 | *   |     function _callOptionalReturn(IERC20 token, bytes memory data) private {
 118 |     |         // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since
 119 |     |         // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that
 120 |     |         // the target address contains contract code and also asserts for success in the low-level call.
 121 |     | 
 122 | *   |         bytes memory returndata = address(token).functionCall(data, "SafeERC20: low-level call failed");
 123 | *   |         require(returndata.length == 0 || abi.decode(returndata, (bool)), "SafeERC20: ERC20 operation did not succeed");
 124 |     |     }
 125 |     | 
 126 |     |     /**
 127 |     |      * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement
 128 |     |      * on the return value: the return value is optional (but if data is returned, it must not be false).
 129 |     |      * @param token The token targeted by the call.
 130 |     |      * @param data The call data (encoded using abi.encode or one of its variants).
 131 |     |      *
 132 |     |      * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.
 133 |     |      */
 134 |     |     function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {
 135 |     |         // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since
 136 |     |         // we're implementing it ourselves. We cannot use {Address-functionCall} here since this should return false
 137 |     |         // and not revert is the subcall reverts.
 138 |     | 
 139 |     |         (bool success, bytes memory returndata) = address(token).call(data);
 140 |     |         return
 141 |     |             success && (returndata.length == 0 || abi.decode(returndata, (bool))) && Address.isContract(address(token));
 142 |     |     }
 143 |     | }
 144 |     | 

/Users/nelsonpereira/Documents/GitHub/Auditing/Fuzzy/Blogs/ElasticSwap_Recon/elasticswap-recon/node_modules/@openzeppelin/contracts/utils/Address.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | // OpenZeppelin Contracts (last updated v4.9.0) (utils/Address.sol)
   3 |     | 
   4 |     | pragma solidity ^0.8.1;
   5 |     | 
   6 |     | /**
   7 |     |  * @dev Collection of functions related to the address type
   8 |     |  */
   9 |     | library Address {
  10 |     |     /**
  11 |     |      * @dev Returns true if `account` is a contract.
  12 |     |      *
  13 |     |      * [IMPORTANT]
  14 |     |      * ====
  15 |     |      * It is unsafe to assume that an address for which this function returns
  16 |     |      * false is an externally-owned account (EOA) and not a contract.
  17 |     |      *
  18 |     |      * Among others, `isContract` will return false for the following
  19 |     |      * types of addresses:
  20 |     |      *
  21 |     |      *  - an externally-owned account
  22 |     |      *  - a contract in construction
  23 |     |      *  - an address where a contract will be created
  24 |     |      *  - an address where a contract lived, but was destroyed
  25 |     |      *
  26 |     |      * Furthermore, `isContract` will also return true if the target contract within
  27 |     |      * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,
  28 |     |      * which only has an effect at the end of a transaction.
  29 |     |      * ====
  30 |     |      *
  31 |     |      * [IMPORTANT]
  32 |     |      * ====
  33 |     |      * You shouldn't rely on `isContract` to protect against flash loan attacks!
  34 |     |      *
  35 |     |      * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets
  36 |     |      * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract
  37 |     |      * constructor.
  38 |     |      * ====
  39 |     |      */
  40 |     |     function isContract(address account) internal view returns (bool) {
  41 |     |         // This method relies on extcodesize/address.code.length, which returns 0
  42 |     |         // for contracts in construction, since the code is only stored at the end
  43 |     |         // of the constructor execution.
  44 |     | 
  45 |     |         return account.code.length > 0;
  46 |     |     }
  47 |     | 
  48 |     |     /**
  49 |     |      * @dev Replacement for Solidity's `transfer`: sends `amount` wei to
  50 |     |      * `recipient`, forwarding all available gas and reverting on errors.
  51 |     |      *
  52 |     |      * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost
  53 |     |      * of certain opcodes, possibly making contracts go over the 2300 gas limit
  54 |     |      * imposed by `transfer`, making them unable to receive funds via
  55 |     |      * `transfer`. {sendValue} removes this limitation.
  56 |     |      *
  57 |     |      * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].
  58 |     |      *
  59 |     |      * IMPORTANT: because control is transferred to `recipient`, care must be
  60 |     |      * taken to not create reentrancy vulnerabilities. Consider using
  61 |     |      * {ReentrancyGuard} or the
  62 |     |      * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].
  63 |     |      */
  64 |     |     function sendValue(address payable recipient, uint256 amount) internal {
  65 |     |         require(address(this).balance >= amount, "Address: insufficient balance");
  66 |     | 
  67 |     |         (bool success, ) = recipient.call{value: amount}("");
  68 |     |         require(success, "Address: unable to send value, recipient may have reverted");
  69 |     |     }
  70 |     | 
  71 |     |     /**
  72 |     |      * @dev Performs a Solidity function call using a low level `call`. A
  73 |     |      * plain `call` is an unsafe replacement for a function call: use this
  74 |     |      * function instead.
  75 |     |      *
  76 |     |      * If `target` reverts with a revert reason, it is bubbled up by this
  77 |     |      * function (like regular Solidity function calls).
  78 |     |      *
  79 |     |      * Returns the raw returned data. To convert to the expected return value,
  80 |     |      * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].
  81 |     |      *
  82 |     |      * Requirements:
  83 |     |      *
  84 |     |      * - `target` must be a contract.
  85 |     |      * - calling `target` with `data` must not revert.
  86 |     |      *
  87 |     |      * _Available since v3.1._
  88 |     |      */
  89 |     |     function functionCall(address target, bytes memory data) internal returns (bytes memory) {
  90 |     |         return functionCallWithValue(target, data, 0, "Address: low-level call failed");
  91 |     |     }
  92 |     | 
  93 |     |     /**
  94 |     |      * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with
  95 |     |      * `errorMessage` as a fallback revert reason when `target` reverts.
  96 |     |      *
  97 |     |      * _Available since v3.1._
  98 |     |      */
  99 |     |     function functionCall(
 100 |     |         address target,
 101 |     |         bytes memory data,
 102 |     |         string memory errorMessage
 103 |     |     ) internal returns (bytes memory) {
 104 |     |         return functionCallWithValue(target, data, 0, errorMessage);
 105 |     |     }
 106 |     | 
 107 |     |     /**
 108 |     |      * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],
 109 |     |      * but also transferring `value` wei to `target`.
 110 |     |      *
 111 |     |      * Requirements:
 112 |     |      *
 113 |     |      * - the calling contract must have an ETH balance of at least `value`.
 114 |     |      * - the called Solidity function must be `payable`.
 115 |     |      *
 116 |     |      * _Available since v3.1._
 117 |     |      */
 118 |     |     function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {
 119 |     |         return functionCallWithValue(target, data, value, "Address: low-level call with value failed");
 120 |     |     }
 121 |     | 
 122 |     |     /**
 123 |     |      * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but
 124 |     |      * with `errorMessage` as a fallback revert reason when `target` reverts.
 125 |     |      *
 126 |     |      * _Available since v3.1._
 127 |     |      */
 128 |     |     function functionCallWithValue(
 129 |     |         address target,
 130 |     |         bytes memory data,
 131 |     |         uint256 value,
 132 |     |         string memory errorMessage
 133 |     |     ) internal returns (bytes memory) {
 134 | *   |         require(address(this).balance >= value, "Address: insufficient balance for call");
 135 | *   |         (bool success, bytes memory returndata) = target.call{value: value}(data);
 136 |     |         return verifyCallResultFromTarget(target, success, returndata, errorMessage);
 137 |     |     }
 138 |     | 
 139 |     |     /**
 140 |     |      * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],
 141 |     |      * but performing a static call.
 142 |     |      *
 143 |     |      * _Available since v3.3._
 144 |     |      */
 145 |     |     function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {
 146 |     |         return functionStaticCall(target, data, "Address: low-level static call failed");
 147 |     |     }
 148 |     | 
 149 |     |     /**
 150 |     |      * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],
 151 |     |      * but performing a static call.
 152 |     |      *
 153 |     |      * _Available since v3.3._
 154 |     |      */
 155 |     |     function functionStaticCall(
 156 |     |         address target,
 157 |     |         bytes memory data,
 158 |     |         string memory errorMessage
 159 |     |     ) internal view returns (bytes memory) {
 160 |     |         (bool success, bytes memory returndata) = target.staticcall(data);
 161 |     |         return verifyCallResultFromTarget(target, success, returndata, errorMessage);
 162 |     |     }
 163 |     | 
 164 |     |     /**
 165 |     |      * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],
 166 |     |      * but performing a delegate call.
 167 |     |      *
 168 |     |      * _Available since v3.4._
 169 |     |      */
 170 |     |     function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {
 171 |     |         return functionDelegateCall(target, data, "Address: low-level delegate call failed");
 172 |     |     }
 173 |     | 
 174 |     |     /**
 175 |     |      * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],
 176 |     |      * but performing a delegate call.
 177 |     |      *
 178 |     |      * _Available since v3.4._
 179 |     |      */
 180 |     |     function functionDelegateCall(
 181 |     |         address target,
 182 |     |         bytes memory data,
 183 |     |         string memory errorMessage
 184 |     |     ) internal returns (bytes memory) {
 185 |     |         (bool success, bytes memory returndata) = target.delegatecall(data);
 186 |     |         return verifyCallResultFromTarget(target, success, returndata, errorMessage);
 187 |     |     }
 188 |     | 
 189 |     |     /**
 190 |     |      * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling
 191 |     |      * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.
 192 |     |      *
 193 |     |      * _Available since v4.8._
 194 |     |      */
 195 |     |     function verifyCallResultFromTarget(
 196 |     |         address target,
 197 |     |         bool success,
 198 |     |         bytes memory returndata,
 199 |     |         string memory errorMessage
 200 |     |     ) internal view returns (bytes memory) {
 201 |     |         if (success) {
 202 |     |             if (returndata.length == 0) {
 203 |     |                 // only check isContract if the call was successful and the return data is empty
 204 |     |                 // otherwise we already know that it was a contract
 205 |     |                 require(isContract(target), "Address: call to non-contract");
 206 |     |             }
 207 |     |             return returndata;
 208 |     |         } else {
 209 |     |             _revert(returndata, errorMessage);
 210 |     |         }
 211 |     |     }
 212 |     | 
 213 |     |     /**
 214 |     |      * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the
 215 |     |      * revert reason or using the provided one.
 216 |     |      *
 217 |     |      * _Available since v4.3._
 218 |     |      */
 219 |     |     function verifyCallResult(
 220 |     |         bool success,
 221 |     |         bytes memory returndata,
 222 |     |         string memory errorMessage
 223 |     |     ) internal pure returns (bytes memory) {
 224 |     |         if (success) {
 225 |     |             return returndata;
 226 |     |         } else {
 227 |     |             _revert(returndata, errorMessage);
 228 |     |         }
 229 |     |     }
 230 |     | 
 231 |     |     function _revert(bytes memory returndata, string memory errorMessage) private pure {
 232 |     |         // Look for revert reason and bubble it up if present
 233 |     |         if (returndata.length > 0) {
 234 |     |             // The easiest way to bubble the revert reason is using memory via assembly
 235 |     |             /// @solidity memory-safe-assembly
 236 |     |             assembly {
 237 |     |                 let returndata_size := mload(returndata)
 238 |     |                 revert(add(32, returndata), returndata_size)
 239 |     |             }
 240 |     |         } else {
 241 |     |             revert(errorMessage);
 242 |     |         }
 243 |     |     }
 244 |     | }
 245 |     | 

/Users/nelsonpereira/Documents/GitHub/Auditing/Fuzzy/Blogs/ElasticSwap_Recon/elasticswap-recon/node_modules/@openzeppelin/contracts/utils/Context.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // OpenZeppelin Contracts (last updated v4.9.4) (utils/Context.sol)
  3 |     | 
  4 |     | pragma solidity ^0.8.0;
  5 |     | 
  6 |     | /**
  7 |     |  * @dev Provides information about the current execution context, including the
  8 |     |  * sender of the transaction and its data. While these are generally available
  9 |     |  * via msg.sender and msg.data, they should not be accessed in such a direct
 10 |     |  * manner, since when dealing with meta-transactions the account sending and
 11 |     |  * paying for execution may not be the actual sender (as far as an application
 12 |     |  * is concerned).
 13 |     |  *
 14 |     |  * This contract is only required for intermediate, library-like contracts.
 15 |     |  */
 16 |     | abstract contract Context {
 17 |     |     function _msgSender() internal view virtual returns (address) {
 18 | *   |         return msg.sender;
 19 |     |     }
 20 |     | 
 21 |     |     function _msgData() internal view virtual returns (bytes calldata) {
 22 |     |         return msg.data;
 23 |     |     }
 24 |     | 
 25 |     |     function _contextSuffixLength() internal view virtual returns (uint256) {
 26 |     |         return 0;
 27 |     |     }
 28 |     | }
 29 |     | 

/Users/nelsonpereira/Documents/GitHub/Auditing/Fuzzy/Blogs/ElasticSwap_Recon/elasticswap-recon/src/contracts/Exchange.sol
   1 |     | //SPDX-License-Identifier: GPL-3.0
   2 |     | pragma solidity 0.8.4;
   3 |     | 
   4 |     | import "../libraries/MathLib.sol";
   5 |     | import "@openzeppelin/contracts/token/ERC20/ERC20.sol";
   6 |     | import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
   7 |     | import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
   8 |     | import "@openzeppelin/contracts/security/ReentrancyGuard.sol";
   9 |     | import "../interfaces/IExchangeFactory.sol";
  10 |     | 
  11 |     | /**
  12 |     |  * @title Exchange contract for Elastic Swap representing a single ERC20 pair of tokens to be swapped.
  13 |     |  * @author Elastic DAO
  14 |     |  * @notice This contract provides all of the needed functionality for a liquidity provider to supply/withdraw ERC20
  15 |     |  * tokens and traders to swap tokens for one another.
  16 |     |  */
  17 | *   | contract Exchange is ERC20, ReentrancyGuard {
  18 |     |     using MathLib for uint256;
  19 |     |     using SafeERC20 for IERC20;
  20 |     | 
  21 |     |     address public immutable baseToken; // address of ERC20 base token (elastic or fixed supply)
  22 |     |     address public immutable quoteToken; // address of ERC20 quote token (WETH or a stable coin w/ fixed supply)
  23 |     |     address public immutable exchangeFactoryAddress;
  24 |     | 
  25 | *   |     uint256 public constant TOTAL_LIQUIDITY_FEE = 50; // fee provided to liquidity providers + DAO in basis points
  26 | *   |     uint256 public constant MINIMUM_LIQUIDITY = 1e3;
  27 |     | 
  28 |     |     // @audit cant be changed to private because makes it inaccesible in BeforeAfter
  29 |     |     MathLib.InternalBalances public internalBalances;
  30 |     | 
  31 |     |     event AddLiquidity(
  32 |     |         address indexed liquidityProvider,
  33 |     |         uint256 baseTokenQtyAdded,
  34 |     |         uint256 quoteTokenQtyAdded
  35 |     |     );
  36 |     |     event RemoveLiquidity(
  37 |     |         address indexed liquidityProvider,
  38 |     |         uint256 baseTokenQtyRemoved,
  39 |     |         uint256 quoteTokenQtyRemoved
  40 |     |     );
  41 |     |     event Swap(
  42 |     |         address indexed sender,
  43 |     |         uint256 baseTokenQtyIn,
  44 |     |         uint256 quoteTokenQtyIn,
  45 |     |         uint256 baseTokenQtyOut,
  46 |     |         uint256 quoteTokenQtyOut
  47 |     |     );
  48 |     | 
  49 |     |     /**
  50 |     |      * @dev Called to check timestamps from users for expiration of their calls.
  51 |     |      */
  52 |     |     modifier isNotExpired(uint256 _expirationTimeStamp) {
  53 | *   |         require(_expirationTimeStamp >= block.timestamp, "Exchange: EXPIRED");
  54 |     |         _;
  55 |     |     }
  56 |     | 
  57 |     |     /**
  58 |     |      * @notice called by the exchange factory to create a new erc20 token swap pair (do not call this directly!)
  59 |     |      * @param _name The human readable name of this pair (also used for the liquidity token name)
  60 |     |      * @param _symbol Shortened symbol for trading pair (also used for the liquidity token symbol)
  61 |     |      * @param _baseToken address of the ERC20 base token in the pair. This token can have a fixed or elastic supply
  62 |     |      * @param _quoteToken address of the ERC20 quote token in the pair. This token is assumed to have a fixed supply.
  63 |     |      * @param _exchangeFactoryAddress address of the exchange factory
  64 |     |      */
  65 |     |     constructor(
  66 |     |         string memory _name,
  67 |     |         string memory _symbol,
  68 |     |         address _baseToken,
  69 |     |         address _quoteToken,
  70 |     |         address _exchangeFactoryAddress
  71 |     |     ) ERC20(_name, _symbol) {
  72 |     |         baseToken = _baseToken;
  73 |     |         quoteToken = _quoteToken;
  74 |     |         exchangeFactoryAddress = _exchangeFactoryAddress;
  75 |     |     }
  76 |     | 
  77 |     |     /**
  78 |     |      * @notice primary entry point for a liquidity provider to add new liquidity (base and quote tokens) to the exchange
  79 |     |      * and receive liquidity tokens in return.
  80 |     |      * Requires approvals to be granted to this exchange for both base and quote tokens.
  81 |     |      * @param _baseTokenQtyDesired qty of baseTokens that you would like to add to the exchange
  82 |     |      * @param _quoteTokenQtyDesired qty of quoteTokens that you would like to add to the exchange
  83 |     |      * @param _baseTokenQtyMin minimum acceptable qty of baseTokens that will be added (or transaction will revert)
  84 |     |      * @param _quoteTokenQtyMin minimum acceptable qty of quoteTokens that will be added (or transaction will revert)
  85 |     |      * @param _liquidityTokenRecipient address for the exchange to issue the resulting liquidity tokens from
  86 |     |      * this transaction to
  87 |     |      * @param _expirationTimestamp timestamp that this transaction must occur before (or transaction will revert)
  88 |     |      */
  89 | *   |     function addLiquidity(
  90 |     |         uint256 _baseTokenQtyDesired,
  91 |     |         uint256 _quoteTokenQtyDesired,
  92 |     |         uint256 _baseTokenQtyMin,
  93 |     |         uint256 _quoteTokenQtyMin,
  94 |     |         address _liquidityTokenRecipient,
  95 |     |         uint256 _expirationTimestamp
  96 |     |     ) external nonReentrant() isNotExpired(_expirationTimestamp) {
  97 | *   |         uint256 totalSupply = this.totalSupply();
  98 | *   |         MathLib.TokenQtys memory tokenQtys =
  99 | *   |             MathLib.calculateAddLiquidityQuantities(
 100 | *   |                 _baseTokenQtyDesired,
 101 | *   |                 _quoteTokenQtyDesired,
 102 | *   |                 _baseTokenQtyMin,
 103 | *   |                 _quoteTokenQtyMin,
 104 | *   |                 IERC20(baseToken).balanceOf(address(this)),
 105 |     |                 totalSupply,
 106 |     |                 internalBalances
 107 |     |             );
 108 |     | 
 109 |     |         internalBalances.kLast =
 110 |     |             internalBalances.baseTokenReserveQty *
 111 |     |             internalBalances.quoteTokenReserveQty;
 112 |     | 
 113 |     |         if (tokenQtys.liquidityTokenFeeQty != 0) {
 114 |     |             // mint liquidity tokens to fee address for k growth.
 115 | *   |             _mint(
 116 | *   |                 IExchangeFactory(exchangeFactoryAddress).feeAddress(),
 117 | *   |                 tokenQtys.liquidityTokenFeeQty
 118 |     |             );
 119 |     |         }
 120 |     | 
 121 |     |         bool isExchangeEmpty = totalSupply == 0;
 122 |     |         if (isExchangeEmpty) {
 123 |     |             // check if this the first LP provider, if so, we need to lock some minimum dust liquidity.
 124 |     |             require(
 125 |     |                 tokenQtys.liquidityTokenQty > MINIMUM_LIQUIDITY,
 126 |     |                 "Exchange: INITIAL_DEPOSIT_MIN"
 127 |     |             );
 128 |     |             unchecked {
 129 |     |                 tokenQtys.liquidityTokenQty -= MINIMUM_LIQUIDITY;
 130 |     |             }
 131 |     |             _mint(address(this), MINIMUM_LIQUIDITY); // mint to this address, total supply will never be 0 again
 132 |     |         }
 133 |     | 
 134 |     |         _mint(_liquidityTokenRecipient, tokenQtys.liquidityTokenQty); // mint liquidity tokens to recipient
 135 |     | 
 136 |     |         if (tokenQtys.baseTokenQty != 0) {
 137 |     |             // transfer base tokens to Exchange
 138 |     |             IERC20(baseToken).safeTransferFrom(
 139 |     |                 msg.sender,
 140 |     |                 address(this),
 141 |     |                 tokenQtys.baseTokenQty
 142 |     |             );
 143 |     | 
 144 |     |             if (isExchangeEmpty) {
 145 |     |                 require(
 146 |     |                     IERC20(baseToken).balanceOf(address(this)) ==
 147 |     |                         tokenQtys.baseTokenQty,
 148 |     |                     "Exchange: FEE_ON_TRANSFER_NOT_SUPPORTED"
 149 |     |                 );
 150 |     |             }
 151 |     |         }
 152 |     | 
 153 |     |         if (tokenQtys.quoteTokenQty != 0) {
 154 |     |             // transfer quote tokens to Exchange
 155 | *   |             IERC20(quoteToken).safeTransferFrom(
 156 | *   |                 msg.sender,
 157 | *   |                 address(this),
 158 | *   |                 tokenQtys.quoteTokenQty
 159 |     |             );
 160 |     |         }
 161 |     | 
 162 | *   |         emit AddLiquidity(
 163 |     |             msg.sender,
 164 | *   |             tokenQtys.baseTokenQty,
 165 | *   |             tokenQtys.quoteTokenQty
 166 |     |         );
 167 |     |     }
 168 |     | 
 169 |     |     /**
 170 |     |      * @notice called by a liquidity provider to redeem liquidity tokens from the exchange and receive back
 171 |     |      * base and quote tokens. Required approvals to be granted to this exchange for the liquidity token
 172 |     |      * @param _liquidityTokenQty qty of liquidity tokens that you would like to redeem
 173 |     |      * @param _baseTokenQtyMin minimum acceptable qty of base tokens to receive back (or transaction will revert)
 174 |     |      * @param _quoteTokenQtyMin minimum acceptable qty of quote tokens to receive back (or transaction will revert)
 175 |     |      * @param _tokenRecipient address for the exchange to issue the resulting base and
 176 |     |      * quote tokens from this transaction to
 177 |     |      * @param _expirationTimestamp timestamp that this transaction must occur before (or transaction will revert)
 178 |     |      */
 179 | *   |     function removeLiquidity(
 180 |     |         uint256 _liquidityTokenQty,
 181 |     |         uint256 _baseTokenQtyMin,
 182 |     |         uint256 _quoteTokenQtyMin,
 183 |     |         address _tokenRecipient,
 184 |     |         uint256 _expirationTimestamp
 185 | *   |     ) external nonReentrant() isNotExpired(_expirationTimestamp) {
 186 | *   |         require(this.totalSupply() != 0, "Exchange: INSUFFICIENT_LIQUIDITY");
 187 | *   |         require(
 188 | *   |             _baseTokenQtyMin != 0 && _quoteTokenQtyMin != 0,
 189 |     |             "Exchange: MINS_MUST_BE_GREATER_THAN_ZERO"
 190 |     |         );
 191 |     | 
 192 | *   |         uint256 baseTokenReserveQty =
 193 | *   |             IERC20(baseToken).balanceOf(address(this));
 194 | *   |         uint256 quoteTokenReserveQty =
 195 | *   |             IERC20(quoteToken).balanceOf(address(this));
 196 |     | 
 197 | *   |         uint256 totalSupplyOfLiquidityTokens = this.totalSupply();
 198 |     |         // calculate any DAO fees here.
 199 | *   |         uint256 liquidityTokenFeeQty =
 200 | *   |             MathLib.calculateLiquidityTokenFees(
 201 |     |                 totalSupplyOfLiquidityTokens,
 202 | *   |                 internalBalances
 203 |     |             );
 204 |     | 
 205 |     |         // we need to factor this quantity in to any total supply before redemption
 206 | *   |         totalSupplyOfLiquidityTokens += liquidityTokenFeeQty;
 207 |     | 
 208 | *   |         uint256 baseTokenQtyToReturn =
 209 | *   |             (_liquidityTokenQty * baseTokenReserveQty) /
 210 |     |                 totalSupplyOfLiquidityTokens;
 211 | *   |         uint256 quoteTokenQtyToReturn =
 212 | *   |             (_liquidityTokenQty * quoteTokenReserveQty) /
 213 | *   |                 totalSupplyOfLiquidityTokens;
 214 |     | 
 215 | *   |         require(
 216 | *   |             baseTokenQtyToReturn >= _baseTokenQtyMin,
 217 |     |             "Exchange: INSUFFICIENT_BASE_QTY"
 218 |     |         );
 219 |     | 
 220 | *   |         require(
 221 | *   |             quoteTokenQtyToReturn >= _quoteTokenQtyMin,
 222 |     |             "Exchange: INSUFFICIENT_QUOTE_QTY"
 223 |     |         );
 224 |     | 
 225 |     |         // this ensures that we are removing the equivalent amount of decay
 226 |     |         // when this person exits.
 227 |     |         {
 228 |     |             //scoping to avoid stack too deep errors
 229 |     |             uint256 internalBaseTokenReserveQty =
 230 |     |                 internalBalances.baseTokenReserveQty;
 231 |     |             uint256 baseTokenQtyToRemoveFromInternalAccounting =
 232 |     |                 (_liquidityTokenQty * internalBaseTokenReserveQty) /
 233 |     |                     totalSupplyOfLiquidityTokens;
 234 |     | 
 235 |     |             internalBalances.baseTokenReserveQty = internalBaseTokenReserveQty =
 236 |     |                 internalBaseTokenReserveQty -
 237 |     |                 baseTokenQtyToRemoveFromInternalAccounting;
 238 |     | 
 239 |     |             // We should ensure no possible overflow here.
 240 |     |             uint256 internalQuoteTokenReserveQty =
 241 |     |                 internalBalances.quoteTokenReserveQty;
 242 | *   |             if (quoteTokenQtyToReturn > internalQuoteTokenReserveQty) {
 243 |     |                 internalBalances
 244 |     |                     .quoteTokenReserveQty = internalQuoteTokenReserveQty = 0;
 245 |     |             } else {
 246 |     |                 internalBalances
 247 |     |                     .quoteTokenReserveQty = internalQuoteTokenReserveQty =
 248 |     |                     internalQuoteTokenReserveQty -
 249 |     |                     quoteTokenQtyToReturn;
 250 |     |             }
 251 |     | 
 252 |     |             internalBalances.kLast =
 253 | *   |                 internalBaseTokenReserveQty *
 254 | *   |                 internalQuoteTokenReserveQty;
 255 |     |         }
 256 |     | 
 257 |     |         if (liquidityTokenFeeQty != 0) {
 258 |     |             _mint(
 259 |     |                 IExchangeFactory(exchangeFactoryAddress).feeAddress(),
 260 |     |                 liquidityTokenFeeQty
 261 |     |             );
 262 |     |         }
 263 |     | 
 264 |     |         _burn(msg.sender, _liquidityTokenQty);
 265 |     |         IERC20(baseToken).safeTransfer(_tokenRecipient, baseTokenQtyToReturn);
 266 |     |         IERC20(quoteToken).safeTransfer(_tokenRecipient, quoteTokenQtyToReturn);
 267 |     |         emit RemoveLiquidity(
 268 |     |             msg.sender,
 269 |     |             baseTokenQtyToReturn,
 270 |     |             quoteTokenQtyToReturn
 271 |     |         );
 272 |     |     }
 273 |     | 
 274 |     |     /**
 275 |     |      * @notice swaps base tokens for a minimum amount of quote tokens.  Fees are included in all transactions.
 276 |     |      * The exchange must be granted approvals for the base token by the caller.
 277 |     |      * @param _baseTokenQty qty of base tokens to swap
 278 |     |      * @param _minQuoteTokenQty minimum qty of quote tokens to receive in exchange for
 279 |     |      * your base tokens (or the transaction will revert)
 280 |     |      * @param _expirationTimestamp timestamp that this transaction must occur before (or transaction will revert)
 281 |     |      */
 282 | *   |     function swapBaseTokenForQuoteToken(
 283 |     |         uint256 _baseTokenQty,
 284 |     |         uint256 _minQuoteTokenQty,
 285 |     |         uint256 _expirationTimestamp
 286 | *   |     ) external nonReentrant() isNotExpired(_expirationTimestamp) {
 287 | *   |         require(
 288 | *   |             _baseTokenQty != 0 && _minQuoteTokenQty != 0,
 289 |     |             "Exchange: INSUFFICIENT_TOKEN_QTY"
 290 |     |         );
 291 |     | 
 292 |     |         uint256 quoteTokenQty =
 293 |     |             MathLib.calculateQuoteTokenQty(
 294 |     |                 _baseTokenQty,
 295 |     |                 _minQuoteTokenQty,
 296 |     |                 TOTAL_LIQUIDITY_FEE,
 297 |     |                 internalBalances
 298 |     |             );
 299 |     | 
 300 |     |         IERC20(baseToken).safeTransferFrom(
 301 |     |             msg.sender,
 302 |     |             address(this),
 303 |     |             _baseTokenQty
 304 |     |         );
 305 |     | 
 306 |     |         IERC20(quoteToken).safeTransfer(msg.sender, quoteTokenQty);
 307 |     |         emit Swap(msg.sender, _baseTokenQty, 0, 0, quoteTokenQty);
 308 |     |     }
 309 |     | 
 310 |     |     /**
 311 |     |      * @notice swaps quote tokens for a minimum amount of base tokens.  Fees are included in all transactions.
 312 |     |      * The exchange must be granted approvals for the quote token by the caller.
 313 |     |      * @param _quoteTokenQty qty of quote tokens to swap
 314 |     |      * @param _minBaseTokenQty minimum qty of base tokens to receive in exchange for
 315 |     |      * your quote tokens (or the transaction will revert)
 316 |     |      * @param _expirationTimestamp timestamp that this transaction must occur before (or transaction will revert)
 317 |     |      */
 318 | *   |     function swapQuoteTokenForBaseToken(
 319 |     |         uint256 _quoteTokenQty,
 320 |     |         uint256 _minBaseTokenQty,
 321 |     |         uint256 _expirationTimestamp
 322 | *   |     ) external nonReentrant() isNotExpired(_expirationTimestamp) {
 323 | *   |         require(
 324 | *   |             _quoteTokenQty != 0 && _minBaseTokenQty != 0,
 325 |     |             "Exchange: INSUFFICIENT_TOKEN_QTY"
 326 |     |         );
 327 |     | 
 328 | *   |         uint256 baseTokenQty =
 329 | *   |             MathLib.calculateBaseTokenQty(
 330 |     |                 _quoteTokenQty,
 331 |     |                 _minBaseTokenQty,
 332 | *   |                 IERC20(baseToken).balanceOf(address(this)),
 333 |     |                 TOTAL_LIQUIDITY_FEE,
 334 | *   |                 internalBalances
 335 |     |             );
 336 |     | 
 337 | *   |         IERC20(quoteToken).safeTransferFrom(
 338 |     |             msg.sender,
 339 |     |             address(this),
 340 |     |             _quoteTokenQty
 341 |     |         );
 342 |     | 
 343 | *   |         IERC20(baseToken).safeTransfer(msg.sender, baseTokenQty);
 344 | *   |         emit Swap(msg.sender, 0, _quoteTokenQty, baseTokenQty, 0);
 345 |     |     }
 346 |     | }
 347 |     | 

/Users/nelsonpereira/Documents/GitHub/Auditing/Fuzzy/Blogs/ElasticSwap_Recon/elasticswap-recon/src/contracts/ExchangeFactory.sol
  1 |     | //SPDX-License-Identifier: GPL-3.0
  2 |     | pragma solidity 0.8.4;
  3 |     | 
  4 |     | import "@openzeppelin/contracts/access/Ownable.sol";
  5 |     | import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
  6 |     | import "./Exchange.sol";
  7 |     | import "../interfaces/IExchangeFactory.sol";
  8 |     | import "../libraries/SafeMetadata.sol";
  9 |     | 
 10 |     | /**
 11 |     |  * @title ExchangeFactory contract for Elastic Swap.
 12 |     |  * @author Elastic DAO
 13 |     |  * @notice The ExchangeFactory provides the needed functionality to create new Exchange's that represent
 14 |     |  * a single token pair.  Additionally it houses records of all deployed Exchange's for validation and easy
 15 |     |  * lookup.
 16 |     |  */
 17 |     | contract ExchangeFactory is Ownable, IExchangeFactory {
 18 |     |     using SafeMetadata for IERC20;
 19 |     | 
 20 |     |     mapping(address => mapping(address => address))
 21 |     |         public exchangeAddressByTokenAddress;
 22 |     |     mapping(address => bool) public isValidExchangeAddress;
 23 |     | 
 24 |     |     address private feeAddress_;
 25 |     | 
 26 |     |     // events
 27 |     |     event NewExchange(address indexed creator, address indexed exchangeAddress);
 28 |     |     event SetFeeAddress(address indexed feeAddress);
 29 |     | 
 30 |     |     constructor(address _feeAddress) {
 31 |     |         require(_feeAddress != address(0), "ExchangeFactory: INVALID_ADDRESS");
 32 |     |         feeAddress_ = _feeAddress;
 33 |     |     }
 34 |     | 
 35 |     |     /**
 36 |     |      * @notice called to create a new erc20 token pair exchange
 37 |     |      * @param _baseToken address of the ERC20 base token in the pair. This token can have a fixed or elastic supply
 38 |     |      * @param _quoteToken address of the ERC20 quote token in the pair. This token is assumed to have a fixed supply.
 39 |     |      */
 40 |     |     function createNewExchange(address _baseToken, address _quoteToken)
 41 |     |         external
 42 |     |     {
 43 |     |         require(_baseToken != _quoteToken, "ExchangeFactory: IDENTICAL_TOKENS");
 44 |     |         require(
 45 |     |             _baseToken != address(0) && _quoteToken != address(0),
 46 |     |             "ExchangeFactory: INVALID_TOKEN_ADDRESS"
 47 |     |         );
 48 |     |         require(
 49 |     |             exchangeAddressByTokenAddress[_baseToken][_quoteToken] ==
 50 |     |                 address(0),
 51 |     |             "ExchangeFactory: DUPLICATE_EXCHANGE"
 52 |     |         );
 53 |     | 
 54 |     |         string memory baseSymbol = IERC20(_baseToken).safeSymbol();
 55 |     |         string memory quoteSymbol = IERC20(_quoteToken).safeSymbol();
 56 |     | 
 57 |     |         Exchange exchange =
 58 |     |             new Exchange(
 59 |     |                 string(
 60 |     |                     abi.encodePacked(
 61 |     |                         baseSymbol,
 62 |     |                         "v",
 63 |     |                         quoteSymbol,
 64 |     |                         " ElasticSwap Liquidity Token"
 65 |     |                     )
 66 |     |                 ),
 67 |     |                 string(abi.encodePacked(baseSymbol, "v", quoteSymbol, "-ELP")),
 68 |     |                 _baseToken,
 69 |     |                 _quoteToken,
 70 |     |                 address(this)
 71 |     |             );
 72 |     | 
 73 |     |         exchangeAddressByTokenAddress[_baseToken][_quoteToken] = address(
 74 |     |             exchange
 75 |     |         );
 76 |     |         isValidExchangeAddress[address(exchange)] = true;
 77 |     | 
 78 |     |         emit NewExchange(msg.sender, address(exchange));
 79 |     |     }
 80 |     | 
 81 |     |     function setFeeAddress(address _feeAddress) external onlyOwner {
 82 |     |         require(
 83 |     |             _feeAddress != address(0) && _feeAddress != feeAddress_,
 84 |     |             "ExchangeFactory: INVAlID_FEE_ADDRESS"
 85 |     |         );
 86 |     |         feeAddress_ = _feeAddress;
 87 |     |         emit SetFeeAddress(_feeAddress);
 88 |     |     }
 89 |     | 
 90 |     |     function feeAddress() public view virtual override returns (address) {
 91 |     |         return feeAddress_;
 92 |     |     }
 93 |     | }
 94 |     | 

/Users/nelsonpereira/Documents/GitHub/Auditing/Fuzzy/Blogs/ElasticSwap_Recon/elasticswap-recon/src/contracts/mocks/ElasticMock.sol
  1 |     | //SPDX-License-Identifier: GPL-3.0
  2 |     | pragma solidity 0.8.4;
  3 |     | 
  4 |     | import "@openzeppelin/contracts/token/ERC20/presets/ERC20PresetFixedSupply.sol";
  5 |     | import "@openzeppelin/contracts/access/Ownable.sol";
  6 |     | 
  7 |     | /**
  8 |     | @notice DO NOT USE IN PRODUCTION. FOR TEST PURPOSES ONLY
  9 |     |  */
 10 | *   | contract ElasticMock is ERC20PresetFixedSupply, Ownable {
 11 |     |     constructor(
 12 |     |         string memory name,
 13 |     |         string memory symbol,
 14 |     |         uint256 initialSupply,
 15 |     |         address owner
 16 |     |     ) ERC20PresetFixedSupply(name, symbol, initialSupply, owner) {}
 17 |     | 
 18 |     |     /**
 19 |     |     @dev Allows us to transfer away tokens from an address in our tests simulating a rebase down occurring
 20 |     |     */
 21 |     |     function simulateRebaseDown(
 22 |     |         address tokenHolder,
 23 |     |         uint256 tokenAmountToRemove
 24 |     |     ) external onlyOwner() {
 25 |     |         _transfer(tokenHolder, address(this), tokenAmountToRemove);
 26 |     |     }
 27 |     | }
 28 |     | 

/Users/nelsonpereira/Documents/GitHub/Auditing/Fuzzy/Blogs/ElasticSwap_Recon/elasticswap-recon/src/contracts/mocks/MockERC20.sol
  1 |     | // SPDX-License-Identifier: GPL-2.0
  2 |     | pragma solidity ^0.8.0;
  3 |     | 
  4 |     | import {ERC20} from "@openzeppelin/contracts/token/ERC20/ERC20.sol";
  5 |     | 
  6 | *   | contract MockERC20 is ERC20 {
  7 |     |     constructor(string memory name_, string memory symbol_) ERC20(name_, symbol_) {}
  8 |     | 
  9 |     |     function mint(address to, uint256 value) public virtual {
 10 |     |         _mint(to, value);
 11 |     |     }
 12 |     | 
 13 | *   |     function burn(address from, uint256 value) public virtual {
 14 | *   |         _burn(from, value);
 15 |     |     }
 16 |     | 
 17 |     | }

/Users/nelsonpereira/Documents/GitHub/Auditing/Fuzzy/Blogs/ElasticSwap_Recon/elasticswap-recon/src/interfaces/IExchangeFactory.sol
 1 |     | //SPDX-License-Identifier: GPL-3.0
 2 |     | pragma solidity 0.8.4;
 3 |     | 
 4 |     | interface IExchangeFactory {
 5 |     |     function feeAddress() external view returns (address);
 6 |     | }
 7 |     | 

/Users/nelsonpereira/Documents/GitHub/Auditing/Fuzzy/Blogs/ElasticSwap_Recon/elasticswap-recon/src/libraries/MathLib.sol
   1 |     | //SPDX-License-Identifier: GPL-3.0
   2 |     | pragma solidity 0.8.4;
   3 |     | 
   4 |     | /**
   5 |     |  * @title MathLib
   6 |     |  * @author ElasticDAO
   7 |     |  */
   8 |     | library MathLib {
   9 |     |     struct InternalBalances {
  10 |     |         // x*y=k - we track these internally to compare to actual balances of the ERC20's
  11 |     |         // in order to calculate the "decay" or the amount of balances that are not
  12 |     |         // participating in the pricing curve and adding additional liquidity to swap.
  13 |     |         uint256 baseTokenReserveQty; // x
  14 |     |         uint256 quoteTokenReserveQty; // y
  15 |     |         uint256 kLast; // as of the last add / rem liquidity event
  16 |     |     }
  17 |     | 
  18 |     |     // aids in avoiding stack too deep errors.
  19 |     |     struct TokenQtys {
  20 |     |         uint256 baseTokenQty;
  21 |     |         uint256 quoteTokenQty;
  22 |     |         uint256 liquidityTokenQty;
  23 |     |         uint256 liquidityTokenFeeQty;
  24 |     |     }
  25 |     | 
  26 | *   |     uint256 public constant BASIS_POINTS = 10000;
  27 | *   |     uint256 public constant WAD = 1e18; // represent a decimal with 18 digits of precision
  28 |     | 
  29 |     |     /**
  30 |     |      * @dev divides two float values, required since solidity does not handle
  31 |     |      * floating point values.
  32 |     |      *
  33 |     |      * inspiration: https://github.com/dapphub/ds-math/blob/master/src/math.sol
  34 |     |      *
  35 |     |      * NOTE: this rounds to the nearest integer (up or down). For example .666666 would end up
  36 |     |      * rounding to .66667.
  37 |     |      *
  38 |     |      * @return uint256 wad value (decimal with 18 digits of precision)
  39 |     |      */
  40 |     |     function wDiv(uint256 a, uint256 b) internal pure returns (uint256) {
  41 |     |         return ((a * WAD) + (b / 2)) / b;
  42 |     |     }
  43 |     | 
  44 |     |     /**
  45 |     |      * @dev rounds a integer (a) to the nearest n places.
  46 |     |      * IE roundToNearest(123, 10) would round to the nearest 10th place (120).
  47 |     |      */
  48 |     |     function roundToNearest(uint256 a, uint256 n)
  49 |     |         internal
  50 |     |         pure
  51 |     |         returns (uint256)
  52 |     |     {
  53 | *   |         return ((a + (n / 2)) / n) * n;
  54 |     |     }
  55 |     | 
  56 |     |     /**
  57 |     |      * @dev multiplies two float values, required since solidity does not handle
  58 |     |      * floating point values
  59 |     |      *
  60 |     |      * inspiration: https://github.com/dapphub/ds-math/blob/master/src/math.sol
  61 |     |      *
  62 |     |      * @return uint256 wad value (decimal with 18 digits of precision)
  63 |     |      */
  64 |     |     function wMul(uint256 a, uint256 b) internal pure returns (uint256) {
  65 |     |         return ((a * b) + (WAD / 2)) / WAD;
  66 |     |     }
  67 |     | 
  68 |     |     /**
  69 |     |      * @dev calculates an absolute diff between two integers. Basically the solidity
  70 |     |      * equivalent of Math.abs(a-b);
  71 |     |      */
  72 |     |     function diff(uint256 a, uint256 b) internal pure returns (uint256) {
  73 |     |         if (a >= b) {
  74 |     |             return a - b;
  75 |     |         }
  76 |     |         return b - a;
  77 |     |     }
  78 |     | 
  79 |     |     // babylonian method (https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method)
  80 |     |     function sqrt(uint256 x) internal pure returns (uint256 y) {
  81 |     |         uint256 z = (x + 1) / 2;
  82 |     |         y = x;
  83 |     |         while (z < y) {
  84 |     |             y = z;
  85 |     |             z = (x / z + z) / 2;
  86 |     |         }
  87 |     |     }
  88 |     | 
  89 |     |     /**
  90 |     |      * @dev defines the amount of decay needed in order for us to require a user to handle the
  91 |     |      * decay prior to a double asset entry as the equivalent of 1 unit of quote token
  92 |     |      */
  93 |     |     function isSufficientDecayPresent(
  94 |     |         uint256 _baseTokenReserveQty,
  95 |     |         InternalBalances memory _internalBalances
  96 |     |     ) internal pure returns (bool) {
  97 |     |         return (wDiv(
  98 |     |             diff(_baseTokenReserveQty, _internalBalances.baseTokenReserveQty) *
  99 |     |                 WAD,
 100 |     |             wDiv(
 101 |     |                 _internalBalances.baseTokenReserveQty,
 102 |     |                 _internalBalances.quoteTokenReserveQty
 103 |     |             )
 104 |     |         ) >= WAD); // the amount of base token (a) decay is greater than 1 unit of quote token (token b)
 105 |     |     }
 106 |     | 
 107 |     |     /**
 108 |     |      * @dev used to calculate the qty of token a liquidity provider
 109 |     |      * must add in order to maintain the current reserve ratios
 110 |     |      * @param _tokenAQty base or quote token qty to be supplied by the liquidity provider
 111 |     |      * @param _tokenAReserveQty current reserve qty of the base or quote token (same token as tokenA)
 112 |     |      * @param _tokenBReserveQty current reserve qty of the other base or quote token (not tokenA)
 113 |     |      */
 114 |     |     function calculateQty(
 115 |     |         uint256 _tokenAQty,
 116 |     |         uint256 _tokenAReserveQty,
 117 |     |         uint256 _tokenBReserveQty
 118 |     |     ) internal pure returns (uint256 tokenBQty) {
 119 | *   |         require(_tokenAQty != 0, "MathLib: INSUFFICIENT_QTY");
 120 | *   |         require(
 121 | *   |             _tokenAReserveQty != 0 && _tokenBReserveQty != 0,
 122 |     |             "MathLib: INSUFFICIENT_LIQUIDITY"
 123 |     |         );
 124 | *   |         tokenBQty = (_tokenAQty * _tokenBReserveQty) / _tokenAReserveQty;
 125 |     |     }
 126 |     | 
 127 |     |     /**
 128 |     |      * @dev used to calculate the qty of token a trader will receive (less fees)
 129 |     |      * given the qty of token A they are providing
 130 |     |      * @param _tokenASwapQty base or quote token qty to be swapped by the trader
 131 |     |      * @param _tokenAReserveQty current reserve qty of the base or quote token (same token as tokenA)
 132 |     |      * @param _tokenBReserveQty current reserve qty of the other base or quote token (not tokenA)
 133 |     |      * @param _liquidityFeeInBasisPoints fee to liquidity providers represented in basis points
 134 |     |      */
 135 | *   |     function calculateQtyToReturnAfterFees(
 136 |     |         uint256 _tokenASwapQty,
 137 |     |         uint256 _tokenAReserveQty,
 138 |     |         uint256 _tokenBReserveQty,
 139 |     |         uint256 _liquidityFeeInBasisPoints
 140 |     |     ) internal pure returns (uint256 qtyToReturn) {
 141 | *   |         uint256 tokenASwapQtyLessFee =
 142 |     |             _tokenASwapQty * (BASIS_POINTS - _liquidityFeeInBasisPoints);
 143 | *   |         qtyToReturn =
 144 | *   |             (tokenASwapQtyLessFee * _tokenBReserveQty) /
 145 | *   |             ((_tokenAReserveQty * BASIS_POINTS) + tokenASwapQtyLessFee);
 146 |     |     }
 147 |     | 
 148 |     |     /**
 149 |     |      * @dev used to calculate the qty of liquidity tokens (deltaRo) we will be issued to a supplier
 150 |     |      * of a single asset entry when base token decay is present.
 151 |     |      * @param _baseTokenReserveBalance the total balance (external) of base tokens in our pool (Alpha)
 152 |     |      * @param _totalSupplyOfLiquidityTokens the total supply of our exchange's liquidity tokens (aka Ro)
 153 |     |      * @param _tokenQtyAToAdd the amount of tokens being added by the caller to remove the current decay
 154 |     |      * @param _internalTokenAReserveQty the internal balance (X or Y) of token A as a result of this transaction
 155 |     |      * @param _omega - ratio of internal balances of baseToken and quoteToken: baseToken/quoteToken
 156 |     |      * @return liquidityTokenQty qty of liquidity tokens to be issued in exchange
 157 |     |      */
 158 | *   |     function calculateLiquidityTokenQtyForSingleAssetEntryWithBaseTokenDecay(
 159 |     |         uint256 _baseTokenReserveBalance,
 160 |     |         uint256 _totalSupplyOfLiquidityTokens,
 161 |     |         uint256 _tokenQtyAToAdd,
 162 |     |         uint256 _internalTokenAReserveQty,
 163 |     |         uint256 _omega
 164 | *   |     ) internal pure returns (uint256 liquidityTokenQty) {
 165 |     |         /**
 166 |     |         
 167 |     |         (is the formula in the terms of quoteToken)
 168 |     |                     ΔY 
 169 |     |             = ---------------------                                                    
 170 |     |                 Alpha/Omega + Y'
 171 |     | 
 172 |     | 
 173 |     |          */
 174 | *   |         uint256 wRatio = wDiv(_baseTokenReserveBalance, _omega);
 175 | *   |         uint256 denominator = wRatio + _internalTokenAReserveQty;
 176 | *   |         uint256 wGamma = wDiv(_tokenQtyAToAdd, denominator);
 177 |     | 
 178 | *   |         liquidityTokenQty =
 179 | *   |             wDiv(
 180 |     |                 wMul(_totalSupplyOfLiquidityTokens * WAD, wGamma),
 181 |     |                 WAD - wGamma
 182 |     |             ) /
 183 |     |             WAD;
 184 |     |     }
 185 |     | 
 186 |     |     /**
 187 |     |      * @dev used to calculate the qty of liquidity tokens (deltaRo) we will be issued to a supplier
 188 |     |      * of a single asset entry when quote decay is present.
 189 |     |      * @param _baseTokenReserveBalance the total balance (external) of base tokens in our pool (Alpha)
 190 |     |      * @param _totalSupplyOfLiquidityTokens the total supply of our exchange's liquidity tokens (aka Ro)
 191 |     |      * @param _tokenQtyAToAdd the amount of tokens being added by the caller to remove the current decay
 192 |     |      * @param _internalTokenAReserveQty the internal balance (X or Y) of token A as a result of this transaction
 193 |     |      * @return liquidityTokenQty qty of liquidity tokens to be issued in exchange
 194 |     |      */
 195 | *   |     function calculateLiquidityTokenQtyForSingleAssetEntryWithQuoteTokenDecay(
 196 |     |         uint256 _baseTokenReserveBalance,
 197 |     |         uint256 _totalSupplyOfLiquidityTokens,
 198 |     |         uint256 _tokenQtyAToAdd,
 199 |     |         uint256 _internalTokenAReserveQty
 200 | *   |     ) internal pure returns (uint256 liquidityTokenQty) {
 201 |     |         /**
 202 |     |         
 203 |     |                ΔX
 204 |     |         = -------------------  / (denominator may be Alpha' instead of X)
 205 |     |            X + (Alpha + ΔX)
 206 |     | 
 207 |     |         */
 208 |     | 
 209 |     |         uint256 denominator =
 210 | *   |             _internalTokenAReserveQty +
 211 | *   |                 _baseTokenReserveBalance +
 212 | *   |                 _tokenQtyAToAdd;
 213 |     |         uint256 wGamma = wDiv(_tokenQtyAToAdd, denominator);
 214 |     | 
 215 |     |         liquidityTokenQty =
 216 |     |             wDiv(
 217 |     |                 wMul(_totalSupplyOfLiquidityTokens * WAD, wGamma),
 218 |     |                 WAD - wGamma
 219 |     |             ) /
 220 |     |             WAD;
 221 |     |     }
 222 |     | 
 223 |     |     /**
 224 |     |      * @dev used to calculate the qty of liquidity tokens (deltaRo) we will be issued to a supplier
 225 |     |      * of a single asset entry when decay is present.
 226 |     |      * @param _totalSupplyOfLiquidityTokens the total supply of our exchange's liquidity tokens (aka Ro)
 227 |     |      * @param _quoteTokenQty the amount of quote token the user it adding to the pool (deltaB or deltaY)
 228 |     |      * @param _quoteTokenReserveBalance the total balance (external) of quote tokens in our pool (Beta)
 229 |     |      *
 230 |     |      * @return liquidityTokenQty qty of liquidity tokens to be issued in exchange
 231 |     |      */
 232 | *   |     function calculateLiquidityTokenQtyForDoubleAssetEntry(
 233 |     |         uint256 _totalSupplyOfLiquidityTokens,
 234 |     |         uint256 _quoteTokenQty,
 235 |     |         uint256 _quoteTokenReserveBalance
 236 | *   |     ) internal pure returns (uint256 liquidityTokenQty) {
 237 |     |         liquidityTokenQty =
 238 |     |             (_quoteTokenQty * _totalSupplyOfLiquidityTokens) /
 239 |     |             _quoteTokenReserveBalance;
 240 |     |     }
 241 |     | 
 242 |     |     /**
 243 |     |      * @dev used to calculate the qty of quote token required and liquidity tokens (deltaRo) to be issued
 244 |     |      * in order to add liquidity and remove base token decay.
 245 |     |      * @param _quoteTokenQtyDesired the amount of quote token the user wants to contribute
 246 |     |      * @param _baseTokenReserveQty the external base token reserve qty prior to this transaction
 247 |     |      * @param _totalSupplyOfLiquidityTokens the total supply of our exchange's liquidity tokens (aka Ro)
 248 |     |      * @param _internalBalances internal balances struct from our exchange's internal accounting
 249 |     |      *
 250 |     |      *
 251 |     |      * @return quoteTokenQty qty of quote token the user must supply
 252 |     |      * @return liquidityTokenQty qty of liquidity tokens to be issued in exchange
 253 |     |      */
 254 |     |     function calculateAddQuoteTokenLiquidityQuantities(
 255 |     |         uint256 _quoteTokenQtyDesired,
 256 |     |         uint256 _baseTokenReserveQty,
 257 |     |         uint256 _totalSupplyOfLiquidityTokens,
 258 |     |         InternalBalances storage _internalBalances
 259 |     |     ) internal returns (uint256 quoteTokenQty, uint256 liquidityTokenQty) {
 260 |     |         uint256 baseTokenDecay =
 261 |     |             _baseTokenReserveQty - _internalBalances.baseTokenReserveQty;
 262 |     | 
 263 |     |         // determine max amount of quote token that can be added to offset the current decay
 264 |     |         uint256 wInternalBaseTokenToQuoteTokenRatio =
 265 |     |             wDiv(
 266 |     |                 _internalBalances.baseTokenReserveQty,
 267 |     |                 _internalBalances.quoteTokenReserveQty
 268 |     |             );
 269 |     | 
 270 |     |         // alphaDecay / omega (A/B)
 271 |     |         uint256 maxQuoteTokenQty =
 272 |     |             wDiv(baseTokenDecay, wInternalBaseTokenToQuoteTokenRatio);
 273 |     | 
 274 |     |         if (_quoteTokenQtyDesired > maxQuoteTokenQty) {
 275 |     |             quoteTokenQty = maxQuoteTokenQty;
 276 |     |         } else {
 277 |     |             quoteTokenQty = _quoteTokenQtyDesired;
 278 |     |         }
 279 |     | 
 280 |     |         uint256 baseTokenQtyDecayChange =
 281 |     |             roundToNearest(
 282 |     |                 (quoteTokenQty * wInternalBaseTokenToQuoteTokenRatio),
 283 |     |                 WAD
 284 |     |             ) / WAD;
 285 |     | 
 286 |     |         require(
 287 |     |             baseTokenQtyDecayChange != 0,
 288 |     |             "MathLib: INSUFFICIENT_CHANGE_IN_DECAY"
 289 |     |         );
 290 |     |         //x += alphaDecayChange
 291 |     |         //y += deltaBeta
 292 |     |         _internalBalances.baseTokenReserveQty += baseTokenQtyDecayChange;
 293 |     |         _internalBalances.quoteTokenReserveQty += quoteTokenQty;
 294 |     | 
 295 |     |         // calculate the number of liquidity tokens to return to user using
 296 |     |         liquidityTokenQty = calculateLiquidityTokenQtyForSingleAssetEntryWithBaseTokenDecay(
 297 |     |             _baseTokenReserveQty,
 298 |     |             _totalSupplyOfLiquidityTokens,
 299 |     |             quoteTokenQty,
 300 |     |             _internalBalances.quoteTokenReserveQty,
 301 |     |             wInternalBaseTokenToQuoteTokenRatio
 302 |     |         );
 303 |     |         return (quoteTokenQty, liquidityTokenQty);
 304 |     |     }
 305 |     | 
 306 |     |     /**
 307 |     |      * @dev used to calculate the qty of base tokens required and liquidity tokens (deltaRo) to be issued
 308 |     |      * in order to add liquidity and remove base token decay.
 309 |     |      * @param _baseTokenQtyDesired the amount of base token the user wants to contribute
 310 |     |      * @param _baseTokenQtyMin the minimum amount of base token the user wants to contribute (allows for slippage)
 311 |     |      * @param _baseTokenReserveQty the external base token reserve qty prior to this transaction
 312 |     |      * @param _totalSupplyOfLiquidityTokens the total supply of our exchange's liquidity tokens (aka Ro)
 313 |     |      * @param _internalBalances internal balances struct from our exchange's internal accounting
 314 |     |      *
 315 |     |      * @return baseTokenQty qty of base token the user must supply
 316 |     |      * @return liquidityTokenQty qty of liquidity tokens to be issued in exchange
 317 |     |      */
 318 | *   |     function calculateAddBaseTokenLiquidityQuantities(
 319 |     |         uint256 _baseTokenQtyDesired,
 320 |     |         uint256 _baseTokenQtyMin,
 321 |     |         uint256 _baseTokenReserveQty,
 322 |     |         uint256 _totalSupplyOfLiquidityTokens,
 323 |     |         InternalBalances memory _internalBalances
 324 |     |     ) internal pure returns (uint256 baseTokenQty, uint256 liquidityTokenQty) {
 325 |     |         uint256 maxBaseTokenQty =
 326 |     |             _internalBalances.baseTokenReserveQty - _baseTokenReserveQty;
 327 |     |         require(
 328 |     |             _baseTokenQtyMin <= maxBaseTokenQty,
 329 |     |             "MathLib: INSUFFICIENT_DECAY"
 330 |     |         );
 331 |     | 
 332 | *   |         if (_baseTokenQtyDesired > maxBaseTokenQty) {
 333 | *   |             baseTokenQty = maxBaseTokenQty;
 334 |     |         } else {
 335 | *   |             baseTokenQty = _baseTokenQtyDesired;
 336 |     |         }
 337 |     | 
 338 |     |         // determine the quote token qty decay change quoted on our current ratios
 339 | *   |         uint256 wInternalQuoteToBaseTokenRatio =
 340 | *   |             wDiv(
 341 | *   |                 _internalBalances.quoteTokenReserveQty,
 342 | *   |                 _internalBalances.baseTokenReserveQty
 343 |     |             );
 344 |     | 
 345 |     |         // NOTE we need this function to use the same
 346 |     |         // rounding scheme as wDiv in order to avoid a case
 347 |     |         // in which a user is trying to resolve decay in which
 348 |     |         // quoteTokenQtyDecayChange ends up being 0 and we are stuck in
 349 |     |         // a bad state.
 350 | *   |         uint256 quoteTokenQtyDecayChange =
 351 | *   |             roundToNearest(
 352 | *   |                 (baseTokenQty * wInternalQuoteToBaseTokenRatio),
 353 |     |                 MathLib.WAD
 354 |     |             ) / WAD;
 355 |     | 
 356 | *   |         require(
 357 | *   |             quoteTokenQtyDecayChange != 0,
 358 |     |             "MathLib: INSUFFICIENT_CHANGE_IN_DECAY"
 359 |     |         );
 360 |     | 
 361 |     |         // we can now calculate the total amount of quote token decay
 362 | *   |         uint256 quoteTokenDecay =
 363 | *   |             (maxBaseTokenQty * wInternalQuoteToBaseTokenRatio) / WAD;
 364 |     | 
 365 |     |         // this may be redundant quoted on the above math, but will check to ensure the decay wasn't so small
 366 |     |         // that it was <1 and rounded down to 0 saving the caller some gas
 367 |     |         // also could fix a potential revert due to div by zero.
 368 | *   |         require(quoteTokenDecay != 0, "MathLib: NO_QUOTE_DECAY");
 369 |     | 
 370 |     |         // we are not changing anything about our internal accounting here. We are simply adding tokens
 371 |     |         // to make our internal account "right"...or rather getting the external balances to match our internal
 372 |     |         // quoteTokenReserveQty += quoteTokenQtyDecayChange;
 373 |     |         // baseTokenReserveQty += baseTokenQty;
 374 |     | 
 375 |     |         // calculate the number of liquidity tokens to return to user using:
 376 | *   |         liquidityTokenQty = calculateLiquidityTokenQtyForSingleAssetEntryWithQuoteTokenDecay(
 377 | *   |             _baseTokenReserveQty,
 378 | *   |             _totalSupplyOfLiquidityTokens,
 379 | *   |             baseTokenQty,
 380 | *   |             _internalBalances.baseTokenReserveQty
 381 |     |         );
 382 |     |     }
 383 |     | 
 384 |     |     /**
 385 |     |      * @dev used to calculate the qty of tokens a user will need to contribute and be issued in order to add liquidity
 386 |     |      * @param _baseTokenQtyDesired the amount of base token the user wants to contribute
 387 |     |      * @param _quoteTokenQtyDesired the amount of quote token the user wants to contribute
 388 |     |      * @param _baseTokenQtyMin the minimum amount of base token the user wants to contribute (allows for slippage)
 389 |     |      * @param _quoteTokenQtyMin the minimum amount of quote token the user wants to contribute (allows for slippage)
 390 |     |      * @param _baseTokenReserveQty the external base token reserve qty prior to this transaction
 391 |     |      * @param _totalSupplyOfLiquidityTokens the total supply of our exchange's liquidity tokens (aka Ro)
 392 |     |      * @param _internalBalances internal balances struct from our exchange's internal accounting
 393 |     |      *
 394 |     |      * @return tokenQtys qty of tokens needed to complete transaction
 395 |     |      */
 396 | *   |     function calculateAddLiquidityQuantities(
 397 |     |         uint256 _baseTokenQtyDesired,
 398 |     |         uint256 _quoteTokenQtyDesired,
 399 |     |         uint256 _baseTokenQtyMin,
 400 |     |         uint256 _quoteTokenQtyMin,
 401 |     |         uint256 _baseTokenReserveQty,
 402 |     |         uint256 _totalSupplyOfLiquidityTokens,
 403 |     |         InternalBalances storage _internalBalances
 404 |     |     ) internal returns (TokenQtys memory tokenQtys) {
 405 | *   |         if (_totalSupplyOfLiquidityTokens != 0) {
 406 |     |             // we have outstanding liquidity tokens present and an existing price curve
 407 |     | 
 408 |     |             tokenQtys.liquidityTokenFeeQty = calculateLiquidityTokenFees(
 409 |     |                 _totalSupplyOfLiquidityTokens,
 410 |     |                 _internalBalances
 411 |     |             );
 412 |     | 
 413 |     |             // we need to take this amount (that will be minted) into account for below calculations
 414 |     |             _totalSupplyOfLiquidityTokens += tokenQtys.liquidityTokenFeeQty;
 415 |     | 
 416 |     |             // confirm that we have no beta or alpha decay present
 417 |     |             // if we do, we need to resolve that first
 418 |     |             if (
 419 |     |                 isSufficientDecayPresent(
 420 |     |                     _baseTokenReserveQty,
 421 |     |                     _internalBalances
 422 |     |                 )
 423 |     |             ) {
 424 |     |                 // decay is present and needs to be dealt with by the caller.
 425 |     | 
 426 |     |                 uint256 baseTokenQtyFromDecay;
 427 |     |                 uint256 quoteTokenQtyFromDecay;
 428 |     |                 uint256 liquidityTokenQtyFromDecay;
 429 |     | 
 430 |     |                 if (
 431 |     |                     _baseTokenReserveQty > _internalBalances.baseTokenReserveQty
 432 |     |                 ) {
 433 |     |                     // we have more base token than expected (base token decay) due to rebase up
 434 |     |                     // we first need to handle this situation by requiring this user
 435 |     |                     // to add quote tokens
 436 |     |                     (
 437 |     |                         quoteTokenQtyFromDecay,
 438 |     |                         liquidityTokenQtyFromDecay
 439 |     |                     ) = calculateAddQuoteTokenLiquidityQuantities(
 440 |     |                         _quoteTokenQtyDesired,
 441 |     |                         _baseTokenReserveQty,
 442 |     |                         _totalSupplyOfLiquidityTokens,
 443 |     |                         _internalBalances
 444 |     |                     );
 445 |     |                 } else {
 446 |     |                     // we have less base token than expected (quote token decay) due to a rebase down
 447 |     |                     // we first need to handle this by adding base tokens to offset this.
 448 |     |                     (
 449 |     |                         baseTokenQtyFromDecay,
 450 |     |                         liquidityTokenQtyFromDecay
 451 |     |                     ) = calculateAddBaseTokenLiquidityQuantities(
 452 |     |                         _baseTokenQtyDesired,
 453 |     |                         0, // there is no minimum for this particular call since we may use base tokens later.
 454 |     |                         _baseTokenReserveQty,
 455 |     |                         _totalSupplyOfLiquidityTokens,
 456 |     |                         _internalBalances
 457 |     |                     );
 458 |     |                 }
 459 |     | 
 460 | *   |                 if (
 461 |     |                     quoteTokenQtyFromDecay < _quoteTokenQtyDesired &&
 462 |     |                     baseTokenQtyFromDecay < _baseTokenQtyDesired
 463 |     |                 ) {
 464 |     |                     // the user still has qty that they desire to contribute to the exchange for liquidity
 465 | *   |                     (
 466 |     |                         tokenQtys.baseTokenQty,
 467 | *   |                         tokenQtys.quoteTokenQty,
 468 |     |                         tokenQtys.liquidityTokenQty
 469 |     |                     ) = calculateAddTokenPairLiquidityQuantities(
 470 |     |                         _baseTokenQtyDesired - baseTokenQtyFromDecay, // safe from underflow quoted on above IF
 471 |     |                         _quoteTokenQtyDesired - quoteTokenQtyFromDecay, // safe from underflow quoted on above IF
 472 |     |                         0, // we will check minimums below
 473 |     |                         0, // we will check minimums below
 474 |     |                         _totalSupplyOfLiquidityTokens +
 475 |     |                             liquidityTokenQtyFromDecay,
 476 |     |                         _internalBalances // NOTE: these balances have already been updated when we did the decay math.
 477 |     |                     );
 478 |     |                 }
 479 | *   |                 tokenQtys.baseTokenQty += baseTokenQtyFromDecay;
 480 | *   |                 tokenQtys.quoteTokenQty += quoteTokenQtyFromDecay;
 481 |     |                 tokenQtys.liquidityTokenQty += liquidityTokenQtyFromDecay;
 482 |     | 
 483 |     |                 require(
 484 |     |                     tokenQtys.baseTokenQty >= _baseTokenQtyMin,
 485 |     |                     "MathLib: INSUFFICIENT_BASE_QTY"
 486 |     |                 );
 487 |     | 
 488 |     |                 require(
 489 |     |                     tokenQtys.quoteTokenQty >= _quoteTokenQtyMin,
 490 |     |                     "MathLib: INSUFFICIENT_QUOTE_QTY"
 491 |     |                 );
 492 |     |             } else {
 493 |     |                 // the user is just doing a simple double asset entry / providing both base and quote.
 494 |     |                 (
 495 |     |                     tokenQtys.baseTokenQty,
 496 |     |                     tokenQtys.quoteTokenQty,
 497 |     |                     tokenQtys.liquidityTokenQty
 498 |     |                 ) = calculateAddTokenPairLiquidityQuantities(
 499 |     |                     _baseTokenQtyDesired,
 500 |     |                     _quoteTokenQtyDesired,
 501 |     |                     _baseTokenQtyMin,
 502 |     |                     _quoteTokenQtyMin,
 503 |     |                     _totalSupplyOfLiquidityTokens,
 504 |     |                     _internalBalances
 505 |     |                 );
 506 |     |             }
 507 |     |         } else {
 508 |     |             // this user will set the initial pricing curve
 509 | *   |             require(
 510 |     |                 _baseTokenQtyDesired != 0,
 511 |     |                 "MathLib: INSUFFICIENT_BASE_QTY_DESIRED"
 512 |     |             );
 513 | *   |             require(
 514 | *   |                 _quoteTokenQtyDesired != 0,
 515 |     |                 "MathLib: INSUFFICIENT_QUOTE_QTY_DESIRED"
 516 |     |             );
 517 |     | 
 518 | *   |             tokenQtys.baseTokenQty = _baseTokenQtyDesired;
 519 | *   |             tokenQtys.quoteTokenQty = _quoteTokenQtyDesired;
 520 | *   |             tokenQtys.liquidityTokenQty = sqrt(
 521 | *   |                 _baseTokenQtyDesired * _quoteTokenQtyDesired
 522 |     |             );
 523 |     | 
 524 | *   |             _internalBalances.baseTokenReserveQty += tokenQtys.baseTokenQty;
 525 | *   |             _internalBalances.quoteTokenReserveQty += tokenQtys.quoteTokenQty;
 526 |     |         }
 527 |     |     }
 528 |     | 
 529 |     |     /**
 530 |     |      * @dev calculates the qty of base and quote tokens required and liquidity tokens (deltaRo) to be issued
 531 |     |      * in order to add liquidity when no decay is present.
 532 |     |      * @param _baseTokenQtyDesired the amount of base token the user wants to contribute
 533 |     |      * @param _quoteTokenQtyDesired the amount of quote token the user wants to contribute
 534 |     |      * @param _baseTokenQtyMin the minimum amount of base token the user wants to contribute (allows for slippage)
 535 |     |      * @param _quoteTokenQtyMin the minimum amount of quote token the user wants to contribute (allows for slippage)
 536 |     |      * @param _totalSupplyOfLiquidityTokens the total supply of our exchange's liquidity tokens (aka Ro)
 537 |     |      * @param _internalBalances internal balances struct from our exchange's internal accounting
 538 |     |      *
 539 |     |      * @return baseTokenQty qty of base token the user must supply
 540 |     |      * @return quoteTokenQty qty of quote token the user must supply
 541 |     |      * @return liquidityTokenQty qty of liquidity tokens to be issued in exchange
 542 |     |      */
 543 | *   |     function calculateAddTokenPairLiquidityQuantities(
 544 |     |         uint256 _baseTokenQtyDesired,
 545 |     |         uint256 _quoteTokenQtyDesired,
 546 |     |         uint256 _baseTokenQtyMin,
 547 |     |         uint256 _quoteTokenQtyMin,
 548 |     |         uint256 _totalSupplyOfLiquidityTokens,
 549 |     |         InternalBalances storage _internalBalances
 550 |     |     )
 551 |     |         internal
 552 |     |         returns (
 553 | *   |             uint256 baseTokenQty,
 554 | *   |             uint256 quoteTokenQty,
 555 | *   |             uint256 liquidityTokenQty
 556 |     |         )
 557 |     |     {
 558 | *   |         uint256 requiredQuoteTokenQty =
 559 | *   |             calculateQty(
 560 | *   |                 _baseTokenQtyDesired,
 561 | *   |                 _internalBalances.baseTokenReserveQty,
 562 | *   |                 _internalBalances.quoteTokenReserveQty
 563 |     |             );
 564 |     | 
 565 | *   |         if (requiredQuoteTokenQty <= _quoteTokenQtyDesired) {
 566 |     |             // user has to provide less than their desired amount
 567 | *   |             require(
 568 | *   |                 requiredQuoteTokenQty >= _quoteTokenQtyMin,
 569 |     |                 "MathLib: INSUFFICIENT_QUOTE_QTY"
 570 |     |             );
 571 | *   |             baseTokenQty = _baseTokenQtyDesired;
 572 | *   |             quoteTokenQty = requiredQuoteTokenQty;
 573 |     |         } else {
 574 |     |             // we need to check the opposite way.
 575 | *   |             uint256 requiredBaseTokenQty =
 576 | *   |                 calculateQty(
 577 | *   |                     _quoteTokenQtyDesired,
 578 | *   |                     _internalBalances.quoteTokenReserveQty,
 579 | *   |                     _internalBalances.baseTokenReserveQty
 580 |     |                 );
 581 |     | 
 582 | *   |             require(
 583 | *   |                 requiredBaseTokenQty >= _baseTokenQtyMin,
 584 |     |                 "MathLib: INSUFFICIENT_BASE_QTY"
 585 |     |             );
 586 | *   |             baseTokenQty = requiredBaseTokenQty;
 587 | *   |             quoteTokenQty = _quoteTokenQtyDesired;
 588 |     |         }
 589 |     | 
 590 | *   |         liquidityTokenQty = calculateLiquidityTokenQtyForDoubleAssetEntry(
 591 | *   |             _totalSupplyOfLiquidityTokens,
 592 | *   |             quoteTokenQty,
 593 | *   |             _internalBalances.quoteTokenReserveQty
 594 |     |         );
 595 |     | 
 596 | *   |         _internalBalances.baseTokenReserveQty += baseTokenQty;
 597 |     |         _internalBalances.quoteTokenReserveQty += quoteTokenQty;
 598 |     |     }
 599 |     | 
 600 |     |     /**
 601 |     |      * @dev calculates the qty of base tokens a user will receive for swapping their quote tokens (less fees)
 602 |     |      * @param _quoteTokenQty the amount of quote tokens the user wants to swap
 603 |     |      * @param _baseTokenQtyMin the minimum about of base tokens they are willing to receive in return (slippage)
 604 |     |      * @param _baseTokenReserveQty the external base token reserve qty prior to this transaction
 605 |     |      * @param _liquidityFeeInBasisPoints the current total liquidity fee represented as an integer of basis points
 606 |     |      * @param _internalBalances internal balances struct from our exchange's internal accounting
 607 |     |      *
 608 |     |      * @return baseTokenQty qty of base token the user will receive back
 609 |     |      */
 610 | *   |     function calculateBaseTokenQty(
 611 |     |         uint256 _quoteTokenQty,
 612 |     |         uint256 _baseTokenQtyMin,
 613 |     |         uint256 _baseTokenReserveQty,
 614 |     |         uint256 _liquidityFeeInBasisPoints,
 615 |     |         InternalBalances storage _internalBalances
 616 | *   |     ) internal returns (uint256 baseTokenQty) {
 617 | *   |         require(
 618 | *   |             _baseTokenReserveQty != 0 &&
 619 | *   |                 _internalBalances.baseTokenReserveQty != 0,
 620 |     |             "MathLib: INSUFFICIENT_BASE_TOKEN_QTY"
 621 |     |         );
 622 |     | 
 623 |     |         // check to see if we have experience quote token decay / a rebase down event
 624 | *   |         if (_baseTokenReserveQty < _internalBalances.baseTokenReserveQty) {
 625 |     |             // we have less reserves than our current price curve will expect, we need to adjust the curve
 626 | *   |             uint256 wPricingRatio =
 627 | *   |                 wDiv(
 628 | *   |                     _internalBalances.baseTokenReserveQty,
 629 | *   |                     _internalBalances.quoteTokenReserveQty
 630 |     |                 ); // omega
 631 |     | 
 632 | *   |             uint256 impliedQuoteTokenQty =
 633 | *   |                 wDiv(_baseTokenReserveQty, wPricingRatio); // no need to divide by WAD, wPricingRatio is already a WAD.
 634 |     | 
 635 | *   |             baseTokenQty = calculateQtyToReturnAfterFees(
 636 | *   |                 _quoteTokenQty,
 637 | *   |                 impliedQuoteTokenQty,
 638 | *   |                 _baseTokenReserveQty, // use the actual balance here since we adjusted the quote token to match ratio!
 639 | *   |                 _liquidityFeeInBasisPoints
 640 |     |             );
 641 |     |         } else {
 642 |     |             // we have the same or more reserves, no need to alter the curve.
 643 | *   |             baseTokenQty = calculateQtyToReturnAfterFees(
 644 | *   |                 _quoteTokenQty,
 645 | *   |                 _internalBalances.quoteTokenReserveQty,
 646 | *   |                 _internalBalances.baseTokenReserveQty,
 647 | *   |                 _liquidityFeeInBasisPoints
 648 |     |             );
 649 |     |         }
 650 |     | 
 651 | *   |         require(
 652 | *   |             baseTokenQty >= _baseTokenQtyMin,
 653 |     |             "MathLib: INSUFFICIENT_BASE_TOKEN_QTY"
 654 |     |         );
 655 |     | 
 656 | *   |         _internalBalances.baseTokenReserveQty -= baseTokenQty;
 657 | *   |         _internalBalances.quoteTokenReserveQty += _quoteTokenQty;
 658 |     |     }
 659 |     | 
 660 |     |     /**
 661 |     |      * @dev calculates the qty of quote tokens a user will receive for swapping their base tokens (less fees)
 662 |     |      * @param _baseTokenQty the amount of bases tokens the user wants to swap
 663 |     |      * @param _quoteTokenQtyMin the minimum about of quote tokens they are willing to receive in return (slippage)
 664 |     |      * @param _liquidityFeeInBasisPoints the current total liquidity fee represented as an integer of basis points
 665 |     |      * @param _internalBalances internal balances struct from our exchange's internal accounting
 666 |     |      *
 667 |     |      * @return quoteTokenQty qty of quote token the user will receive back
 668 |     |      */
 669 | *   |     function calculateQuoteTokenQty(
 670 |     |         uint256 _baseTokenQty,
 671 |     |         uint256 _quoteTokenQtyMin,
 672 |     |         uint256 _liquidityFeeInBasisPoints,
 673 |     |         InternalBalances storage _internalBalances
 674 | *   |     ) internal returns (uint256 quoteTokenQty) {
 675 | *   |         require(
 676 | *   |             _baseTokenQty != 0 && _quoteTokenQtyMin != 0,
 677 |     |             "MathLib: INSUFFICIENT_TOKEN_QTY"
 678 |     |         );
 679 |     | 
 680 | *   |         quoteTokenQty = calculateQtyToReturnAfterFees(
 681 | *   |             _baseTokenQty,
 682 | *   |             _internalBalances.baseTokenReserveQty,
 683 | *   |             _internalBalances.quoteTokenReserveQty,
 684 | *   |             _liquidityFeeInBasisPoints
 685 |     |         );
 686 |     | 
 687 | *   |         require(
 688 | *   |             quoteTokenQty >= _quoteTokenQtyMin,
 689 |     |             "MathLib: INSUFFICIENT_QUOTE_TOKEN_QTY"
 690 |     |         );
 691 |     | 
 692 |     |         _internalBalances.baseTokenReserveQty += _baseTokenQty;
 693 | *   |         _internalBalances.quoteTokenReserveQty -= quoteTokenQty;
 694 |     |     }
 695 |     | 
 696 |     |     /**
 697 |     |      * @dev calculates the qty of liquidity tokens that should be sent to the DAO due to the growth in K from trading.
 698 |     |      * 50BPS is the total fee, 25 goes to the LPs, 5 BP to the DAO, and 20 BP to staking rewards and liquidity incentives
 699 |     |      * @param _totalSupplyOfLiquidityTokens the total supply of our exchange's liquidity tokens (aka Ro)
 700 |     |      * @param _internalBalances internal balances struct from our exchange's internal accounting
 701 |     |      *
 702 |     |      * @return liquidityTokenFeeQty qty of tokens to be minted to the fee address for the growth in K
 703 |     |      */
 704 | *   |     function calculateLiquidityTokenFees(
 705 |     |         uint256 _totalSupplyOfLiquidityTokens,
 706 |     |         InternalBalances memory _internalBalances
 707 | *   |     ) internal pure returns (uint256 liquidityTokenFeeQty) {
 708 | *   |         uint256 rootK =
 709 | *   |             sqrt(
 710 | *   |                 _internalBalances.baseTokenReserveQty *
 711 | *   |                     _internalBalances.quoteTokenReserveQty
 712 |     |             );
 713 | *   |         uint256 rootKLast = sqrt(_internalBalances.kLast);
 714 | *   |         if (rootK > rootKLast) {
 715 | *   |             uint256 numerator =
 716 | *   |                 _totalSupplyOfLiquidityTokens * (rootK - rootKLast);
 717 |     |             uint256 denominator = rootK * 2;
 718 |     |             liquidityTokenFeeQty = numerator / denominator;
 719 |     |         }
 720 |     |     }
 721 |     | }
 722 |     | 

/Users/nelsonpereira/Documents/GitHub/Auditing/Fuzzy/Blogs/ElasticSwap_Recon/elasticswap-recon/src/libraries/SafeMetadata.sol
  1 |     | //SPDX-License-Identifier: GPL-3.0
  2 |     | pragma solidity 0.8.4;
  3 |     | 
  4 |     | import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
  5 |     | import "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol";
  6 |     | 
  7 |     | library SafeMetadata {
  8 |     |     function safeName(IERC20 token) internal view returns (string memory) {
  9 |     |         (bool success, bytes memory data) =
 10 |     |             address(token).staticcall(
 11 |     |                 abi.encodeWithSelector(IERC20Metadata.name.selector)
 12 |     |             );
 13 |     |         if (success) return abi.decode(data, (string));
 14 |     |         return "Token";
 15 |     |     }
 16 |     | 
 17 |     |     function safeSymbol(IERC20 token) internal view returns (string memory) {
 18 |     |         (bool success, bytes memory data) =
 19 |     |             address(token).staticcall(
 20 |     |                 abi.encodeWithSelector(IERC20Metadata.symbol.selector)
 21 |     |             );
 22 |     |         if (success) return abi.decode(data, (string));
 23 |     |         return "TKN";
 24 |     |     }
 25 |     | 
 26 |     |     function safeDecimals(IERC20 token) internal view returns (uint8) {
 27 |     |         (bool success, bytes memory data) =
 28 |     |             address(token).staticcall(
 29 |     |                 abi.encodeWithSelector(IERC20Metadata.decimals.selector)
 30 |     |             );
 31 |     |         if (success && data.length >= 32) return abi.decode(data, (uint8));
 32 |     |         return 18;
 33 |     |     }
 34 |     | }
 35 |     | 

/Users/nelsonpereira/Documents/GitHub/Auditing/Fuzzy/Blogs/ElasticSwap_Recon/elasticswap-recon/test/recon/BeforeAfter.sol
  1 |     | 
  2 |     | // SPDX-License-Identifier: GPL-2.0
  3 |     | pragma solidity ^0.8.0;
  4 |     | 
  5 |     | import {Setup} from "./Setup.sol";
  6 |     | 
  7 |     | abstract contract BeforeAfter is Setup {
  8 |     | 
  9 |     |     struct InternalBalances {
 10 |     |         // x*y=k - we track these internally to compare to actual balances of the ERC20's
 11 |     |         // in order to calculate the "decay" or the amount of balances that are not
 12 |     |         // participating in the pricing curve and adding additional liquidity to swap.
 13 |     |         uint256 baseTokenReserveQty; // x
 14 |     |         uint256 quoteTokenReserveQty; // y
 15 |     |         uint256 kLast; // as of the last add / rem liquidity event
 16 |     |     }
 17 |     | 
 18 |     |     struct Vars {
 19 |     |         InternalBalances exchange_internalBalances;
 20 |     |     }
 21 |     | 
 22 |     |     Vars internal _before;
 23 |     |     Vars internal _after;
 24 |     | 
 25 |     |     function __before() internal {
 26 |     |         (
 27 |     |             _before.exchange_internalBalances.baseTokenReserveQty,
 28 |     |             _before.exchange_internalBalances.quoteTokenReserveQty,
 29 |     |             _before.exchange_internalBalances.kLast
 30 |     |         ) = exchange.internalBalances();
 31 |     |     }
 32 |     | 
 33 |     |     function __after() internal {
 34 |     |         (
 35 |     |             _after.exchange_internalBalances.baseTokenReserveQty,
 36 |     |             _after.exchange_internalBalances.quoteTokenReserveQty,
 37 |     |             _after.exchange_internalBalances.kLast
 38 |     |         ) = exchange.internalBalances();
 39 |     |     } 
 40 |     | }
 41 |     | 

/Users/nelsonpereira/Documents/GitHub/Auditing/Fuzzy/Blogs/ElasticSwap_Recon/elasticswap-recon/test/recon/CryticTester.sol
  1 |     | 
  2 |     | // SPDX-License-Identifier: GPL-2.0
  3 |     | pragma solidity ^0.8.0;
  4 |     | 
  5 |     | import {TargetFunctions} from "./TargetFunctions.sol";
  6 |     | import {CryticAsserts} from "@chimera/CryticAsserts.sol";
  7 |     | 
  8 |     | // echidna . --contract CryticTester --config echidna.yaml
  9 |     | // medusa fuzz
 10 | *or | contract CryticTester is TargetFunctions, CryticAsserts {
 11 |     |     constructor() payable {
 12 |     |         setup();
 13 |     |     }
 14 |     | }
 15 |     | 

/Users/nelsonpereira/Documents/GitHub/Auditing/Fuzzy/Blogs/ElasticSwap_Recon/elasticswap-recon/test/recon/Properties.sol
  1 |     | 
  2 |     | // SPDX-License-Identifier: GPL-2.0
  3 |     | pragma solidity ^0.8.0;
  4 |     | 
  5 |     | import {Asserts} from "@chimera/Asserts.sol";
  6 |     | import {Setup} from "./Setup.sol";
  7 |     | 
  8 |     | abstract contract Properties is Setup, Asserts {
  9 |     | 
 10 |     |     // need a property that allows calling both functions and price doesn't change
 11 |     |     // price starts at a value -> functions get called -> price stays at same value
 12 |     |     // function invariant_priceDoesntChange() public returns (bool) {
 13 |     |     //     // price before actions are executed is stored in setup as previousBaseSpotPrice
 14 |     |     //     // this reads from storage and updates after each call
 15 |     |     //     (uint256 baseTokenReserveQty, uint256 quoteTokenReserveQty,) = exchange.internalBalances();
 16 |     |     //     uint256 currentBaseSpotPrice =  quoteTokenReserveQty / baseTokenReserveQty;
 17 |     |         
 18 |     |     //     // may need to use a percentage here to deal with potential rounding errors
 19 |     |     //     eq(previousBaseSpotPrice, currentBaseSpotPrice, "prices differ after call sequence");
 20 |     |     //     // return previousBaseSpotPrice == currentBaseSpotPrice;
 21 |     |     // }
 22 |     | 
 23 | *   |     function invariant_user_cant_gain_value() public returns (bool) {
 24 | *   |         return _getBalanceSum() <= initialUserBalance;
 25 |     |     }
 26 |     | 
 27 |     |     function crytic_user_cant_gain_value() public returns (bool) {
 28 |     |         return _getBalanceSum() <= initialUserBalance;
 29 |     |     }
 30 |     | }
 31 |     | 

/Users/nelsonpereira/Documents/GitHub/Auditing/Fuzzy/Blogs/ElasticSwap_Recon/elasticswap-recon/test/recon/Setup.sol
  1 |     | 
  2 |     | // SPDX-License-Identifier: GPL-2.0
  3 |     | pragma solidity ^0.8.0;
  4 |     | 
  5 |     | import {BaseSetup} from "@chimera/BaseSetup.sol";
  6 |     | import {ElasticMock} from "src/contracts/mocks/ElasticMock.sol";
  7 |     | // import {Token_ERC20} from "lib/forge-std/test/mocks/MockERC20.t.sol";
  8 |     | import {MockERC20} from "src/contracts/mocks/MockERC20.sol";
  9 |     | import {Exchange} from "src/contracts/Exchange.sol";
 10 |     | import {ExchangeFactory} from "src/contracts/ExchangeFactory.sol";
 11 |     | import "forge-std/console.sol";
 12 |     | import "lib/chimera/src/Hevm.sol";
 13 |     | 
 14 |     | // inheriting from Test to expose targetContracts function
 15 |     | abstract contract Setup is BaseSetup {
 16 |     | 
 17 |     |     ElasticMock elasticMockToken; // base token
 18 |     |     MockERC20 usdMockToken; // quote token
 19 |     |     ExchangeFactory exchangeFactory; 
 20 |     |     Exchange exchange; 
 21 |     | 
 22 |     |     uint256 previousBaseSpotPrice;
 23 |     | 
 24 |     |     uint256 initialUserBalance;
 25 |     | 
 26 |     |     function setup() internal virtual override {
 27 |     |       uint256 initialTokenBalance = 1000000000000000000000000000;
 28 |     |       // initial supply of ETM is minted to 0x10000 address
 29 |     |       elasticMockToken = new ElasticMock("ElasticTokenMock", "ETM", 3 * initialTokenBalance, address(0x10000));
 30 |     |       
 31 |     |       // transfer elasticMockToken to other addresses since it has fixed supply
 32 |     |       vm.prank(address(0x10000));
 33 |     |       elasticMockToken.transfer(address(0x20000), initialTokenBalance);
 34 |     |       vm.prank(address(0x10000));
 35 |     |       elasticMockToken.transfer(address(0x30000), initialTokenBalance);
 36 |     | 
 37 |     |       usdMockToken = new MockERC20("Fake-USD", "FUSD");
 38 |     |       // initialize the token and mint the initial supply to 0x10000 which is one of the senders so it can make donation to pool
 39 |     |       usdMockToken.mint(address(0x10000), initialTokenBalance);
 40 |     |       usdMockToken.mint(address(0x20000), initialTokenBalance);
 41 |     |       usdMockToken.mint(address(0x30000), initialTokenBalance);
 42 |     | 
 43 |     |       exchangeFactory = new ExchangeFactory(address(0x456));
 44 |     |       exchange = new Exchange("EGT LP Token", "EGTLPS", address(elasticMockToken), address(usdMockToken), address(exchangeFactory));
 45 |     |     
 46 |     |       // grant exchange permissions for sender's tokens
 47 |     |       vm.prank(address(0x10000));
 48 |     |       usdMockToken.approve(address(exchange), type(uint256).max);
 49 |     |       vm.prank(address(0x10000));
 50 |     |       elasticMockToken.approve(address(exchange), type(uint256).max);
 51 |     | 
 52 |     |       vm.prank(address(0x20000));
 53 |     |       usdMockToken.approve(address(exchange), type(uint256).max);
 54 |     |       vm.prank(address(0x20000));
 55 |     |       elasticMockToken.approve(address(exchange), type(uint256).max);
 56 |     | 
 57 |     |       vm.prank(address(0x30000));
 58 |     |       usdMockToken.approve(address(exchange), type(uint256).max);
 59 |     |       vm.prank(address(0x30000));
 60 |     |       elasticMockToken.approve(address(exchange), type(uint256).max);
 61 |     | 
 62 |     |       // seed exchange with tokens
 63 |     |       uint256 halfOfTokenBalance = initialTokenBalance / 2;
 64 |     |       vm.prank(address(0x20000));
 65 |     |       exchange.addLiquidity(halfOfTokenBalance, halfOfTokenBalance, halfOfTokenBalance - 10, halfOfTokenBalance - 10, address(0x20000), block.timestamp + 1);
 66 |     |       
 67 |     |       initialUserBalance = _getBalanceSum();
 68 |     | 
 69 |     |       // user adds liquidity
 70 |     |       vm.prank(address(0x30000));
 71 |     |       exchange.addLiquidity(initialTokenBalance, initialTokenBalance, initialTokenBalance, initialTokenBalance, address(0x30000), block.timestamp + 1);
 72 |     |       
 73 |     |       // spot price is just the ratio of the two quantities of tokens in the pool
 74 |     |       // this is initially set here then set after all function calls by the invariant
 75 |     |       // (uint256 baseTokenReserveQty, uint256 quoteTokenReserveQty,) = exchange.internalBalances();
 76 |     |       // previousBaseSpotPrice = quoteTokenReserveQty / baseTokenReserveQty;
 77 |     | 
 78 |     |       // required for foundry invariant testing
 79 |     |       // targetContract(address(exchange));
 80 |     |       // address[] memory targetContracts =  targetContracts();
 81 |     |       // address targetContracts0 = targetContracts[0];
 82 |     |       // console.log("targetContracts: ", targetContracts0);
 83 |     |     }
 84 |     | 
 85 | *   |     function _getBalanceSum() internal returns (uint256) {
 86 | *   |       return elasticMockToken.balanceOf(address(0x30000)) + usdMockToken.balanceOf(address(0x30000));
 87 |     |     }
 88 |     | }
 89 |     | 

/Users/nelsonpereira/Documents/GitHub/Auditing/Fuzzy/Blogs/ElasticSwap_Recon/elasticswap-recon/test/recon/TargetFunctions.sol
  1 |     | 
  2 |     | // SPDX-License-Identifier: GPL-2.0
  3 |     | pragma solidity ^0.8.0;
  4 |     | 
  5 |     | import {BaseTargetFunctions} from "@chimera/BaseTargetFunctions.sol";
  6 |     | import {BeforeAfter} from "./BeforeAfter.sol";
  7 |     | import {Properties} from "./Properties.sol";
  8 |     | import {vm} from "@chimera/Hevm.sol";
  9 |     | import "forge-std/console.sol";
 10 |     | 
 11 |     | abstract contract TargetFunctions is BaseTargetFunctions, Properties, BeforeAfter {
 12 |     | 
 13 | *   |   function eRC20_approve(address spender, uint256 amount) public {
 14 | *r  |     usdMockToken.approve(spender, amount);
 15 |     |   }
 16 |     |   
 17 | *   |   function eRC20_transfer(address to, uint256 amount) public {
 18 | *   |     usdMockToken.transfer(to, amount);
 19 |     |   }
 20 |     | 
 21 | *   |   function eRC20_transferFrom(address from, address to, uint256 amount) public {
 22 | *r  |     usdMockToken.transferFrom(from, to, amount);
 23 |     |   }
 24 |     | 
 25 |     |   // all _expirationTimestamp parameters have been replaced with block.timestamp + 1 to reduce fuzz runs being wasted on different values of this parameter
 26 | *   |   function exchange_addLiquidity(uint256 _baseTokenQtyDesired, uint256 _quoteTokenQtyDesired, uint256 _baseTokenQtyMin, uint256 _quoteTokenQtyMin, address _liquidityTokenRecipient) public {
 27 | *r  |     exchange.addLiquidity(_baseTokenQtyDesired, _quoteTokenQtyDesired, _baseTokenQtyMin, _quoteTokenQtyMin, _liquidityTokenRecipient, block.timestamp + 1);
 28 |     |   }
 29 |     | 
 30 | *   |   function exchange_removeLiquidity(uint256 _liquidityTokenQty, uint256 _baseTokenQtyMin, uint256 _quoteTokenQtyMin, address _tokenRecipient) public {
 31 | *r  |     exchange.removeLiquidity(_liquidityTokenQty, _baseTokenQtyMin, _quoteTokenQtyMin, _tokenRecipient, block.timestamp + 1);
 32 |     |   }
 33 |     | 
 34 | *   |   function exchange_swapBaseTokenForQuoteToken(uint256 _baseTokenQty, uint256 _minQuoteTokenQty) public {
 35 | *r  |     exchange.swapBaseTokenForQuoteToken(_baseTokenQty, _minQuoteTokenQty, block.timestamp + 1);
 36 |     |   }
 37 |     | 
 38 | *   |   function exchange_swapQuoteTokenForBaseToken(uint256 _quoteTokenQty, uint256 _minBaseTokenQty) public {
 39 | *   |     exchange.swapQuoteTokenForBaseToken(_quoteTokenQty, _minBaseTokenQty, block.timestamp + 1);
 40 |     |   }
 41 |     | }
 42 |     | 

