<style> code { white-space: pre-wrap; display: block; background-color: #eee; }.executed { background-color: #afa; }.reverted { background-color: #ffa; }.unexecuted { background-color: #faa; }.neutral { background-color: #eee; }</style><b>/Users/nelsonpereira/Documents/GitHub/Auditing/Fuzzy/Blogs/ElasticSwap_Recon/elasticswap-recon/lib/chimera/src/Asserts.sol</b>
<code>
  1 |     | <span class='unexecuted'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>abstract contract Asserts {</span>
  5 |     | <span class='neutral'>    function gt(uint256 a, uint256 b, string memory reason) internal virtual;</span>
  6 |     | <span class='neutral'></span>
  7 |     | <span class='neutral'>    function gte(uint256 a, uint256 b, string memory reason) internal virtual;</span>
  8 |     | <span class='neutral'></span>
  9 |     | <span class='neutral'>    function lt(uint256 a, uint256 b, string memory reason) internal virtual;</span>
 10 |     | <span class='neutral'></span>
 11 |     | <span class='neutral'>    function lte(uint256 a, uint256 b, string memory reason) internal virtual;</span>
 12 |     | <span class='neutral'></span>
 13 |     | <span class='neutral'>    function eq(uint256 a, uint256 b, string memory reason) internal virtual;</span>
 14 |     | <span class='neutral'></span>
 15 |     | <span class='neutral'>    function t(bool b, string memory reason) internal virtual;</span>
 16 |     | <span class='neutral'></span>
 17 |     | <span class='neutral'>    function between(uint256 value, uint256 low, uint256 high) internal virtual returns (uint256);</span>
 18 |     | <span class='neutral'></span>
 19 |     | <span class='neutral'>    function between(int256 value, int256 low, int256 high) internal virtual returns (int256);</span>
 20 |     | <span class='neutral'></span>
 21 |     | <span class='neutral'>    function precondition(bool p) internal virtual;</span>
 22 |     | <span class='neutral'>}</span>
 23 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/nelsonpereira/Documents/GitHub/Auditing/Fuzzy/Blogs/ElasticSwap_Recon/elasticswap-recon/lib/chimera/src/BaseProperties.sol</b>
<code>
 1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
 2 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
 3 |     | <span class='neutral'></span>
 4 |     | <span class='neutral'>import {BaseSetup} from &quot;./BaseSetup.sol&quot;;</span>
 5 |     | <span class='neutral'></span>
 6 |     | <span class='neutral'>abstract contract BaseProperties is BaseSetup {}</span>
 7 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/nelsonpereira/Documents/GitHub/Auditing/Fuzzy/Blogs/ElasticSwap_Recon/elasticswap-recon/lib/chimera/src/BaseSetup.sol</b>
<code>
 1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
 2 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
 3 |     | <span class='neutral'></span>
 4 |     | <span class='neutral'>abstract contract BaseSetup {</span>
 5 |     | <span class='neutral'>    function setup() internal virtual;</span>
 6 |     | <span class='neutral'>}</span>
 7 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/nelsonpereira/Documents/GitHub/Auditing/Fuzzy/Blogs/ElasticSwap_Recon/elasticswap-recon/lib/chimera/src/BaseTargetFunctions.sol</b>
<code>
 1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
 2 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
 3 |     | <span class='neutral'></span>
 4 |     | <span class='neutral'>import {BaseProperties} from &quot;./BaseProperties.sol&quot;;</span>
 5 |     | <span class='neutral'>import {Asserts} from &quot;./Asserts.sol&quot;;</span>
 6 |     | <span class='neutral'></span>
 7 |     | <span class='neutral'>abstract contract BaseTargetFunctions is BaseProperties, Asserts {}</span>
 8 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/nelsonpereira/Documents/GitHub/Auditing/Fuzzy/Blogs/ElasticSwap_Recon/elasticswap-recon/lib/chimera/src/CryticAsserts.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import {Asserts} from &quot;./Asserts.sol&quot;;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='unexecuted'>contract CryticAsserts is Asserts {</span>
  7 |     | <span class='neutral'>    event Log(string);</span>
  8 |     | <span class='neutral'></span>
  9 |     | <span class='neutral'>    function gt(uint256 a, uint256 b, string memory reason) internal virtual override {</span>
 10 |     | <span class='neutral'>        emit Log(reason);</span>
 11 |     | <span class='neutral'>        assert(a &gt; b);</span>
 12 |     | <span class='neutral'>    }</span>
 13 |     | <span class='neutral'></span>
 14 |     | <span class='neutral'>    function gte(uint256 a, uint256 b, string memory reason) internal virtual override {</span>
 15 |     | <span class='neutral'>        emit Log(reason);</span>
 16 |     | <span class='neutral'>        assert(a &gt;= b);</span>
 17 |     | <span class='neutral'>    }</span>
 18 |     | <span class='neutral'></span>
 19 |     | <span class='neutral'>    function lt(uint256 a, uint256 b, string memory reason) internal virtual override {</span>
 20 |     | <span class='neutral'>        emit Log(reason);</span>
 21 |     | <span class='neutral'>        assert(a &lt; b);</span>
 22 |     | <span class='neutral'>    }</span>
 23 |     | <span class='neutral'></span>
 24 |     | <span class='neutral'>    function lte(uint256 a, uint256 b, string memory reason) internal virtual override {</span>
 25 |     | <span class='neutral'>        emit Log(reason);</span>
 26 |     | <span class='neutral'>        assert(a &lt;= b);</span>
 27 |     | <span class='neutral'>    }</span>
 28 |     | <span class='neutral'></span>
 29 |     | <span class='neutral'>    function eq(uint256 a, uint256 b, string memory reason) internal virtual override {</span>
 30 |     | <span class='neutral'>        emit Log(reason);</span>
 31 |     | <span class='neutral'>        assert(a == b);</span>
 32 |     | <span class='neutral'>    }</span>
 33 |     | <span class='neutral'></span>
 34 |     | <span class='neutral'>    function t(bool b, string memory reason) internal virtual override {</span>
 35 |     | <span class='neutral'>        emit Log(reason);</span>
 36 |     | <span class='neutral'>        assert(b);</span>
 37 |     | <span class='neutral'>    }</span>
 38 |     | <span class='neutral'></span>
 39 |     | <span class='neutral'>    function between(uint256 value, uint256 low, uint256 high) internal virtual override returns (uint256) {</span>
 40 |     | <span class='neutral'>        if (value &lt; low || value &gt; high) {</span>
 41 |     | <span class='neutral'>            uint256 ans = low + (value % (high - low + 1));</span>
 42 |     | <span class='neutral'>            return ans;</span>
 43 |     | <span class='neutral'>        }</span>
 44 |     | <span class='neutral'>        return value;</span>
 45 |     | <span class='neutral'>    }</span>
 46 |     | <span class='neutral'></span>
 47 |     | <span class='neutral'>    function between(int256 value, int256 low, int256 high) internal virtual override returns (int256) {</span>
 48 |     | <span class='neutral'>        if (value &lt; low || value &gt; high) {</span>
 49 |     | <span class='neutral'>            int256 range = high - low + 1;</span>
 50 |     | <span class='neutral'>            int256 clamped = (value - low) % (range);</span>
 51 |     | <span class='neutral'>            if (clamped &lt; 0) clamped += range;</span>
 52 |     | <span class='neutral'>            int256 ans = low + clamped;</span>
 53 |     | <span class='neutral'>            return ans;</span>
 54 |     | <span class='neutral'>        }</span>
 55 |     | <span class='neutral'>        return value;</span>
 56 |     | <span class='neutral'>    }</span>
 57 |     | <span class='neutral'></span>
 58 |     | <span class='neutral'>    function precondition(bool p) internal virtual override {</span>
 59 |     | <span class='neutral'>        require(p);</span>
 60 |     | <span class='neutral'>    }</span>
 61 |     | <span class='neutral'>}</span>
 62 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/nelsonpereira/Documents/GitHub/Auditing/Fuzzy/Blogs/ElasticSwap_Recon/elasticswap-recon/lib/chimera/src/Hevm.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>interface IHevm {</span>
  5 |     | <span class='neutral'>    // Set block.timestamp to newTimestamp</span>
  6 |     | <span class='neutral'>    function warp(uint256 newTimestamp) external;</span>
  7 |     | <span class='neutral'></span>
  8 |     | <span class='neutral'>    // Set block.number to newNumber</span>
  9 |     | <span class='neutral'>    function roll(uint256 newNumber) external;</span>
 10 |     | <span class='neutral'></span>
 11 |     | <span class='neutral'>    // Loads a storage slot from an address</span>
 12 |     | <span class='neutral'>    function load(address where, bytes32 slot) external returns (bytes32);</span>
 13 |     | <span class='neutral'></span>
 14 |     | <span class='neutral'>    // Stores a value to an address&#39; storage slot</span>
 15 |     | <span class='neutral'>    function store(address where, bytes32 slot, bytes32 value) external;</span>
 16 |     | <span class='neutral'></span>
 17 |     | <span class='neutral'>    // Signs data (privateKey, digest) =&gt; (r, v, s)</span>
 18 |     | <span class='neutral'>    function sign(uint256 privateKey, bytes32 digest) external returns (uint8 r, bytes32 v, bytes32 s);</span>
 19 |     | <span class='neutral'></span>
 20 |     | <span class='neutral'>    // Gets address for a given private key</span>
 21 |     | <span class='neutral'>    function addr(uint256 privateKey) external returns (address account);</span>
 22 |     | <span class='neutral'></span>
 23 |     | <span class='neutral'>    // Performs a foreign function call via terminal</span>
 24 |     | <span class='neutral'>    function ffi(string[] calldata inputs) external returns (bytes memory result);</span>
 25 |     | <span class='neutral'></span>
 26 |     | <span class='neutral'>    // Performs the next smart contract call with specified `msg.sender`</span>
 27 |     | <span class='neutral'>    function prank(address newSender) external;</span>
 28 |     | <span class='neutral'>}</span>
 29 |     | <span class='neutral'></span>
 30 |     | <span class='unexecuted'>IHevm constant vm = IHevm(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D);</span>
 31 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/nelsonpereira/Documents/GitHub/Auditing/Fuzzy/Blogs/ElasticSwap_Recon/elasticswap-recon/lib/forge-std/src/console.sol</b>
<code>
    1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
    2 |     | <span class='neutral'>pragma solidity &gt;=0.4.22 &lt;0.9.0;</span>
    3 |     | <span class='neutral'></span>
    4 |     | <span class='unexecuted'>library console {</span>
    5 |     | <span class='neutral'>    address constant CONSOLE_ADDRESS = address(0x000000000000000000636F6e736F6c652e6c6f67);</span>
    6 |     | <span class='neutral'></span>
    7 |     | <span class='neutral'>    function _sendLogPayload(bytes memory payload) private view {</span>
    8 |     | <span class='neutral'>        uint256 payloadLength = payload.length;</span>
    9 |     | <span class='neutral'>        address consoleAddress = CONSOLE_ADDRESS;</span>
   10 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
   11 |     | <span class='neutral'>        assembly {</span>
   12 |     | <span class='neutral'>            let payloadStart := add(payload, 32)</span>
   13 |     | <span class='neutral'>            let r := staticcall(gas(), consoleAddress, payloadStart, payloadLength, 0, 0)</span>
   14 |     | <span class='neutral'>        }</span>
   15 |     | <span class='neutral'>    }</span>
   16 |     | <span class='neutral'></span>
   17 |     | <span class='neutral'>    function log() internal view {</span>
   18 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log()&quot;));</span>
   19 |     | <span class='neutral'>    }</span>
   20 |     | <span class='neutral'></span>
   21 |     | <span class='neutral'>    function logInt(int p0) internal view {</span>
   22 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(int)&quot;, p0));</span>
   23 |     | <span class='neutral'>    }</span>
   24 |     | <span class='neutral'></span>
   25 |     | <span class='neutral'>    function logUint(uint p0) internal view {</span>
   26 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint)&quot;, p0));</span>
   27 |     | <span class='neutral'>    }</span>
   28 |     | <span class='neutral'></span>
   29 |     | <span class='neutral'>    function logString(string memory p0) internal view {</span>
   30 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string)&quot;, p0));</span>
   31 |     | <span class='neutral'>    }</span>
   32 |     | <span class='neutral'></span>
   33 |     | <span class='neutral'>    function logBool(bool p0) internal view {</span>
   34 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool)&quot;, p0));</span>
   35 |     | <span class='neutral'>    }</span>
   36 |     | <span class='neutral'></span>
   37 |     | <span class='neutral'>    function logAddress(address p0) internal view {</span>
   38 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address)&quot;, p0));</span>
   39 |     | <span class='neutral'>    }</span>
   40 |     | <span class='neutral'></span>
   41 |     | <span class='neutral'>    function logBytes(bytes memory p0) internal view {</span>
   42 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes)&quot;, p0));</span>
   43 |     | <span class='neutral'>    }</span>
   44 |     | <span class='neutral'></span>
   45 |     | <span class='neutral'>    function logBytes1(bytes1 p0) internal view {</span>
   46 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes1)&quot;, p0));</span>
   47 |     | <span class='neutral'>    }</span>
   48 |     | <span class='neutral'></span>
   49 |     | <span class='neutral'>    function logBytes2(bytes2 p0) internal view {</span>
   50 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes2)&quot;, p0));</span>
   51 |     | <span class='neutral'>    }</span>
   52 |     | <span class='neutral'></span>
   53 |     | <span class='neutral'>    function logBytes3(bytes3 p0) internal view {</span>
   54 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes3)&quot;, p0));</span>
   55 |     | <span class='neutral'>    }</span>
   56 |     | <span class='neutral'></span>
   57 |     | <span class='neutral'>    function logBytes4(bytes4 p0) internal view {</span>
   58 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes4)&quot;, p0));</span>
   59 |     | <span class='neutral'>    }</span>
   60 |     | <span class='neutral'></span>
   61 |     | <span class='neutral'>    function logBytes5(bytes5 p0) internal view {</span>
   62 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes5)&quot;, p0));</span>
   63 |     | <span class='neutral'>    }</span>
   64 |     | <span class='neutral'></span>
   65 |     | <span class='neutral'>    function logBytes6(bytes6 p0) internal view {</span>
   66 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes6)&quot;, p0));</span>
   67 |     | <span class='neutral'>    }</span>
   68 |     | <span class='neutral'></span>
   69 |     | <span class='neutral'>    function logBytes7(bytes7 p0) internal view {</span>
   70 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes7)&quot;, p0));</span>
   71 |     | <span class='neutral'>    }</span>
   72 |     | <span class='neutral'></span>
   73 |     | <span class='neutral'>    function logBytes8(bytes8 p0) internal view {</span>
   74 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes8)&quot;, p0));</span>
   75 |     | <span class='neutral'>    }</span>
   76 |     | <span class='neutral'></span>
   77 |     | <span class='neutral'>    function logBytes9(bytes9 p0) internal view {</span>
   78 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes9)&quot;, p0));</span>
   79 |     | <span class='neutral'>    }</span>
   80 |     | <span class='neutral'></span>
   81 |     | <span class='neutral'>    function logBytes10(bytes10 p0) internal view {</span>
   82 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes10)&quot;, p0));</span>
   83 |     | <span class='neutral'>    }</span>
   84 |     | <span class='neutral'></span>
   85 |     | <span class='neutral'>    function logBytes11(bytes11 p0) internal view {</span>
   86 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes11)&quot;, p0));</span>
   87 |     | <span class='neutral'>    }</span>
   88 |     | <span class='neutral'></span>
   89 |     | <span class='neutral'>    function logBytes12(bytes12 p0) internal view {</span>
   90 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes12)&quot;, p0));</span>
   91 |     | <span class='neutral'>    }</span>
   92 |     | <span class='neutral'></span>
   93 |     | <span class='neutral'>    function logBytes13(bytes13 p0) internal view {</span>
   94 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes13)&quot;, p0));</span>
   95 |     | <span class='neutral'>    }</span>
   96 |     | <span class='neutral'></span>
   97 |     | <span class='neutral'>    function logBytes14(bytes14 p0) internal view {</span>
   98 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes14)&quot;, p0));</span>
   99 |     | <span class='neutral'>    }</span>
  100 |     | <span class='neutral'></span>
  101 |     | <span class='neutral'>    function logBytes15(bytes15 p0) internal view {</span>
  102 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes15)&quot;, p0));</span>
  103 |     | <span class='neutral'>    }</span>
  104 |     | <span class='neutral'></span>
  105 |     | <span class='neutral'>    function logBytes16(bytes16 p0) internal view {</span>
  106 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes16)&quot;, p0));</span>
  107 |     | <span class='neutral'>    }</span>
  108 |     | <span class='neutral'></span>
  109 |     | <span class='neutral'>    function logBytes17(bytes17 p0) internal view {</span>
  110 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes17)&quot;, p0));</span>
  111 |     | <span class='neutral'>    }</span>
  112 |     | <span class='neutral'></span>
  113 |     | <span class='neutral'>    function logBytes18(bytes18 p0) internal view {</span>
  114 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes18)&quot;, p0));</span>
  115 |     | <span class='neutral'>    }</span>
  116 |     | <span class='neutral'></span>
  117 |     | <span class='neutral'>    function logBytes19(bytes19 p0) internal view {</span>
  118 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes19)&quot;, p0));</span>
  119 |     | <span class='neutral'>    }</span>
  120 |     | <span class='neutral'></span>
  121 |     | <span class='neutral'>    function logBytes20(bytes20 p0) internal view {</span>
  122 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes20)&quot;, p0));</span>
  123 |     | <span class='neutral'>    }</span>
  124 |     | <span class='neutral'></span>
  125 |     | <span class='neutral'>    function logBytes21(bytes21 p0) internal view {</span>
  126 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes21)&quot;, p0));</span>
  127 |     | <span class='neutral'>    }</span>
  128 |     | <span class='neutral'></span>
  129 |     | <span class='neutral'>    function logBytes22(bytes22 p0) internal view {</span>
  130 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes22)&quot;, p0));</span>
  131 |     | <span class='neutral'>    }</span>
  132 |     | <span class='neutral'></span>
  133 |     | <span class='neutral'>    function logBytes23(bytes23 p0) internal view {</span>
  134 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes23)&quot;, p0));</span>
  135 |     | <span class='neutral'>    }</span>
  136 |     | <span class='neutral'></span>
  137 |     | <span class='neutral'>    function logBytes24(bytes24 p0) internal view {</span>
  138 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes24)&quot;, p0));</span>
  139 |     | <span class='neutral'>    }</span>
  140 |     | <span class='neutral'></span>
  141 |     | <span class='neutral'>    function logBytes25(bytes25 p0) internal view {</span>
  142 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes25)&quot;, p0));</span>
  143 |     | <span class='neutral'>    }</span>
  144 |     | <span class='neutral'></span>
  145 |     | <span class='neutral'>    function logBytes26(bytes26 p0) internal view {</span>
  146 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes26)&quot;, p0));</span>
  147 |     | <span class='neutral'>    }</span>
  148 |     | <span class='neutral'></span>
  149 |     | <span class='neutral'>    function logBytes27(bytes27 p0) internal view {</span>
  150 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes27)&quot;, p0));</span>
  151 |     | <span class='neutral'>    }</span>
  152 |     | <span class='neutral'></span>
  153 |     | <span class='neutral'>    function logBytes28(bytes28 p0) internal view {</span>
  154 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes28)&quot;, p0));</span>
  155 |     | <span class='neutral'>    }</span>
  156 |     | <span class='neutral'></span>
  157 |     | <span class='neutral'>    function logBytes29(bytes29 p0) internal view {</span>
  158 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes29)&quot;, p0));</span>
  159 |     | <span class='neutral'>    }</span>
  160 |     | <span class='neutral'></span>
  161 |     | <span class='neutral'>    function logBytes30(bytes30 p0) internal view {</span>
  162 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes30)&quot;, p0));</span>
  163 |     | <span class='neutral'>    }</span>
  164 |     | <span class='neutral'></span>
  165 |     | <span class='neutral'>    function logBytes31(bytes31 p0) internal view {</span>
  166 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes31)&quot;, p0));</span>
  167 |     | <span class='neutral'>    }</span>
  168 |     | <span class='neutral'></span>
  169 |     | <span class='neutral'>    function logBytes32(bytes32 p0) internal view {</span>
  170 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes32)&quot;, p0));</span>
  171 |     | <span class='neutral'>    }</span>
  172 |     | <span class='neutral'></span>
  173 |     | <span class='neutral'>    function log(uint p0) internal view {</span>
  174 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint)&quot;, p0));</span>
  175 |     | <span class='neutral'>    }</span>
  176 |     | <span class='neutral'></span>
  177 |     | <span class='neutral'>    function log(string memory p0) internal view {</span>
  178 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string)&quot;, p0));</span>
  179 |     | <span class='neutral'>    }</span>
  180 |     | <span class='neutral'></span>
  181 |     | <span class='neutral'>    function log(bool p0) internal view {</span>
  182 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool)&quot;, p0));</span>
  183 |     | <span class='neutral'>    }</span>
  184 |     | <span class='neutral'></span>
  185 |     | <span class='neutral'>    function log(address p0) internal view {</span>
  186 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address)&quot;, p0));</span>
  187 |     | <span class='neutral'>    }</span>
  188 |     | <span class='neutral'></span>
  189 |     | <span class='neutral'>    function log(uint p0, uint p1) internal view {</span>
  190 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,uint)&quot;, p0, p1));</span>
  191 |     | <span class='neutral'>    }</span>
  192 |     | <span class='neutral'></span>
  193 |     | <span class='neutral'>    function log(uint p0, string memory p1) internal view {</span>
  194 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,string)&quot;, p0, p1));</span>
  195 |     | <span class='neutral'>    }</span>
  196 |     | <span class='neutral'></span>
  197 |     | <span class='neutral'>    function log(uint p0, bool p1) internal view {</span>
  198 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,bool)&quot;, p0, p1));</span>
  199 |     | <span class='neutral'>    }</span>
  200 |     | <span class='neutral'></span>
  201 |     | <span class='neutral'>    function log(uint p0, address p1) internal view {</span>
  202 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,address)&quot;, p0, p1));</span>
  203 |     | <span class='neutral'>    }</span>
  204 |     | <span class='neutral'></span>
  205 |     | <span class='neutral'>    function log(string memory p0, uint p1) internal view {</span>
  206 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint)&quot;, p0, p1));</span>
  207 |     | <span class='neutral'>    }</span>
  208 |     | <span class='neutral'></span>
  209 |     | <span class='neutral'>    function log(string memory p0, string memory p1) internal view {</span>
  210 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string)&quot;, p0, p1));</span>
  211 |     | <span class='neutral'>    }</span>
  212 |     | <span class='neutral'></span>
  213 |     | <span class='neutral'>    function log(string memory p0, bool p1) internal view {</span>
  214 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool)&quot;, p0, p1));</span>
  215 |     | <span class='neutral'>    }</span>
  216 |     | <span class='neutral'></span>
  217 |     | <span class='neutral'>    function log(string memory p0, address p1) internal view {</span>
  218 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address)&quot;, p0, p1));</span>
  219 |     | <span class='neutral'>    }</span>
  220 |     | <span class='neutral'></span>
  221 |     | <span class='neutral'>    function log(bool p0, uint p1) internal view {</span>
  222 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint)&quot;, p0, p1));</span>
  223 |     | <span class='neutral'>    }</span>
  224 |     | <span class='neutral'></span>
  225 |     | <span class='neutral'>    function log(bool p0, string memory p1) internal view {</span>
  226 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string)&quot;, p0, p1));</span>
  227 |     | <span class='neutral'>    }</span>
  228 |     | <span class='neutral'></span>
  229 |     | <span class='neutral'>    function log(bool p0, bool p1) internal view {</span>
  230 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool)&quot;, p0, p1));</span>
  231 |     | <span class='neutral'>    }</span>
  232 |     | <span class='neutral'></span>
  233 |     | <span class='neutral'>    function log(bool p0, address p1) internal view {</span>
  234 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address)&quot;, p0, p1));</span>
  235 |     | <span class='neutral'>    }</span>
  236 |     | <span class='neutral'></span>
  237 |     | <span class='neutral'>    function log(address p0, uint p1) internal view {</span>
  238 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint)&quot;, p0, p1));</span>
  239 |     | <span class='neutral'>    }</span>
  240 |     | <span class='neutral'></span>
  241 |     | <span class='neutral'>    function log(address p0, string memory p1) internal view {</span>
  242 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string)&quot;, p0, p1));</span>
  243 |     | <span class='neutral'>    }</span>
  244 |     | <span class='neutral'></span>
  245 |     | <span class='neutral'>    function log(address p0, bool p1) internal view {</span>
  246 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool)&quot;, p0, p1));</span>
  247 |     | <span class='neutral'>    }</span>
  248 |     | <span class='neutral'></span>
  249 |     | <span class='neutral'>    function log(address p0, address p1) internal view {</span>
  250 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address)&quot;, p0, p1));</span>
  251 |     | <span class='neutral'>    }</span>
  252 |     | <span class='neutral'></span>
  253 |     | <span class='neutral'>    function log(uint p0, uint p1, uint p2) internal view {</span>
  254 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,uint,uint)&quot;, p0, p1, p2));</span>
  255 |     | <span class='neutral'>    }</span>
  256 |     | <span class='neutral'></span>
  257 |     | <span class='neutral'>    function log(uint p0, uint p1, string memory p2) internal view {</span>
  258 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,uint,string)&quot;, p0, p1, p2));</span>
  259 |     | <span class='neutral'>    }</span>
  260 |     | <span class='neutral'></span>
  261 |     | <span class='neutral'>    function log(uint p0, uint p1, bool p2) internal view {</span>
  262 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,uint,bool)&quot;, p0, p1, p2));</span>
  263 |     | <span class='neutral'>    }</span>
  264 |     | <span class='neutral'></span>
  265 |     | <span class='neutral'>    function log(uint p0, uint p1, address p2) internal view {</span>
  266 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,uint,address)&quot;, p0, p1, p2));</span>
  267 |     | <span class='neutral'>    }</span>
  268 |     | <span class='neutral'></span>
  269 |     | <span class='neutral'>    function log(uint p0, string memory p1, uint p2) internal view {</span>
  270 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,string,uint)&quot;, p0, p1, p2));</span>
  271 |     | <span class='neutral'>    }</span>
  272 |     | <span class='neutral'></span>
  273 |     | <span class='neutral'>    function log(uint p0, string memory p1, string memory p2) internal view {</span>
  274 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,string,string)&quot;, p0, p1, p2));</span>
  275 |     | <span class='neutral'>    }</span>
  276 |     | <span class='neutral'></span>
  277 |     | <span class='neutral'>    function log(uint p0, string memory p1, bool p2) internal view {</span>
  278 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,string,bool)&quot;, p0, p1, p2));</span>
  279 |     | <span class='neutral'>    }</span>
  280 |     | <span class='neutral'></span>
  281 |     | <span class='neutral'>    function log(uint p0, string memory p1, address p2) internal view {</span>
  282 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,string,address)&quot;, p0, p1, p2));</span>
  283 |     | <span class='neutral'>    }</span>
  284 |     | <span class='neutral'></span>
  285 |     | <span class='neutral'>    function log(uint p0, bool p1, uint p2) internal view {</span>
  286 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,bool,uint)&quot;, p0, p1, p2));</span>
  287 |     | <span class='neutral'>    }</span>
  288 |     | <span class='neutral'></span>
  289 |     | <span class='neutral'>    function log(uint p0, bool p1, string memory p2) internal view {</span>
  290 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,bool,string)&quot;, p0, p1, p2));</span>
  291 |     | <span class='neutral'>    }</span>
  292 |     | <span class='neutral'></span>
  293 |     | <span class='neutral'>    function log(uint p0, bool p1, bool p2) internal view {</span>
  294 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,bool,bool)&quot;, p0, p1, p2));</span>
  295 |     | <span class='neutral'>    }</span>
  296 |     | <span class='neutral'></span>
  297 |     | <span class='neutral'>    function log(uint p0, bool p1, address p2) internal view {</span>
  298 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,bool,address)&quot;, p0, p1, p2));</span>
  299 |     | <span class='neutral'>    }</span>
  300 |     | <span class='neutral'></span>
  301 |     | <span class='neutral'>    function log(uint p0, address p1, uint p2) internal view {</span>
  302 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,address,uint)&quot;, p0, p1, p2));</span>
  303 |     | <span class='neutral'>    }</span>
  304 |     | <span class='neutral'></span>
  305 |     | <span class='neutral'>    function log(uint p0, address p1, string memory p2) internal view {</span>
  306 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,address,string)&quot;, p0, p1, p2));</span>
  307 |     | <span class='neutral'>    }</span>
  308 |     | <span class='neutral'></span>
  309 |     | <span class='neutral'>    function log(uint p0, address p1, bool p2) internal view {</span>
  310 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,address,bool)&quot;, p0, p1, p2));</span>
  311 |     | <span class='neutral'>    }</span>
  312 |     | <span class='neutral'></span>
  313 |     | <span class='neutral'>    function log(uint p0, address p1, address p2) internal view {</span>
  314 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,address,address)&quot;, p0, p1, p2));</span>
  315 |     | <span class='neutral'>    }</span>
  316 |     | <span class='neutral'></span>
  317 |     | <span class='neutral'>    function log(string memory p0, uint p1, uint p2) internal view {</span>
  318 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint,uint)&quot;, p0, p1, p2));</span>
  319 |     | <span class='neutral'>    }</span>
  320 |     | <span class='neutral'></span>
  321 |     | <span class='neutral'>    function log(string memory p0, uint p1, string memory p2) internal view {</span>
  322 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint,string)&quot;, p0, p1, p2));</span>
  323 |     | <span class='neutral'>    }</span>
  324 |     | <span class='neutral'></span>
  325 |     | <span class='neutral'>    function log(string memory p0, uint p1, bool p2) internal view {</span>
  326 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint,bool)&quot;, p0, p1, p2));</span>
  327 |     | <span class='neutral'>    }</span>
  328 |     | <span class='neutral'></span>
  329 |     | <span class='neutral'>    function log(string memory p0, uint p1, address p2) internal view {</span>
  330 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint,address)&quot;, p0, p1, p2));</span>
  331 |     | <span class='neutral'>    }</span>
  332 |     | <span class='neutral'></span>
  333 |     | <span class='neutral'>    function log(string memory p0, string memory p1, uint p2) internal view {</span>
  334 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,uint)&quot;, p0, p1, p2));</span>
  335 |     | <span class='neutral'>    }</span>
  336 |     | <span class='neutral'></span>
  337 |     | <span class='neutral'>    function log(string memory p0, string memory p1, string memory p2) internal view {</span>
  338 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,string)&quot;, p0, p1, p2));</span>
  339 |     | <span class='neutral'>    }</span>
  340 |     | <span class='neutral'></span>
  341 |     | <span class='neutral'>    function log(string memory p0, string memory p1, bool p2) internal view {</span>
  342 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,bool)&quot;, p0, p1, p2));</span>
  343 |     | <span class='neutral'>    }</span>
  344 |     | <span class='neutral'></span>
  345 |     | <span class='neutral'>    function log(string memory p0, string memory p1, address p2) internal view {</span>
  346 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,address)&quot;, p0, p1, p2));</span>
  347 |     | <span class='neutral'>    }</span>
  348 |     | <span class='neutral'></span>
  349 |     | <span class='neutral'>    function log(string memory p0, bool p1, uint p2) internal view {</span>
  350 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,uint)&quot;, p0, p1, p2));</span>
  351 |     | <span class='neutral'>    }</span>
  352 |     | <span class='neutral'></span>
  353 |     | <span class='neutral'>    function log(string memory p0, bool p1, string memory p2) internal view {</span>
  354 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,string)&quot;, p0, p1, p2));</span>
  355 |     | <span class='neutral'>    }</span>
  356 |     | <span class='neutral'></span>
  357 |     | <span class='neutral'>    function log(string memory p0, bool p1, bool p2) internal view {</span>
  358 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,bool)&quot;, p0, p1, p2));</span>
  359 |     | <span class='neutral'>    }</span>
  360 |     | <span class='neutral'></span>
  361 |     | <span class='neutral'>    function log(string memory p0, bool p1, address p2) internal view {</span>
  362 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,address)&quot;, p0, p1, p2));</span>
  363 |     | <span class='neutral'>    }</span>
  364 |     | <span class='neutral'></span>
  365 |     | <span class='neutral'>    function log(string memory p0, address p1, uint p2) internal view {</span>
  366 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,uint)&quot;, p0, p1, p2));</span>
  367 |     | <span class='neutral'>    }</span>
  368 |     | <span class='neutral'></span>
  369 |     | <span class='neutral'>    function log(string memory p0, address p1, string memory p2) internal view {</span>
  370 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,string)&quot;, p0, p1, p2));</span>
  371 |     | <span class='neutral'>    }</span>
  372 |     | <span class='neutral'></span>
  373 |     | <span class='neutral'>    function log(string memory p0, address p1, bool p2) internal view {</span>
  374 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,bool)&quot;, p0, p1, p2));</span>
  375 |     | <span class='neutral'>    }</span>
  376 |     | <span class='neutral'></span>
  377 |     | <span class='neutral'>    function log(string memory p0, address p1, address p2) internal view {</span>
  378 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,address)&quot;, p0, p1, p2));</span>
  379 |     | <span class='neutral'>    }</span>
  380 |     | <span class='neutral'></span>
  381 |     | <span class='neutral'>    function log(bool p0, uint p1, uint p2) internal view {</span>
  382 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint,uint)&quot;, p0, p1, p2));</span>
  383 |     | <span class='neutral'>    }</span>
  384 |     | <span class='neutral'></span>
  385 |     | <span class='neutral'>    function log(bool p0, uint p1, string memory p2) internal view {</span>
  386 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint,string)&quot;, p0, p1, p2));</span>
  387 |     | <span class='neutral'>    }</span>
  388 |     | <span class='neutral'></span>
  389 |     | <span class='neutral'>    function log(bool p0, uint p1, bool p2) internal view {</span>
  390 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint,bool)&quot;, p0, p1, p2));</span>
  391 |     | <span class='neutral'>    }</span>
  392 |     | <span class='neutral'></span>
  393 |     | <span class='neutral'>    function log(bool p0, uint p1, address p2) internal view {</span>
  394 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint,address)&quot;, p0, p1, p2));</span>
  395 |     | <span class='neutral'>    }</span>
  396 |     | <span class='neutral'></span>
  397 |     | <span class='neutral'>    function log(bool p0, string memory p1, uint p2) internal view {</span>
  398 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,uint)&quot;, p0, p1, p2));</span>
  399 |     | <span class='neutral'>    }</span>
  400 |     | <span class='neutral'></span>
  401 |     | <span class='neutral'>    function log(bool p0, string memory p1, string memory p2) internal view {</span>
  402 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,string)&quot;, p0, p1, p2));</span>
  403 |     | <span class='neutral'>    }</span>
  404 |     | <span class='neutral'></span>
  405 |     | <span class='neutral'>    function log(bool p0, string memory p1, bool p2) internal view {</span>
  406 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,bool)&quot;, p0, p1, p2));</span>
  407 |     | <span class='neutral'>    }</span>
  408 |     | <span class='neutral'></span>
  409 |     | <span class='neutral'>    function log(bool p0, string memory p1, address p2) internal view {</span>
  410 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,address)&quot;, p0, p1, p2));</span>
  411 |     | <span class='neutral'>    }</span>
  412 |     | <span class='neutral'></span>
  413 |     | <span class='neutral'>    function log(bool p0, bool p1, uint p2) internal view {</span>
  414 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,uint)&quot;, p0, p1, p2));</span>
  415 |     | <span class='neutral'>    }</span>
  416 |     | <span class='neutral'></span>
  417 |     | <span class='neutral'>    function log(bool p0, bool p1, string memory p2) internal view {</span>
  418 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,string)&quot;, p0, p1, p2));</span>
  419 |     | <span class='neutral'>    }</span>
  420 |     | <span class='neutral'></span>
  421 |     | <span class='neutral'>    function log(bool p0, bool p1, bool p2) internal view {</span>
  422 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,bool)&quot;, p0, p1, p2));</span>
  423 |     | <span class='neutral'>    }</span>
  424 |     | <span class='neutral'></span>
  425 |     | <span class='neutral'>    function log(bool p0, bool p1, address p2) internal view {</span>
  426 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,address)&quot;, p0, p1, p2));</span>
  427 |     | <span class='neutral'>    }</span>
  428 |     | <span class='neutral'></span>
  429 |     | <span class='neutral'>    function log(bool p0, address p1, uint p2) internal view {</span>
  430 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,uint)&quot;, p0, p1, p2));</span>
  431 |     | <span class='neutral'>    }</span>
  432 |     | <span class='neutral'></span>
  433 |     | <span class='neutral'>    function log(bool p0, address p1, string memory p2) internal view {</span>
  434 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,string)&quot;, p0, p1, p2));</span>
  435 |     | <span class='neutral'>    }</span>
  436 |     | <span class='neutral'></span>
  437 |     | <span class='neutral'>    function log(bool p0, address p1, bool p2) internal view {</span>
  438 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,bool)&quot;, p0, p1, p2));</span>
  439 |     | <span class='neutral'>    }</span>
  440 |     | <span class='neutral'></span>
  441 |     | <span class='neutral'>    function log(bool p0, address p1, address p2) internal view {</span>
  442 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,address)&quot;, p0, p1, p2));</span>
  443 |     | <span class='neutral'>    }</span>
  444 |     | <span class='neutral'></span>
  445 |     | <span class='neutral'>    function log(address p0, uint p1, uint p2) internal view {</span>
  446 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint,uint)&quot;, p0, p1, p2));</span>
  447 |     | <span class='neutral'>    }</span>
  448 |     | <span class='neutral'></span>
  449 |     | <span class='neutral'>    function log(address p0, uint p1, string memory p2) internal view {</span>
  450 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint,string)&quot;, p0, p1, p2));</span>
  451 |     | <span class='neutral'>    }</span>
  452 |     | <span class='neutral'></span>
  453 |     | <span class='neutral'>    function log(address p0, uint p1, bool p2) internal view {</span>
  454 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint,bool)&quot;, p0, p1, p2));</span>
  455 |     | <span class='neutral'>    }</span>
  456 |     | <span class='neutral'></span>
  457 |     | <span class='neutral'>    function log(address p0, uint p1, address p2) internal view {</span>
  458 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint,address)&quot;, p0, p1, p2));</span>
  459 |     | <span class='neutral'>    }</span>
  460 |     | <span class='neutral'></span>
  461 |     | <span class='neutral'>    function log(address p0, string memory p1, uint p2) internal view {</span>
  462 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,uint)&quot;, p0, p1, p2));</span>
  463 |     | <span class='neutral'>    }</span>
  464 |     | <span class='neutral'></span>
  465 |     | <span class='neutral'>    function log(address p0, string memory p1, string memory p2) internal view {</span>
  466 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,string)&quot;, p0, p1, p2));</span>
  467 |     | <span class='neutral'>    }</span>
  468 |     | <span class='neutral'></span>
  469 |     | <span class='neutral'>    function log(address p0, string memory p1, bool p2) internal view {</span>
  470 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,bool)&quot;, p0, p1, p2));</span>
  471 |     | <span class='neutral'>    }</span>
  472 |     | <span class='neutral'></span>
  473 |     | <span class='neutral'>    function log(address p0, string memory p1, address p2) internal view {</span>
  474 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,address)&quot;, p0, p1, p2));</span>
  475 |     | <span class='neutral'>    }</span>
  476 |     | <span class='neutral'></span>
  477 |     | <span class='neutral'>    function log(address p0, bool p1, uint p2) internal view {</span>
  478 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,uint)&quot;, p0, p1, p2));</span>
  479 |     | <span class='neutral'>    }</span>
  480 |     | <span class='neutral'></span>
  481 |     | <span class='neutral'>    function log(address p0, bool p1, string memory p2) internal view {</span>
  482 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,string)&quot;, p0, p1, p2));</span>
  483 |     | <span class='neutral'>    }</span>
  484 |     | <span class='neutral'></span>
  485 |     | <span class='neutral'>    function log(address p0, bool p1, bool p2) internal view {</span>
  486 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,bool)&quot;, p0, p1, p2));</span>
  487 |     | <span class='neutral'>    }</span>
  488 |     | <span class='neutral'></span>
  489 |     | <span class='neutral'>    function log(address p0, bool p1, address p2) internal view {</span>
  490 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,address)&quot;, p0, p1, p2));</span>
  491 |     | <span class='neutral'>    }</span>
  492 |     | <span class='neutral'></span>
  493 |     | <span class='neutral'>    function log(address p0, address p1, uint p2) internal view {</span>
  494 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,uint)&quot;, p0, p1, p2));</span>
  495 |     | <span class='neutral'>    }</span>
  496 |     | <span class='neutral'></span>
  497 |     | <span class='neutral'>    function log(address p0, address p1, string memory p2) internal view {</span>
  498 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,string)&quot;, p0, p1, p2));</span>
  499 |     | <span class='neutral'>    }</span>
  500 |     | <span class='neutral'></span>
  501 |     | <span class='neutral'>    function log(address p0, address p1, bool p2) internal view {</span>
  502 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,bool)&quot;, p0, p1, p2));</span>
  503 |     | <span class='neutral'>    }</span>
  504 |     | <span class='neutral'></span>
  505 |     | <span class='neutral'>    function log(address p0, address p1, address p2) internal view {</span>
  506 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,address)&quot;, p0, p1, p2));</span>
  507 |     | <span class='neutral'>    }</span>
  508 |     | <span class='neutral'></span>
  509 |     | <span class='neutral'>    function log(uint p0, uint p1, uint p2, uint p3) internal view {</span>
  510 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,uint,uint,uint)&quot;, p0, p1, p2, p3));</span>
  511 |     | <span class='neutral'>    }</span>
  512 |     | <span class='neutral'></span>
  513 |     | <span class='neutral'>    function log(uint p0, uint p1, uint p2, string memory p3) internal view {</span>
  514 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,uint,uint,string)&quot;, p0, p1, p2, p3));</span>
  515 |     | <span class='neutral'>    }</span>
  516 |     | <span class='neutral'></span>
  517 |     | <span class='neutral'>    function log(uint p0, uint p1, uint p2, bool p3) internal view {</span>
  518 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,uint,uint,bool)&quot;, p0, p1, p2, p3));</span>
  519 |     | <span class='neutral'>    }</span>
  520 |     | <span class='neutral'></span>
  521 |     | <span class='neutral'>    function log(uint p0, uint p1, uint p2, address p3) internal view {</span>
  522 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,uint,uint,address)&quot;, p0, p1, p2, p3));</span>
  523 |     | <span class='neutral'>    }</span>
  524 |     | <span class='neutral'></span>
  525 |     | <span class='neutral'>    function log(uint p0, uint p1, string memory p2, uint p3) internal view {</span>
  526 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,uint,string,uint)&quot;, p0, p1, p2, p3));</span>
  527 |     | <span class='neutral'>    }</span>
  528 |     | <span class='neutral'></span>
  529 |     | <span class='neutral'>    function log(uint p0, uint p1, string memory p2, string memory p3) internal view {</span>
  530 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,uint,string,string)&quot;, p0, p1, p2, p3));</span>
  531 |     | <span class='neutral'>    }</span>
  532 |     | <span class='neutral'></span>
  533 |     | <span class='neutral'>    function log(uint p0, uint p1, string memory p2, bool p3) internal view {</span>
  534 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,uint,string,bool)&quot;, p0, p1, p2, p3));</span>
  535 |     | <span class='neutral'>    }</span>
  536 |     | <span class='neutral'></span>
  537 |     | <span class='neutral'>    function log(uint p0, uint p1, string memory p2, address p3) internal view {</span>
  538 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,uint,string,address)&quot;, p0, p1, p2, p3));</span>
  539 |     | <span class='neutral'>    }</span>
  540 |     | <span class='neutral'></span>
  541 |     | <span class='neutral'>    function log(uint p0, uint p1, bool p2, uint p3) internal view {</span>
  542 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,uint,bool,uint)&quot;, p0, p1, p2, p3));</span>
  543 |     | <span class='neutral'>    }</span>
  544 |     | <span class='neutral'></span>
  545 |     | <span class='neutral'>    function log(uint p0, uint p1, bool p2, string memory p3) internal view {</span>
  546 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,uint,bool,string)&quot;, p0, p1, p2, p3));</span>
  547 |     | <span class='neutral'>    }</span>
  548 |     | <span class='neutral'></span>
  549 |     | <span class='neutral'>    function log(uint p0, uint p1, bool p2, bool p3) internal view {</span>
  550 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,uint,bool,bool)&quot;, p0, p1, p2, p3));</span>
  551 |     | <span class='neutral'>    }</span>
  552 |     | <span class='neutral'></span>
  553 |     | <span class='neutral'>    function log(uint p0, uint p1, bool p2, address p3) internal view {</span>
  554 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,uint,bool,address)&quot;, p0, p1, p2, p3));</span>
  555 |     | <span class='neutral'>    }</span>
  556 |     | <span class='neutral'></span>
  557 |     | <span class='neutral'>    function log(uint p0, uint p1, address p2, uint p3) internal view {</span>
  558 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,uint,address,uint)&quot;, p0, p1, p2, p3));</span>
  559 |     | <span class='neutral'>    }</span>
  560 |     | <span class='neutral'></span>
  561 |     | <span class='neutral'>    function log(uint p0, uint p1, address p2, string memory p3) internal view {</span>
  562 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,uint,address,string)&quot;, p0, p1, p2, p3));</span>
  563 |     | <span class='neutral'>    }</span>
  564 |     | <span class='neutral'></span>
  565 |     | <span class='neutral'>    function log(uint p0, uint p1, address p2, bool p3) internal view {</span>
  566 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,uint,address,bool)&quot;, p0, p1, p2, p3));</span>
  567 |     | <span class='neutral'>    }</span>
  568 |     | <span class='neutral'></span>
  569 |     | <span class='neutral'>    function log(uint p0, uint p1, address p2, address p3) internal view {</span>
  570 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,uint,address,address)&quot;, p0, p1, p2, p3));</span>
  571 |     | <span class='neutral'>    }</span>
  572 |     | <span class='neutral'></span>
  573 |     | <span class='neutral'>    function log(uint p0, string memory p1, uint p2, uint p3) internal view {</span>
  574 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,string,uint,uint)&quot;, p0, p1, p2, p3));</span>
  575 |     | <span class='neutral'>    }</span>
  576 |     | <span class='neutral'></span>
  577 |     | <span class='neutral'>    function log(uint p0, string memory p1, uint p2, string memory p3) internal view {</span>
  578 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,string,uint,string)&quot;, p0, p1, p2, p3));</span>
  579 |     | <span class='neutral'>    }</span>
  580 |     | <span class='neutral'></span>
  581 |     | <span class='neutral'>    function log(uint p0, string memory p1, uint p2, bool p3) internal view {</span>
  582 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,string,uint,bool)&quot;, p0, p1, p2, p3));</span>
  583 |     | <span class='neutral'>    }</span>
  584 |     | <span class='neutral'></span>
  585 |     | <span class='neutral'>    function log(uint p0, string memory p1, uint p2, address p3) internal view {</span>
  586 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,string,uint,address)&quot;, p0, p1, p2, p3));</span>
  587 |     | <span class='neutral'>    }</span>
  588 |     | <span class='neutral'></span>
  589 |     | <span class='neutral'>    function log(uint p0, string memory p1, string memory p2, uint p3) internal view {</span>
  590 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,string,string,uint)&quot;, p0, p1, p2, p3));</span>
  591 |     | <span class='neutral'>    }</span>
  592 |     | <span class='neutral'></span>
  593 |     | <span class='neutral'>    function log(uint p0, string memory p1, string memory p2, string memory p3) internal view {</span>
  594 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,string,string,string)&quot;, p0, p1, p2, p3));</span>
  595 |     | <span class='neutral'>    }</span>
  596 |     | <span class='neutral'></span>
  597 |     | <span class='neutral'>    function log(uint p0, string memory p1, string memory p2, bool p3) internal view {</span>
  598 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,string,string,bool)&quot;, p0, p1, p2, p3));</span>
  599 |     | <span class='neutral'>    }</span>
  600 |     | <span class='neutral'></span>
  601 |     | <span class='neutral'>    function log(uint p0, string memory p1, string memory p2, address p3) internal view {</span>
  602 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,string,string,address)&quot;, p0, p1, p2, p3));</span>
  603 |     | <span class='neutral'>    }</span>
  604 |     | <span class='neutral'></span>
  605 |     | <span class='neutral'>    function log(uint p0, string memory p1, bool p2, uint p3) internal view {</span>
  606 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,string,bool,uint)&quot;, p0, p1, p2, p3));</span>
  607 |     | <span class='neutral'>    }</span>
  608 |     | <span class='neutral'></span>
  609 |     | <span class='neutral'>    function log(uint p0, string memory p1, bool p2, string memory p3) internal view {</span>
  610 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,string,bool,string)&quot;, p0, p1, p2, p3));</span>
  611 |     | <span class='neutral'>    }</span>
  612 |     | <span class='neutral'></span>
  613 |     | <span class='neutral'>    function log(uint p0, string memory p1, bool p2, bool p3) internal view {</span>
  614 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,string,bool,bool)&quot;, p0, p1, p2, p3));</span>
  615 |     | <span class='neutral'>    }</span>
  616 |     | <span class='neutral'></span>
  617 |     | <span class='neutral'>    function log(uint p0, string memory p1, bool p2, address p3) internal view {</span>
  618 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,string,bool,address)&quot;, p0, p1, p2, p3));</span>
  619 |     | <span class='neutral'>    }</span>
  620 |     | <span class='neutral'></span>
  621 |     | <span class='neutral'>    function log(uint p0, string memory p1, address p2, uint p3) internal view {</span>
  622 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,string,address,uint)&quot;, p0, p1, p2, p3));</span>
  623 |     | <span class='neutral'>    }</span>
  624 |     | <span class='neutral'></span>
  625 |     | <span class='neutral'>    function log(uint p0, string memory p1, address p2, string memory p3) internal view {</span>
  626 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,string,address,string)&quot;, p0, p1, p2, p3));</span>
  627 |     | <span class='neutral'>    }</span>
  628 |     | <span class='neutral'></span>
  629 |     | <span class='neutral'>    function log(uint p0, string memory p1, address p2, bool p3) internal view {</span>
  630 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,string,address,bool)&quot;, p0, p1, p2, p3));</span>
  631 |     | <span class='neutral'>    }</span>
  632 |     | <span class='neutral'></span>
  633 |     | <span class='neutral'>    function log(uint p0, string memory p1, address p2, address p3) internal view {</span>
  634 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,string,address,address)&quot;, p0, p1, p2, p3));</span>
  635 |     | <span class='neutral'>    }</span>
  636 |     | <span class='neutral'></span>
  637 |     | <span class='neutral'>    function log(uint p0, bool p1, uint p2, uint p3) internal view {</span>
  638 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,bool,uint,uint)&quot;, p0, p1, p2, p3));</span>
  639 |     | <span class='neutral'>    }</span>
  640 |     | <span class='neutral'></span>
  641 |     | <span class='neutral'>    function log(uint p0, bool p1, uint p2, string memory p3) internal view {</span>
  642 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,bool,uint,string)&quot;, p0, p1, p2, p3));</span>
  643 |     | <span class='neutral'>    }</span>
  644 |     | <span class='neutral'></span>
  645 |     | <span class='neutral'>    function log(uint p0, bool p1, uint p2, bool p3) internal view {</span>
  646 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,bool,uint,bool)&quot;, p0, p1, p2, p3));</span>
  647 |     | <span class='neutral'>    }</span>
  648 |     | <span class='neutral'></span>
  649 |     | <span class='neutral'>    function log(uint p0, bool p1, uint p2, address p3) internal view {</span>
  650 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,bool,uint,address)&quot;, p0, p1, p2, p3));</span>
  651 |     | <span class='neutral'>    }</span>
  652 |     | <span class='neutral'></span>
  653 |     | <span class='neutral'>    function log(uint p0, bool p1, string memory p2, uint p3) internal view {</span>
  654 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,bool,string,uint)&quot;, p0, p1, p2, p3));</span>
  655 |     | <span class='neutral'>    }</span>
  656 |     | <span class='neutral'></span>
  657 |     | <span class='neutral'>    function log(uint p0, bool p1, string memory p2, string memory p3) internal view {</span>
  658 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,bool,string,string)&quot;, p0, p1, p2, p3));</span>
  659 |     | <span class='neutral'>    }</span>
  660 |     | <span class='neutral'></span>
  661 |     | <span class='neutral'>    function log(uint p0, bool p1, string memory p2, bool p3) internal view {</span>
  662 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,bool,string,bool)&quot;, p0, p1, p2, p3));</span>
  663 |     | <span class='neutral'>    }</span>
  664 |     | <span class='neutral'></span>
  665 |     | <span class='neutral'>    function log(uint p0, bool p1, string memory p2, address p3) internal view {</span>
  666 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,bool,string,address)&quot;, p0, p1, p2, p3));</span>
  667 |     | <span class='neutral'>    }</span>
  668 |     | <span class='neutral'></span>
  669 |     | <span class='neutral'>    function log(uint p0, bool p1, bool p2, uint p3) internal view {</span>
  670 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,bool,bool,uint)&quot;, p0, p1, p2, p3));</span>
  671 |     | <span class='neutral'>    }</span>
  672 |     | <span class='neutral'></span>
  673 |     | <span class='neutral'>    function log(uint p0, bool p1, bool p2, string memory p3) internal view {</span>
  674 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,bool,bool,string)&quot;, p0, p1, p2, p3));</span>
  675 |     | <span class='neutral'>    }</span>
  676 |     | <span class='neutral'></span>
  677 |     | <span class='neutral'>    function log(uint p0, bool p1, bool p2, bool p3) internal view {</span>
  678 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,bool,bool,bool)&quot;, p0, p1, p2, p3));</span>
  679 |     | <span class='neutral'>    }</span>
  680 |     | <span class='neutral'></span>
  681 |     | <span class='neutral'>    function log(uint p0, bool p1, bool p2, address p3) internal view {</span>
  682 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,bool,bool,address)&quot;, p0, p1, p2, p3));</span>
  683 |     | <span class='neutral'>    }</span>
  684 |     | <span class='neutral'></span>
  685 |     | <span class='neutral'>    function log(uint p0, bool p1, address p2, uint p3) internal view {</span>
  686 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,bool,address,uint)&quot;, p0, p1, p2, p3));</span>
  687 |     | <span class='neutral'>    }</span>
  688 |     | <span class='neutral'></span>
  689 |     | <span class='neutral'>    function log(uint p0, bool p1, address p2, string memory p3) internal view {</span>
  690 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,bool,address,string)&quot;, p0, p1, p2, p3));</span>
  691 |     | <span class='neutral'>    }</span>
  692 |     | <span class='neutral'></span>
  693 |     | <span class='neutral'>    function log(uint p0, bool p1, address p2, bool p3) internal view {</span>
  694 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,bool,address,bool)&quot;, p0, p1, p2, p3));</span>
  695 |     | <span class='neutral'>    }</span>
  696 |     | <span class='neutral'></span>
  697 |     | <span class='neutral'>    function log(uint p0, bool p1, address p2, address p3) internal view {</span>
  698 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,bool,address,address)&quot;, p0, p1, p2, p3));</span>
  699 |     | <span class='neutral'>    }</span>
  700 |     | <span class='neutral'></span>
  701 |     | <span class='neutral'>    function log(uint p0, address p1, uint p2, uint p3) internal view {</span>
  702 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,address,uint,uint)&quot;, p0, p1, p2, p3));</span>
  703 |     | <span class='neutral'>    }</span>
  704 |     | <span class='neutral'></span>
  705 |     | <span class='neutral'>    function log(uint p0, address p1, uint p2, string memory p3) internal view {</span>
  706 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,address,uint,string)&quot;, p0, p1, p2, p3));</span>
  707 |     | <span class='neutral'>    }</span>
  708 |     | <span class='neutral'></span>
  709 |     | <span class='neutral'>    function log(uint p0, address p1, uint p2, bool p3) internal view {</span>
  710 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,address,uint,bool)&quot;, p0, p1, p2, p3));</span>
  711 |     | <span class='neutral'>    }</span>
  712 |     | <span class='neutral'></span>
  713 |     | <span class='neutral'>    function log(uint p0, address p1, uint p2, address p3) internal view {</span>
  714 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,address,uint,address)&quot;, p0, p1, p2, p3));</span>
  715 |     | <span class='neutral'>    }</span>
  716 |     | <span class='neutral'></span>
  717 |     | <span class='neutral'>    function log(uint p0, address p1, string memory p2, uint p3) internal view {</span>
  718 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,address,string,uint)&quot;, p0, p1, p2, p3));</span>
  719 |     | <span class='neutral'>    }</span>
  720 |     | <span class='neutral'></span>
  721 |     | <span class='neutral'>    function log(uint p0, address p1, string memory p2, string memory p3) internal view {</span>
  722 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,address,string,string)&quot;, p0, p1, p2, p3));</span>
  723 |     | <span class='neutral'>    }</span>
  724 |     | <span class='neutral'></span>
  725 |     | <span class='neutral'>    function log(uint p0, address p1, string memory p2, bool p3) internal view {</span>
  726 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,address,string,bool)&quot;, p0, p1, p2, p3));</span>
  727 |     | <span class='neutral'>    }</span>
  728 |     | <span class='neutral'></span>
  729 |     | <span class='neutral'>    function log(uint p0, address p1, string memory p2, address p3) internal view {</span>
  730 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,address,string,address)&quot;, p0, p1, p2, p3));</span>
  731 |     | <span class='neutral'>    }</span>
  732 |     | <span class='neutral'></span>
  733 |     | <span class='neutral'>    function log(uint p0, address p1, bool p2, uint p3) internal view {</span>
  734 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,address,bool,uint)&quot;, p0, p1, p2, p3));</span>
  735 |     | <span class='neutral'>    }</span>
  736 |     | <span class='neutral'></span>
  737 |     | <span class='neutral'>    function log(uint p0, address p1, bool p2, string memory p3) internal view {</span>
  738 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,address,bool,string)&quot;, p0, p1, p2, p3));</span>
  739 |     | <span class='neutral'>    }</span>
  740 |     | <span class='neutral'></span>
  741 |     | <span class='neutral'>    function log(uint p0, address p1, bool p2, bool p3) internal view {</span>
  742 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,address,bool,bool)&quot;, p0, p1, p2, p3));</span>
  743 |     | <span class='neutral'>    }</span>
  744 |     | <span class='neutral'></span>
  745 |     | <span class='neutral'>    function log(uint p0, address p1, bool p2, address p3) internal view {</span>
  746 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,address,bool,address)&quot;, p0, p1, p2, p3));</span>
  747 |     | <span class='neutral'>    }</span>
  748 |     | <span class='neutral'></span>
  749 |     | <span class='neutral'>    function log(uint p0, address p1, address p2, uint p3) internal view {</span>
  750 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,address,address,uint)&quot;, p0, p1, p2, p3));</span>
  751 |     | <span class='neutral'>    }</span>
  752 |     | <span class='neutral'></span>
  753 |     | <span class='neutral'>    function log(uint p0, address p1, address p2, string memory p3) internal view {</span>
  754 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,address,address,string)&quot;, p0, p1, p2, p3));</span>
  755 |     | <span class='neutral'>    }</span>
  756 |     | <span class='neutral'></span>
  757 |     | <span class='neutral'>    function log(uint p0, address p1, address p2, bool p3) internal view {</span>
  758 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,address,address,bool)&quot;, p0, p1, p2, p3));</span>
  759 |     | <span class='neutral'>    }</span>
  760 |     | <span class='neutral'></span>
  761 |     | <span class='neutral'>    function log(uint p0, address p1, address p2, address p3) internal view {</span>
  762 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,address,address,address)&quot;, p0, p1, p2, p3));</span>
  763 |     | <span class='neutral'>    }</span>
  764 |     | <span class='neutral'></span>
  765 |     | <span class='neutral'>    function log(string memory p0, uint p1, uint p2, uint p3) internal view {</span>
  766 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint,uint,uint)&quot;, p0, p1, p2, p3));</span>
  767 |     | <span class='neutral'>    }</span>
  768 |     | <span class='neutral'></span>
  769 |     | <span class='neutral'>    function log(string memory p0, uint p1, uint p2, string memory p3) internal view {</span>
  770 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint,uint,string)&quot;, p0, p1, p2, p3));</span>
  771 |     | <span class='neutral'>    }</span>
  772 |     | <span class='neutral'></span>
  773 |     | <span class='neutral'>    function log(string memory p0, uint p1, uint p2, bool p3) internal view {</span>
  774 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint,uint,bool)&quot;, p0, p1, p2, p3));</span>
  775 |     | <span class='neutral'>    }</span>
  776 |     | <span class='neutral'></span>
  777 |     | <span class='neutral'>    function log(string memory p0, uint p1, uint p2, address p3) internal view {</span>
  778 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint,uint,address)&quot;, p0, p1, p2, p3));</span>
  779 |     | <span class='neutral'>    }</span>
  780 |     | <span class='neutral'></span>
  781 |     | <span class='neutral'>    function log(string memory p0, uint p1, string memory p2, uint p3) internal view {</span>
  782 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint,string,uint)&quot;, p0, p1, p2, p3));</span>
  783 |     | <span class='neutral'>    }</span>
  784 |     | <span class='neutral'></span>
  785 |     | <span class='neutral'>    function log(string memory p0, uint p1, string memory p2, string memory p3) internal view {</span>
  786 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint,string,string)&quot;, p0, p1, p2, p3));</span>
  787 |     | <span class='neutral'>    }</span>
  788 |     | <span class='neutral'></span>
  789 |     | <span class='neutral'>    function log(string memory p0, uint p1, string memory p2, bool p3) internal view {</span>
  790 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint,string,bool)&quot;, p0, p1, p2, p3));</span>
  791 |     | <span class='neutral'>    }</span>
  792 |     | <span class='neutral'></span>
  793 |     | <span class='neutral'>    function log(string memory p0, uint p1, string memory p2, address p3) internal view {</span>
  794 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint,string,address)&quot;, p0, p1, p2, p3));</span>
  795 |     | <span class='neutral'>    }</span>
  796 |     | <span class='neutral'></span>
  797 |     | <span class='neutral'>    function log(string memory p0, uint p1, bool p2, uint p3) internal view {</span>
  798 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint,bool,uint)&quot;, p0, p1, p2, p3));</span>
  799 |     | <span class='neutral'>    }</span>
  800 |     | <span class='neutral'></span>
  801 |     | <span class='neutral'>    function log(string memory p0, uint p1, bool p2, string memory p3) internal view {</span>
  802 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint,bool,string)&quot;, p0, p1, p2, p3));</span>
  803 |     | <span class='neutral'>    }</span>
  804 |     | <span class='neutral'></span>
  805 |     | <span class='neutral'>    function log(string memory p0, uint p1, bool p2, bool p3) internal view {</span>
  806 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint,bool,bool)&quot;, p0, p1, p2, p3));</span>
  807 |     | <span class='neutral'>    }</span>
  808 |     | <span class='neutral'></span>
  809 |     | <span class='neutral'>    function log(string memory p0, uint p1, bool p2, address p3) internal view {</span>
  810 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint,bool,address)&quot;, p0, p1, p2, p3));</span>
  811 |     | <span class='neutral'>    }</span>
  812 |     | <span class='neutral'></span>
  813 |     | <span class='neutral'>    function log(string memory p0, uint p1, address p2, uint p3) internal view {</span>
  814 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint,address,uint)&quot;, p0, p1, p2, p3));</span>
  815 |     | <span class='neutral'>    }</span>
  816 |     | <span class='neutral'></span>
  817 |     | <span class='neutral'>    function log(string memory p0, uint p1, address p2, string memory p3) internal view {</span>
  818 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint,address,string)&quot;, p0, p1, p2, p3));</span>
  819 |     | <span class='neutral'>    }</span>
  820 |     | <span class='neutral'></span>
  821 |     | <span class='neutral'>    function log(string memory p0, uint p1, address p2, bool p3) internal view {</span>
  822 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint,address,bool)&quot;, p0, p1, p2, p3));</span>
  823 |     | <span class='neutral'>    }</span>
  824 |     | <span class='neutral'></span>
  825 |     | <span class='neutral'>    function log(string memory p0, uint p1, address p2, address p3) internal view {</span>
  826 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint,address,address)&quot;, p0, p1, p2, p3));</span>
  827 |     | <span class='neutral'>    }</span>
  828 |     | <span class='neutral'></span>
  829 |     | <span class='neutral'>    function log(string memory p0, string memory p1, uint p2, uint p3) internal view {</span>
  830 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,uint,uint)&quot;, p0, p1, p2, p3));</span>
  831 |     | <span class='neutral'>    }</span>
  832 |     | <span class='neutral'></span>
  833 |     | <span class='neutral'>    function log(string memory p0, string memory p1, uint p2, string memory p3) internal view {</span>
  834 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,uint,string)&quot;, p0, p1, p2, p3));</span>
  835 |     | <span class='neutral'>    }</span>
  836 |     | <span class='neutral'></span>
  837 |     | <span class='neutral'>    function log(string memory p0, string memory p1, uint p2, bool p3) internal view {</span>
  838 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,uint,bool)&quot;, p0, p1, p2, p3));</span>
  839 |     | <span class='neutral'>    }</span>
  840 |     | <span class='neutral'></span>
  841 |     | <span class='neutral'>    function log(string memory p0, string memory p1, uint p2, address p3) internal view {</span>
  842 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,uint,address)&quot;, p0, p1, p2, p3));</span>
  843 |     | <span class='neutral'>    }</span>
  844 |     | <span class='neutral'></span>
  845 |     | <span class='neutral'>    function log(string memory p0, string memory p1, string memory p2, uint p3) internal view {</span>
  846 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,string,uint)&quot;, p0, p1, p2, p3));</span>
  847 |     | <span class='neutral'>    }</span>
  848 |     | <span class='neutral'></span>
  849 |     | <span class='neutral'>    function log(string memory p0, string memory p1, string memory p2, string memory p3) internal view {</span>
  850 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,string,string)&quot;, p0, p1, p2, p3));</span>
  851 |     | <span class='neutral'>    }</span>
  852 |     | <span class='neutral'></span>
  853 |     | <span class='neutral'>    function log(string memory p0, string memory p1, string memory p2, bool p3) internal view {</span>
  854 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,string,bool)&quot;, p0, p1, p2, p3));</span>
  855 |     | <span class='neutral'>    }</span>
  856 |     | <span class='neutral'></span>
  857 |     | <span class='neutral'>    function log(string memory p0, string memory p1, string memory p2, address p3) internal view {</span>
  858 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,string,address)&quot;, p0, p1, p2, p3));</span>
  859 |     | <span class='neutral'>    }</span>
  860 |     | <span class='neutral'></span>
  861 |     | <span class='neutral'>    function log(string memory p0, string memory p1, bool p2, uint p3) internal view {</span>
  862 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,bool,uint)&quot;, p0, p1, p2, p3));</span>
  863 |     | <span class='neutral'>    }</span>
  864 |     | <span class='neutral'></span>
  865 |     | <span class='neutral'>    function log(string memory p0, string memory p1, bool p2, string memory p3) internal view {</span>
  866 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,bool,string)&quot;, p0, p1, p2, p3));</span>
  867 |     | <span class='neutral'>    }</span>
  868 |     | <span class='neutral'></span>
  869 |     | <span class='neutral'>    function log(string memory p0, string memory p1, bool p2, bool p3) internal view {</span>
  870 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,bool,bool)&quot;, p0, p1, p2, p3));</span>
  871 |     | <span class='neutral'>    }</span>
  872 |     | <span class='neutral'></span>
  873 |     | <span class='neutral'>    function log(string memory p0, string memory p1, bool p2, address p3) internal view {</span>
  874 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,bool,address)&quot;, p0, p1, p2, p3));</span>
  875 |     | <span class='neutral'>    }</span>
  876 |     | <span class='neutral'></span>
  877 |     | <span class='neutral'>    function log(string memory p0, string memory p1, address p2, uint p3) internal view {</span>
  878 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,address,uint)&quot;, p0, p1, p2, p3));</span>
  879 |     | <span class='neutral'>    }</span>
  880 |     | <span class='neutral'></span>
  881 |     | <span class='neutral'>    function log(string memory p0, string memory p1, address p2, string memory p3) internal view {</span>
  882 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,address,string)&quot;, p0, p1, p2, p3));</span>
  883 |     | <span class='neutral'>    }</span>
  884 |     | <span class='neutral'></span>
  885 |     | <span class='neutral'>    function log(string memory p0, string memory p1, address p2, bool p3) internal view {</span>
  886 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,address,bool)&quot;, p0, p1, p2, p3));</span>
  887 |     | <span class='neutral'>    }</span>
  888 |     | <span class='neutral'></span>
  889 |     | <span class='neutral'>    function log(string memory p0, string memory p1, address p2, address p3) internal view {</span>
  890 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,address,address)&quot;, p0, p1, p2, p3));</span>
  891 |     | <span class='neutral'>    }</span>
  892 |     | <span class='neutral'></span>
  893 |     | <span class='neutral'>    function log(string memory p0, bool p1, uint p2, uint p3) internal view {</span>
  894 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,uint,uint)&quot;, p0, p1, p2, p3));</span>
  895 |     | <span class='neutral'>    }</span>
  896 |     | <span class='neutral'></span>
  897 |     | <span class='neutral'>    function log(string memory p0, bool p1, uint p2, string memory p3) internal view {</span>
  898 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,uint,string)&quot;, p0, p1, p2, p3));</span>
  899 |     | <span class='neutral'>    }</span>
  900 |     | <span class='neutral'></span>
  901 |     | <span class='neutral'>    function log(string memory p0, bool p1, uint p2, bool p3) internal view {</span>
  902 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,uint,bool)&quot;, p0, p1, p2, p3));</span>
  903 |     | <span class='neutral'>    }</span>
  904 |     | <span class='neutral'></span>
  905 |     | <span class='neutral'>    function log(string memory p0, bool p1, uint p2, address p3) internal view {</span>
  906 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,uint,address)&quot;, p0, p1, p2, p3));</span>
  907 |     | <span class='neutral'>    }</span>
  908 |     | <span class='neutral'></span>
  909 |     | <span class='neutral'>    function log(string memory p0, bool p1, string memory p2, uint p3) internal view {</span>
  910 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,string,uint)&quot;, p0, p1, p2, p3));</span>
  911 |     | <span class='neutral'>    }</span>
  912 |     | <span class='neutral'></span>
  913 |     | <span class='neutral'>    function log(string memory p0, bool p1, string memory p2, string memory p3) internal view {</span>
  914 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,string,string)&quot;, p0, p1, p2, p3));</span>
  915 |     | <span class='neutral'>    }</span>
  916 |     | <span class='neutral'></span>
  917 |     | <span class='neutral'>    function log(string memory p0, bool p1, string memory p2, bool p3) internal view {</span>
  918 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,string,bool)&quot;, p0, p1, p2, p3));</span>
  919 |     | <span class='neutral'>    }</span>
  920 |     | <span class='neutral'></span>
  921 |     | <span class='neutral'>    function log(string memory p0, bool p1, string memory p2, address p3) internal view {</span>
  922 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,string,address)&quot;, p0, p1, p2, p3));</span>
  923 |     | <span class='neutral'>    }</span>
  924 |     | <span class='neutral'></span>
  925 |     | <span class='neutral'>    function log(string memory p0, bool p1, bool p2, uint p3) internal view {</span>
  926 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,bool,uint)&quot;, p0, p1, p2, p3));</span>
  927 |     | <span class='neutral'>    }</span>
  928 |     | <span class='neutral'></span>
  929 |     | <span class='neutral'>    function log(string memory p0, bool p1, bool p2, string memory p3) internal view {</span>
  930 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,bool,string)&quot;, p0, p1, p2, p3));</span>
  931 |     | <span class='neutral'>    }</span>
  932 |     | <span class='neutral'></span>
  933 |     | <span class='neutral'>    function log(string memory p0, bool p1, bool p2, bool p3) internal view {</span>
  934 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,bool,bool)&quot;, p0, p1, p2, p3));</span>
  935 |     | <span class='neutral'>    }</span>
  936 |     | <span class='neutral'></span>
  937 |     | <span class='neutral'>    function log(string memory p0, bool p1, bool p2, address p3) internal view {</span>
  938 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,bool,address)&quot;, p0, p1, p2, p3));</span>
  939 |     | <span class='neutral'>    }</span>
  940 |     | <span class='neutral'></span>
  941 |     | <span class='neutral'>    function log(string memory p0, bool p1, address p2, uint p3) internal view {</span>
  942 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,address,uint)&quot;, p0, p1, p2, p3));</span>
  943 |     | <span class='neutral'>    }</span>
  944 |     | <span class='neutral'></span>
  945 |     | <span class='neutral'>    function log(string memory p0, bool p1, address p2, string memory p3) internal view {</span>
  946 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,address,string)&quot;, p0, p1, p2, p3));</span>
  947 |     | <span class='neutral'>    }</span>
  948 |     | <span class='neutral'></span>
  949 |     | <span class='neutral'>    function log(string memory p0, bool p1, address p2, bool p3) internal view {</span>
  950 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,address,bool)&quot;, p0, p1, p2, p3));</span>
  951 |     | <span class='neutral'>    }</span>
  952 |     | <span class='neutral'></span>
  953 |     | <span class='neutral'>    function log(string memory p0, bool p1, address p2, address p3) internal view {</span>
  954 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,address,address)&quot;, p0, p1, p2, p3));</span>
  955 |     | <span class='neutral'>    }</span>
  956 |     | <span class='neutral'></span>
  957 |     | <span class='neutral'>    function log(string memory p0, address p1, uint p2, uint p3) internal view {</span>
  958 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,uint,uint)&quot;, p0, p1, p2, p3));</span>
  959 |     | <span class='neutral'>    }</span>
  960 |     | <span class='neutral'></span>
  961 |     | <span class='neutral'>    function log(string memory p0, address p1, uint p2, string memory p3) internal view {</span>
  962 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,uint,string)&quot;, p0, p1, p2, p3));</span>
  963 |     | <span class='neutral'>    }</span>
  964 |     | <span class='neutral'></span>
  965 |     | <span class='neutral'>    function log(string memory p0, address p1, uint p2, bool p3) internal view {</span>
  966 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,uint,bool)&quot;, p0, p1, p2, p3));</span>
  967 |     | <span class='neutral'>    }</span>
  968 |     | <span class='neutral'></span>
  969 |     | <span class='neutral'>    function log(string memory p0, address p1, uint p2, address p3) internal view {</span>
  970 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,uint,address)&quot;, p0, p1, p2, p3));</span>
  971 |     | <span class='neutral'>    }</span>
  972 |     | <span class='neutral'></span>
  973 |     | <span class='neutral'>    function log(string memory p0, address p1, string memory p2, uint p3) internal view {</span>
  974 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,string,uint)&quot;, p0, p1, p2, p3));</span>
  975 |     | <span class='neutral'>    }</span>
  976 |     | <span class='neutral'></span>
  977 |     | <span class='neutral'>    function log(string memory p0, address p1, string memory p2, string memory p3) internal view {</span>
  978 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,string,string)&quot;, p0, p1, p2, p3));</span>
  979 |     | <span class='neutral'>    }</span>
  980 |     | <span class='neutral'></span>
  981 |     | <span class='neutral'>    function log(string memory p0, address p1, string memory p2, bool p3) internal view {</span>
  982 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,string,bool)&quot;, p0, p1, p2, p3));</span>
  983 |     | <span class='neutral'>    }</span>
  984 |     | <span class='neutral'></span>
  985 |     | <span class='neutral'>    function log(string memory p0, address p1, string memory p2, address p3) internal view {</span>
  986 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,string,address)&quot;, p0, p1, p2, p3));</span>
  987 |     | <span class='neutral'>    }</span>
  988 |     | <span class='neutral'></span>
  989 |     | <span class='neutral'>    function log(string memory p0, address p1, bool p2, uint p3) internal view {</span>
  990 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,bool,uint)&quot;, p0, p1, p2, p3));</span>
  991 |     | <span class='neutral'>    }</span>
  992 |     | <span class='neutral'></span>
  993 |     | <span class='neutral'>    function log(string memory p0, address p1, bool p2, string memory p3) internal view {</span>
  994 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,bool,string)&quot;, p0, p1, p2, p3));</span>
  995 |     | <span class='neutral'>    }</span>
  996 |     | <span class='neutral'></span>
  997 |     | <span class='neutral'>    function log(string memory p0, address p1, bool p2, bool p3) internal view {</span>
  998 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,bool,bool)&quot;, p0, p1, p2, p3));</span>
  999 |     | <span class='neutral'>    }</span>
 1000 |     | <span class='neutral'></span>
 1001 |     | <span class='neutral'>    function log(string memory p0, address p1, bool p2, address p3) internal view {</span>
 1002 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,bool,address)&quot;, p0, p1, p2, p3));</span>
 1003 |     | <span class='neutral'>    }</span>
 1004 |     | <span class='neutral'></span>
 1005 |     | <span class='neutral'>    function log(string memory p0, address p1, address p2, uint p3) internal view {</span>
 1006 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,address,uint)&quot;, p0, p1, p2, p3));</span>
 1007 |     | <span class='neutral'>    }</span>
 1008 |     | <span class='neutral'></span>
 1009 |     | <span class='neutral'>    function log(string memory p0, address p1, address p2, string memory p3) internal view {</span>
 1010 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,address,string)&quot;, p0, p1, p2, p3));</span>
 1011 |     | <span class='neutral'>    }</span>
 1012 |     | <span class='neutral'></span>
 1013 |     | <span class='neutral'>    function log(string memory p0, address p1, address p2, bool p3) internal view {</span>
 1014 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,address,bool)&quot;, p0, p1, p2, p3));</span>
 1015 |     | <span class='neutral'>    }</span>
 1016 |     | <span class='neutral'></span>
 1017 |     | <span class='neutral'>    function log(string memory p0, address p1, address p2, address p3) internal view {</span>
 1018 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,address,address)&quot;, p0, p1, p2, p3));</span>
 1019 |     | <span class='neutral'>    }</span>
 1020 |     | <span class='neutral'></span>
 1021 |     | <span class='neutral'>    function log(bool p0, uint p1, uint p2, uint p3) internal view {</span>
 1022 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint,uint,uint)&quot;, p0, p1, p2, p3));</span>
 1023 |     | <span class='neutral'>    }</span>
 1024 |     | <span class='neutral'></span>
 1025 |     | <span class='neutral'>    function log(bool p0, uint p1, uint p2, string memory p3) internal view {</span>
 1026 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint,uint,string)&quot;, p0, p1, p2, p3));</span>
 1027 |     | <span class='neutral'>    }</span>
 1028 |     | <span class='neutral'></span>
 1029 |     | <span class='neutral'>    function log(bool p0, uint p1, uint p2, bool p3) internal view {</span>
 1030 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint,uint,bool)&quot;, p0, p1, p2, p3));</span>
 1031 |     | <span class='neutral'>    }</span>
 1032 |     | <span class='neutral'></span>
 1033 |     | <span class='neutral'>    function log(bool p0, uint p1, uint p2, address p3) internal view {</span>
 1034 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint,uint,address)&quot;, p0, p1, p2, p3));</span>
 1035 |     | <span class='neutral'>    }</span>
 1036 |     | <span class='neutral'></span>
 1037 |     | <span class='neutral'>    function log(bool p0, uint p1, string memory p2, uint p3) internal view {</span>
 1038 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint,string,uint)&quot;, p0, p1, p2, p3));</span>
 1039 |     | <span class='neutral'>    }</span>
 1040 |     | <span class='neutral'></span>
 1041 |     | <span class='neutral'>    function log(bool p0, uint p1, string memory p2, string memory p3) internal view {</span>
 1042 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint,string,string)&quot;, p0, p1, p2, p3));</span>
 1043 |     | <span class='neutral'>    }</span>
 1044 |     | <span class='neutral'></span>
 1045 |     | <span class='neutral'>    function log(bool p0, uint p1, string memory p2, bool p3) internal view {</span>
 1046 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint,string,bool)&quot;, p0, p1, p2, p3));</span>
 1047 |     | <span class='neutral'>    }</span>
 1048 |     | <span class='neutral'></span>
 1049 |     | <span class='neutral'>    function log(bool p0, uint p1, string memory p2, address p3) internal view {</span>
 1050 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint,string,address)&quot;, p0, p1, p2, p3));</span>
 1051 |     | <span class='neutral'>    }</span>
 1052 |     | <span class='neutral'></span>
 1053 |     | <span class='neutral'>    function log(bool p0, uint p1, bool p2, uint p3) internal view {</span>
 1054 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint,bool,uint)&quot;, p0, p1, p2, p3));</span>
 1055 |     | <span class='neutral'>    }</span>
 1056 |     | <span class='neutral'></span>
 1057 |     | <span class='neutral'>    function log(bool p0, uint p1, bool p2, string memory p3) internal view {</span>
 1058 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint,bool,string)&quot;, p0, p1, p2, p3));</span>
 1059 |     | <span class='neutral'>    }</span>
 1060 |     | <span class='neutral'></span>
 1061 |     | <span class='neutral'>    function log(bool p0, uint p1, bool p2, bool p3) internal view {</span>
 1062 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint,bool,bool)&quot;, p0, p1, p2, p3));</span>
 1063 |     | <span class='neutral'>    }</span>
 1064 |     | <span class='neutral'></span>
 1065 |     | <span class='neutral'>    function log(bool p0, uint p1, bool p2, address p3) internal view {</span>
 1066 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint,bool,address)&quot;, p0, p1, p2, p3));</span>
 1067 |     | <span class='neutral'>    }</span>
 1068 |     | <span class='neutral'></span>
 1069 |     | <span class='neutral'>    function log(bool p0, uint p1, address p2, uint p3) internal view {</span>
 1070 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint,address,uint)&quot;, p0, p1, p2, p3));</span>
 1071 |     | <span class='neutral'>    }</span>
 1072 |     | <span class='neutral'></span>
 1073 |     | <span class='neutral'>    function log(bool p0, uint p1, address p2, string memory p3) internal view {</span>
 1074 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint,address,string)&quot;, p0, p1, p2, p3));</span>
 1075 |     | <span class='neutral'>    }</span>
 1076 |     | <span class='neutral'></span>
 1077 |     | <span class='neutral'>    function log(bool p0, uint p1, address p2, bool p3) internal view {</span>
 1078 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint,address,bool)&quot;, p0, p1, p2, p3));</span>
 1079 |     | <span class='neutral'>    }</span>
 1080 |     | <span class='neutral'></span>
 1081 |     | <span class='neutral'>    function log(bool p0, uint p1, address p2, address p3) internal view {</span>
 1082 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint,address,address)&quot;, p0, p1, p2, p3));</span>
 1083 |     | <span class='neutral'>    }</span>
 1084 |     | <span class='neutral'></span>
 1085 |     | <span class='neutral'>    function log(bool p0, string memory p1, uint p2, uint p3) internal view {</span>
 1086 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,uint,uint)&quot;, p0, p1, p2, p3));</span>
 1087 |     | <span class='neutral'>    }</span>
 1088 |     | <span class='neutral'></span>
 1089 |     | <span class='neutral'>    function log(bool p0, string memory p1, uint p2, string memory p3) internal view {</span>
 1090 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,uint,string)&quot;, p0, p1, p2, p3));</span>
 1091 |     | <span class='neutral'>    }</span>
 1092 |     | <span class='neutral'></span>
 1093 |     | <span class='neutral'>    function log(bool p0, string memory p1, uint p2, bool p3) internal view {</span>
 1094 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,uint,bool)&quot;, p0, p1, p2, p3));</span>
 1095 |     | <span class='neutral'>    }</span>
 1096 |     | <span class='neutral'></span>
 1097 |     | <span class='neutral'>    function log(bool p0, string memory p1, uint p2, address p3) internal view {</span>
 1098 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,uint,address)&quot;, p0, p1, p2, p3));</span>
 1099 |     | <span class='neutral'>    }</span>
 1100 |     | <span class='neutral'></span>
 1101 |     | <span class='neutral'>    function log(bool p0, string memory p1, string memory p2, uint p3) internal view {</span>
 1102 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,string,uint)&quot;, p0, p1, p2, p3));</span>
 1103 |     | <span class='neutral'>    }</span>
 1104 |     | <span class='neutral'></span>
 1105 |     | <span class='neutral'>    function log(bool p0, string memory p1, string memory p2, string memory p3) internal view {</span>
 1106 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,string,string)&quot;, p0, p1, p2, p3));</span>
 1107 |     | <span class='neutral'>    }</span>
 1108 |     | <span class='neutral'></span>
 1109 |     | <span class='neutral'>    function log(bool p0, string memory p1, string memory p2, bool p3) internal view {</span>
 1110 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,string,bool)&quot;, p0, p1, p2, p3));</span>
 1111 |     | <span class='neutral'>    }</span>
 1112 |     | <span class='neutral'></span>
 1113 |     | <span class='neutral'>    function log(bool p0, string memory p1, string memory p2, address p3) internal view {</span>
 1114 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,string,address)&quot;, p0, p1, p2, p3));</span>
 1115 |     | <span class='neutral'>    }</span>
 1116 |     | <span class='neutral'></span>
 1117 |     | <span class='neutral'>    function log(bool p0, string memory p1, bool p2, uint p3) internal view {</span>
 1118 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,bool,uint)&quot;, p0, p1, p2, p3));</span>
 1119 |     | <span class='neutral'>    }</span>
 1120 |     | <span class='neutral'></span>
 1121 |     | <span class='neutral'>    function log(bool p0, string memory p1, bool p2, string memory p3) internal view {</span>
 1122 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,bool,string)&quot;, p0, p1, p2, p3));</span>
 1123 |     | <span class='neutral'>    }</span>
 1124 |     | <span class='neutral'></span>
 1125 |     | <span class='neutral'>    function log(bool p0, string memory p1, bool p2, bool p3) internal view {</span>
 1126 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,bool,bool)&quot;, p0, p1, p2, p3));</span>
 1127 |     | <span class='neutral'>    }</span>
 1128 |     | <span class='neutral'></span>
 1129 |     | <span class='neutral'>    function log(bool p0, string memory p1, bool p2, address p3) internal view {</span>
 1130 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,bool,address)&quot;, p0, p1, p2, p3));</span>
 1131 |     | <span class='neutral'>    }</span>
 1132 |     | <span class='neutral'></span>
 1133 |     | <span class='neutral'>    function log(bool p0, string memory p1, address p2, uint p3) internal view {</span>
 1134 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,address,uint)&quot;, p0, p1, p2, p3));</span>
 1135 |     | <span class='neutral'>    }</span>
 1136 |     | <span class='neutral'></span>
 1137 |     | <span class='neutral'>    function log(bool p0, string memory p1, address p2, string memory p3) internal view {</span>
 1138 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,address,string)&quot;, p0, p1, p2, p3));</span>
 1139 |     | <span class='neutral'>    }</span>
 1140 |     | <span class='neutral'></span>
 1141 |     | <span class='neutral'>    function log(bool p0, string memory p1, address p2, bool p3) internal view {</span>
 1142 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,address,bool)&quot;, p0, p1, p2, p3));</span>
 1143 |     | <span class='neutral'>    }</span>
 1144 |     | <span class='neutral'></span>
 1145 |     | <span class='neutral'>    function log(bool p0, string memory p1, address p2, address p3) internal view {</span>
 1146 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,address,address)&quot;, p0, p1, p2, p3));</span>
 1147 |     | <span class='neutral'>    }</span>
 1148 |     | <span class='neutral'></span>
 1149 |     | <span class='neutral'>    function log(bool p0, bool p1, uint p2, uint p3) internal view {</span>
 1150 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,uint,uint)&quot;, p0, p1, p2, p3));</span>
 1151 |     | <span class='neutral'>    }</span>
 1152 |     | <span class='neutral'></span>
 1153 |     | <span class='neutral'>    function log(bool p0, bool p1, uint p2, string memory p3) internal view {</span>
 1154 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,uint,string)&quot;, p0, p1, p2, p3));</span>
 1155 |     | <span class='neutral'>    }</span>
 1156 |     | <span class='neutral'></span>
 1157 |     | <span class='neutral'>    function log(bool p0, bool p1, uint p2, bool p3) internal view {</span>
 1158 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,uint,bool)&quot;, p0, p1, p2, p3));</span>
 1159 |     | <span class='neutral'>    }</span>
 1160 |     | <span class='neutral'></span>
 1161 |     | <span class='neutral'>    function log(bool p0, bool p1, uint p2, address p3) internal view {</span>
 1162 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,uint,address)&quot;, p0, p1, p2, p3));</span>
 1163 |     | <span class='neutral'>    }</span>
 1164 |     | <span class='neutral'></span>
 1165 |     | <span class='neutral'>    function log(bool p0, bool p1, string memory p2, uint p3) internal view {</span>
 1166 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,string,uint)&quot;, p0, p1, p2, p3));</span>
 1167 |     | <span class='neutral'>    }</span>
 1168 |     | <span class='neutral'></span>
 1169 |     | <span class='neutral'>    function log(bool p0, bool p1, string memory p2, string memory p3) internal view {</span>
 1170 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,string,string)&quot;, p0, p1, p2, p3));</span>
 1171 |     | <span class='neutral'>    }</span>
 1172 |     | <span class='neutral'></span>
 1173 |     | <span class='neutral'>    function log(bool p0, bool p1, string memory p2, bool p3) internal view {</span>
 1174 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,string,bool)&quot;, p0, p1, p2, p3));</span>
 1175 |     | <span class='neutral'>    }</span>
 1176 |     | <span class='neutral'></span>
 1177 |     | <span class='neutral'>    function log(bool p0, bool p1, string memory p2, address p3) internal view {</span>
 1178 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,string,address)&quot;, p0, p1, p2, p3));</span>
 1179 |     | <span class='neutral'>    }</span>
 1180 |     | <span class='neutral'></span>
 1181 |     | <span class='neutral'>    function log(bool p0, bool p1, bool p2, uint p3) internal view {</span>
 1182 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,bool,uint)&quot;, p0, p1, p2, p3));</span>
 1183 |     | <span class='neutral'>    }</span>
 1184 |     | <span class='neutral'></span>
 1185 |     | <span class='neutral'>    function log(bool p0, bool p1, bool p2, string memory p3) internal view {</span>
 1186 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,bool,string)&quot;, p0, p1, p2, p3));</span>
 1187 |     | <span class='neutral'>    }</span>
 1188 |     | <span class='neutral'></span>
 1189 |     | <span class='neutral'>    function log(bool p0, bool p1, bool p2, bool p3) internal view {</span>
 1190 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,bool,bool)&quot;, p0, p1, p2, p3));</span>
 1191 |     | <span class='neutral'>    }</span>
 1192 |     | <span class='neutral'></span>
 1193 |     | <span class='neutral'>    function log(bool p0, bool p1, bool p2, address p3) internal view {</span>
 1194 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,bool,address)&quot;, p0, p1, p2, p3));</span>
 1195 |     | <span class='neutral'>    }</span>
 1196 |     | <span class='neutral'></span>
 1197 |     | <span class='neutral'>    function log(bool p0, bool p1, address p2, uint p3) internal view {</span>
 1198 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,address,uint)&quot;, p0, p1, p2, p3));</span>
 1199 |     | <span class='neutral'>    }</span>
 1200 |     | <span class='neutral'></span>
 1201 |     | <span class='neutral'>    function log(bool p0, bool p1, address p2, string memory p3) internal view {</span>
 1202 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,address,string)&quot;, p0, p1, p2, p3));</span>
 1203 |     | <span class='neutral'>    }</span>
 1204 |     | <span class='neutral'></span>
 1205 |     | <span class='neutral'>    function log(bool p0, bool p1, address p2, bool p3) internal view {</span>
 1206 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,address,bool)&quot;, p0, p1, p2, p3));</span>
 1207 |     | <span class='neutral'>    }</span>
 1208 |     | <span class='neutral'></span>
 1209 |     | <span class='neutral'>    function log(bool p0, bool p1, address p2, address p3) internal view {</span>
 1210 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,address,address)&quot;, p0, p1, p2, p3));</span>
 1211 |     | <span class='neutral'>    }</span>
 1212 |     | <span class='neutral'></span>
 1213 |     | <span class='neutral'>    function log(bool p0, address p1, uint p2, uint p3) internal view {</span>
 1214 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,uint,uint)&quot;, p0, p1, p2, p3));</span>
 1215 |     | <span class='neutral'>    }</span>
 1216 |     | <span class='neutral'></span>
 1217 |     | <span class='neutral'>    function log(bool p0, address p1, uint p2, string memory p3) internal view {</span>
 1218 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,uint,string)&quot;, p0, p1, p2, p3));</span>
 1219 |     | <span class='neutral'>    }</span>
 1220 |     | <span class='neutral'></span>
 1221 |     | <span class='neutral'>    function log(bool p0, address p1, uint p2, bool p3) internal view {</span>
 1222 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,uint,bool)&quot;, p0, p1, p2, p3));</span>
 1223 |     | <span class='neutral'>    }</span>
 1224 |     | <span class='neutral'></span>
 1225 |     | <span class='neutral'>    function log(bool p0, address p1, uint p2, address p3) internal view {</span>
 1226 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,uint,address)&quot;, p0, p1, p2, p3));</span>
 1227 |     | <span class='neutral'>    }</span>
 1228 |     | <span class='neutral'></span>
 1229 |     | <span class='neutral'>    function log(bool p0, address p1, string memory p2, uint p3) internal view {</span>
 1230 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,string,uint)&quot;, p0, p1, p2, p3));</span>
 1231 |     | <span class='neutral'>    }</span>
 1232 |     | <span class='neutral'></span>
 1233 |     | <span class='neutral'>    function log(bool p0, address p1, string memory p2, string memory p3) internal view {</span>
 1234 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,string,string)&quot;, p0, p1, p2, p3));</span>
 1235 |     | <span class='neutral'>    }</span>
 1236 |     | <span class='neutral'></span>
 1237 |     | <span class='neutral'>    function log(bool p0, address p1, string memory p2, bool p3) internal view {</span>
 1238 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,string,bool)&quot;, p0, p1, p2, p3));</span>
 1239 |     | <span class='neutral'>    }</span>
 1240 |     | <span class='neutral'></span>
 1241 |     | <span class='neutral'>    function log(bool p0, address p1, string memory p2, address p3) internal view {</span>
 1242 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,string,address)&quot;, p0, p1, p2, p3));</span>
 1243 |     | <span class='neutral'>    }</span>
 1244 |     | <span class='neutral'></span>
 1245 |     | <span class='neutral'>    function log(bool p0, address p1, bool p2, uint p3) internal view {</span>
 1246 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,bool,uint)&quot;, p0, p1, p2, p3));</span>
 1247 |     | <span class='neutral'>    }</span>
 1248 |     | <span class='neutral'></span>
 1249 |     | <span class='neutral'>    function log(bool p0, address p1, bool p2, string memory p3) internal view {</span>
 1250 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,bool,string)&quot;, p0, p1, p2, p3));</span>
 1251 |     | <span class='neutral'>    }</span>
 1252 |     | <span class='neutral'></span>
 1253 |     | <span class='neutral'>    function log(bool p0, address p1, bool p2, bool p3) internal view {</span>
 1254 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,bool,bool)&quot;, p0, p1, p2, p3));</span>
 1255 |     | <span class='neutral'>    }</span>
 1256 |     | <span class='neutral'></span>
 1257 |     | <span class='neutral'>    function log(bool p0, address p1, bool p2, address p3) internal view {</span>
 1258 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,bool,address)&quot;, p0, p1, p2, p3));</span>
 1259 |     | <span class='neutral'>    }</span>
 1260 |     | <span class='neutral'></span>
 1261 |     | <span class='neutral'>    function log(bool p0, address p1, address p2, uint p3) internal view {</span>
 1262 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,address,uint)&quot;, p0, p1, p2, p3));</span>
 1263 |     | <span class='neutral'>    }</span>
 1264 |     | <span class='neutral'></span>
 1265 |     | <span class='neutral'>    function log(bool p0, address p1, address p2, string memory p3) internal view {</span>
 1266 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,address,string)&quot;, p0, p1, p2, p3));</span>
 1267 |     | <span class='neutral'>    }</span>
 1268 |     | <span class='neutral'></span>
 1269 |     | <span class='neutral'>    function log(bool p0, address p1, address p2, bool p3) internal view {</span>
 1270 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,address,bool)&quot;, p0, p1, p2, p3));</span>
 1271 |     | <span class='neutral'>    }</span>
 1272 |     | <span class='neutral'></span>
 1273 |     | <span class='neutral'>    function log(bool p0, address p1, address p2, address p3) internal view {</span>
 1274 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,address,address)&quot;, p0, p1, p2, p3));</span>
 1275 |     | <span class='neutral'>    }</span>
 1276 |     | <span class='neutral'></span>
 1277 |     | <span class='neutral'>    function log(address p0, uint p1, uint p2, uint p3) internal view {</span>
 1278 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint,uint,uint)&quot;, p0, p1, p2, p3));</span>
 1279 |     | <span class='neutral'>    }</span>
 1280 |     | <span class='neutral'></span>
 1281 |     | <span class='neutral'>    function log(address p0, uint p1, uint p2, string memory p3) internal view {</span>
 1282 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint,uint,string)&quot;, p0, p1, p2, p3));</span>
 1283 |     | <span class='neutral'>    }</span>
 1284 |     | <span class='neutral'></span>
 1285 |     | <span class='neutral'>    function log(address p0, uint p1, uint p2, bool p3) internal view {</span>
 1286 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint,uint,bool)&quot;, p0, p1, p2, p3));</span>
 1287 |     | <span class='neutral'>    }</span>
 1288 |     | <span class='neutral'></span>
 1289 |     | <span class='neutral'>    function log(address p0, uint p1, uint p2, address p3) internal view {</span>
 1290 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint,uint,address)&quot;, p0, p1, p2, p3));</span>
 1291 |     | <span class='neutral'>    }</span>
 1292 |     | <span class='neutral'></span>
 1293 |     | <span class='neutral'>    function log(address p0, uint p1, string memory p2, uint p3) internal view {</span>
 1294 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint,string,uint)&quot;, p0, p1, p2, p3));</span>
 1295 |     | <span class='neutral'>    }</span>
 1296 |     | <span class='neutral'></span>
 1297 |     | <span class='neutral'>    function log(address p0, uint p1, string memory p2, string memory p3) internal view {</span>
 1298 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint,string,string)&quot;, p0, p1, p2, p3));</span>
 1299 |     | <span class='neutral'>    }</span>
 1300 |     | <span class='neutral'></span>
 1301 |     | <span class='neutral'>    function log(address p0, uint p1, string memory p2, bool p3) internal view {</span>
 1302 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint,string,bool)&quot;, p0, p1, p2, p3));</span>
 1303 |     | <span class='neutral'>    }</span>
 1304 |     | <span class='neutral'></span>
 1305 |     | <span class='neutral'>    function log(address p0, uint p1, string memory p2, address p3) internal view {</span>
 1306 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint,string,address)&quot;, p0, p1, p2, p3));</span>
 1307 |     | <span class='neutral'>    }</span>
 1308 |     | <span class='neutral'></span>
 1309 |     | <span class='neutral'>    function log(address p0, uint p1, bool p2, uint p3) internal view {</span>
 1310 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint,bool,uint)&quot;, p0, p1, p2, p3));</span>
 1311 |     | <span class='neutral'>    }</span>
 1312 |     | <span class='neutral'></span>
 1313 |     | <span class='neutral'>    function log(address p0, uint p1, bool p2, string memory p3) internal view {</span>
 1314 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint,bool,string)&quot;, p0, p1, p2, p3));</span>
 1315 |     | <span class='neutral'>    }</span>
 1316 |     | <span class='neutral'></span>
 1317 |     | <span class='neutral'>    function log(address p0, uint p1, bool p2, bool p3) internal view {</span>
 1318 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint,bool,bool)&quot;, p0, p1, p2, p3));</span>
 1319 |     | <span class='neutral'>    }</span>
 1320 |     | <span class='neutral'></span>
 1321 |     | <span class='neutral'>    function log(address p0, uint p1, bool p2, address p3) internal view {</span>
 1322 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint,bool,address)&quot;, p0, p1, p2, p3));</span>
 1323 |     | <span class='neutral'>    }</span>
 1324 |     | <span class='neutral'></span>
 1325 |     | <span class='neutral'>    function log(address p0, uint p1, address p2, uint p3) internal view {</span>
 1326 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint,address,uint)&quot;, p0, p1, p2, p3));</span>
 1327 |     | <span class='neutral'>    }</span>
 1328 |     | <span class='neutral'></span>
 1329 |     | <span class='neutral'>    function log(address p0, uint p1, address p2, string memory p3) internal view {</span>
 1330 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint,address,string)&quot;, p0, p1, p2, p3));</span>
 1331 |     | <span class='neutral'>    }</span>
 1332 |     | <span class='neutral'></span>
 1333 |     | <span class='neutral'>    function log(address p0, uint p1, address p2, bool p3) internal view {</span>
 1334 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint,address,bool)&quot;, p0, p1, p2, p3));</span>
 1335 |     | <span class='neutral'>    }</span>
 1336 |     | <span class='neutral'></span>
 1337 |     | <span class='neutral'>    function log(address p0, uint p1, address p2, address p3) internal view {</span>
 1338 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint,address,address)&quot;, p0, p1, p2, p3));</span>
 1339 |     | <span class='neutral'>    }</span>
 1340 |     | <span class='neutral'></span>
 1341 |     | <span class='neutral'>    function log(address p0, string memory p1, uint p2, uint p3) internal view {</span>
 1342 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,uint,uint)&quot;, p0, p1, p2, p3));</span>
 1343 |     | <span class='neutral'>    }</span>
 1344 |     | <span class='neutral'></span>
 1345 |     | <span class='neutral'>    function log(address p0, string memory p1, uint p2, string memory p3) internal view {</span>
 1346 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,uint,string)&quot;, p0, p1, p2, p3));</span>
 1347 |     | <span class='neutral'>    }</span>
 1348 |     | <span class='neutral'></span>
 1349 |     | <span class='neutral'>    function log(address p0, string memory p1, uint p2, bool p3) internal view {</span>
 1350 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,uint,bool)&quot;, p0, p1, p2, p3));</span>
 1351 |     | <span class='neutral'>    }</span>
 1352 |     | <span class='neutral'></span>
 1353 |     | <span class='neutral'>    function log(address p0, string memory p1, uint p2, address p3) internal view {</span>
 1354 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,uint,address)&quot;, p0, p1, p2, p3));</span>
 1355 |     | <span class='neutral'>    }</span>
 1356 |     | <span class='neutral'></span>
 1357 |     | <span class='neutral'>    function log(address p0, string memory p1, string memory p2, uint p3) internal view {</span>
 1358 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,string,uint)&quot;, p0, p1, p2, p3));</span>
 1359 |     | <span class='neutral'>    }</span>
 1360 |     | <span class='neutral'></span>
 1361 |     | <span class='neutral'>    function log(address p0, string memory p1, string memory p2, string memory p3) internal view {</span>
 1362 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,string,string)&quot;, p0, p1, p2, p3));</span>
 1363 |     | <span class='neutral'>    }</span>
 1364 |     | <span class='neutral'></span>
 1365 |     | <span class='neutral'>    function log(address p0, string memory p1, string memory p2, bool p3) internal view {</span>
 1366 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,string,bool)&quot;, p0, p1, p2, p3));</span>
 1367 |     | <span class='neutral'>    }</span>
 1368 |     | <span class='neutral'></span>
 1369 |     | <span class='neutral'>    function log(address p0, string memory p1, string memory p2, address p3) internal view {</span>
 1370 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,string,address)&quot;, p0, p1, p2, p3));</span>
 1371 |     | <span class='neutral'>    }</span>
 1372 |     | <span class='neutral'></span>
 1373 |     | <span class='neutral'>    function log(address p0, string memory p1, bool p2, uint p3) internal view {</span>
 1374 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,bool,uint)&quot;, p0, p1, p2, p3));</span>
 1375 |     | <span class='neutral'>    }</span>
 1376 |     | <span class='neutral'></span>
 1377 |     | <span class='neutral'>    function log(address p0, string memory p1, bool p2, string memory p3) internal view {</span>
 1378 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,bool,string)&quot;, p0, p1, p2, p3));</span>
 1379 |     | <span class='neutral'>    }</span>
 1380 |     | <span class='neutral'></span>
 1381 |     | <span class='neutral'>    function log(address p0, string memory p1, bool p2, bool p3) internal view {</span>
 1382 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,bool,bool)&quot;, p0, p1, p2, p3));</span>
 1383 |     | <span class='neutral'>    }</span>
 1384 |     | <span class='neutral'></span>
 1385 |     | <span class='neutral'>    function log(address p0, string memory p1, bool p2, address p3) internal view {</span>
 1386 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,bool,address)&quot;, p0, p1, p2, p3));</span>
 1387 |     | <span class='neutral'>    }</span>
 1388 |     | <span class='neutral'></span>
 1389 |     | <span class='neutral'>    function log(address p0, string memory p1, address p2, uint p3) internal view {</span>
 1390 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,address,uint)&quot;, p0, p1, p2, p3));</span>
 1391 |     | <span class='neutral'>    }</span>
 1392 |     | <span class='neutral'></span>
 1393 |     | <span class='neutral'>    function log(address p0, string memory p1, address p2, string memory p3) internal view {</span>
 1394 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,address,string)&quot;, p0, p1, p2, p3));</span>
 1395 |     | <span class='neutral'>    }</span>
 1396 |     | <span class='neutral'></span>
 1397 |     | <span class='neutral'>    function log(address p0, string memory p1, address p2, bool p3) internal view {</span>
 1398 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,address,bool)&quot;, p0, p1, p2, p3));</span>
 1399 |     | <span class='neutral'>    }</span>
 1400 |     | <span class='neutral'></span>
 1401 |     | <span class='neutral'>    function log(address p0, string memory p1, address p2, address p3) internal view {</span>
 1402 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,address,address)&quot;, p0, p1, p2, p3));</span>
 1403 |     | <span class='neutral'>    }</span>
 1404 |     | <span class='neutral'></span>
 1405 |     | <span class='neutral'>    function log(address p0, bool p1, uint p2, uint p3) internal view {</span>
 1406 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,uint,uint)&quot;, p0, p1, p2, p3));</span>
 1407 |     | <span class='neutral'>    }</span>
 1408 |     | <span class='neutral'></span>
 1409 |     | <span class='neutral'>    function log(address p0, bool p1, uint p2, string memory p3) internal view {</span>
 1410 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,uint,string)&quot;, p0, p1, p2, p3));</span>
 1411 |     | <span class='neutral'>    }</span>
 1412 |     | <span class='neutral'></span>
 1413 |     | <span class='neutral'>    function log(address p0, bool p1, uint p2, bool p3) internal view {</span>
 1414 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,uint,bool)&quot;, p0, p1, p2, p3));</span>
 1415 |     | <span class='neutral'>    }</span>
 1416 |     | <span class='neutral'></span>
 1417 |     | <span class='neutral'>    function log(address p0, bool p1, uint p2, address p3) internal view {</span>
 1418 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,uint,address)&quot;, p0, p1, p2, p3));</span>
 1419 |     | <span class='neutral'>    }</span>
 1420 |     | <span class='neutral'></span>
 1421 |     | <span class='neutral'>    function log(address p0, bool p1, string memory p2, uint p3) internal view {</span>
 1422 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,string,uint)&quot;, p0, p1, p2, p3));</span>
 1423 |     | <span class='neutral'>    }</span>
 1424 |     | <span class='neutral'></span>
 1425 |     | <span class='neutral'>    function log(address p0, bool p1, string memory p2, string memory p3) internal view {</span>
 1426 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,string,string)&quot;, p0, p1, p2, p3));</span>
 1427 |     | <span class='neutral'>    }</span>
 1428 |     | <span class='neutral'></span>
 1429 |     | <span class='neutral'>    function log(address p0, bool p1, string memory p2, bool p3) internal view {</span>
 1430 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,string,bool)&quot;, p0, p1, p2, p3));</span>
 1431 |     | <span class='neutral'>    }</span>
 1432 |     | <span class='neutral'></span>
 1433 |     | <span class='neutral'>    function log(address p0, bool p1, string memory p2, address p3) internal view {</span>
 1434 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,string,address)&quot;, p0, p1, p2, p3));</span>
 1435 |     | <span class='neutral'>    }</span>
 1436 |     | <span class='neutral'></span>
 1437 |     | <span class='neutral'>    function log(address p0, bool p1, bool p2, uint p3) internal view {</span>
 1438 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,bool,uint)&quot;, p0, p1, p2, p3));</span>
 1439 |     | <span class='neutral'>    }</span>
 1440 |     | <span class='neutral'></span>
 1441 |     | <span class='neutral'>    function log(address p0, bool p1, bool p2, string memory p3) internal view {</span>
 1442 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,bool,string)&quot;, p0, p1, p2, p3));</span>
 1443 |     | <span class='neutral'>    }</span>
 1444 |     | <span class='neutral'></span>
 1445 |     | <span class='neutral'>    function log(address p0, bool p1, bool p2, bool p3) internal view {</span>
 1446 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,bool,bool)&quot;, p0, p1, p2, p3));</span>
 1447 |     | <span class='neutral'>    }</span>
 1448 |     | <span class='neutral'></span>
 1449 |     | <span class='neutral'>    function log(address p0, bool p1, bool p2, address p3) internal view {</span>
 1450 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,bool,address)&quot;, p0, p1, p2, p3));</span>
 1451 |     | <span class='neutral'>    }</span>
 1452 |     | <span class='neutral'></span>
 1453 |     | <span class='neutral'>    function log(address p0, bool p1, address p2, uint p3) internal view {</span>
 1454 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,address,uint)&quot;, p0, p1, p2, p3));</span>
 1455 |     | <span class='neutral'>    }</span>
 1456 |     | <span class='neutral'></span>
 1457 |     | <span class='neutral'>    function log(address p0, bool p1, address p2, string memory p3) internal view {</span>
 1458 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,address,string)&quot;, p0, p1, p2, p3));</span>
 1459 |     | <span class='neutral'>    }</span>
 1460 |     | <span class='neutral'></span>
 1461 |     | <span class='neutral'>    function log(address p0, bool p1, address p2, bool p3) internal view {</span>
 1462 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,address,bool)&quot;, p0, p1, p2, p3));</span>
 1463 |     | <span class='neutral'>    }</span>
 1464 |     | <span class='neutral'></span>
 1465 |     | <span class='neutral'>    function log(address p0, bool p1, address p2, address p3) internal view {</span>
 1466 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,address,address)&quot;, p0, p1, p2, p3));</span>
 1467 |     | <span class='neutral'>    }</span>
 1468 |     | <span class='neutral'></span>
 1469 |     | <span class='neutral'>    function log(address p0, address p1, uint p2, uint p3) internal view {</span>
 1470 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,uint,uint)&quot;, p0, p1, p2, p3));</span>
 1471 |     | <span class='neutral'>    }</span>
 1472 |     | <span class='neutral'></span>
 1473 |     | <span class='neutral'>    function log(address p0, address p1, uint p2, string memory p3) internal view {</span>
 1474 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,uint,string)&quot;, p0, p1, p2, p3));</span>
 1475 |     | <span class='neutral'>    }</span>
 1476 |     | <span class='neutral'></span>
 1477 |     | <span class='neutral'>    function log(address p0, address p1, uint p2, bool p3) internal view {</span>
 1478 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,uint,bool)&quot;, p0, p1, p2, p3));</span>
 1479 |     | <span class='neutral'>    }</span>
 1480 |     | <span class='neutral'></span>
 1481 |     | <span class='neutral'>    function log(address p0, address p1, uint p2, address p3) internal view {</span>
 1482 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,uint,address)&quot;, p0, p1, p2, p3));</span>
 1483 |     | <span class='neutral'>    }</span>
 1484 |     | <span class='neutral'></span>
 1485 |     | <span class='neutral'>    function log(address p0, address p1, string memory p2, uint p3) internal view {</span>
 1486 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,string,uint)&quot;, p0, p1, p2, p3));</span>
 1487 |     | <span class='neutral'>    }</span>
 1488 |     | <span class='neutral'></span>
 1489 |     | <span class='neutral'>    function log(address p0, address p1, string memory p2, string memory p3) internal view {</span>
 1490 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,string,string)&quot;, p0, p1, p2, p3));</span>
 1491 |     | <span class='neutral'>    }</span>
 1492 |     | <span class='neutral'></span>
 1493 |     | <span class='neutral'>    function log(address p0, address p1, string memory p2, bool p3) internal view {</span>
 1494 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,string,bool)&quot;, p0, p1, p2, p3));</span>
 1495 |     | <span class='neutral'>    }</span>
 1496 |     | <span class='neutral'></span>
 1497 |     | <span class='neutral'>    function log(address p0, address p1, string memory p2, address p3) internal view {</span>
 1498 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,string,address)&quot;, p0, p1, p2, p3));</span>
 1499 |     | <span class='neutral'>    }</span>
 1500 |     | <span class='neutral'></span>
 1501 |     | <span class='neutral'>    function log(address p0, address p1, bool p2, uint p3) internal view {</span>
 1502 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,bool,uint)&quot;, p0, p1, p2, p3));</span>
 1503 |     | <span class='neutral'>    }</span>
 1504 |     | <span class='neutral'></span>
 1505 |     | <span class='neutral'>    function log(address p0, address p1, bool p2, string memory p3) internal view {</span>
 1506 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,bool,string)&quot;, p0, p1, p2, p3));</span>
 1507 |     | <span class='neutral'>    }</span>
 1508 |     | <span class='neutral'></span>
 1509 |     | <span class='neutral'>    function log(address p0, address p1, bool p2, bool p3) internal view {</span>
 1510 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,bool,bool)&quot;, p0, p1, p2, p3));</span>
 1511 |     | <span class='neutral'>    }</span>
 1512 |     | <span class='neutral'></span>
 1513 |     | <span class='neutral'>    function log(address p0, address p1, bool p2, address p3) internal view {</span>
 1514 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,bool,address)&quot;, p0, p1, p2, p3));</span>
 1515 |     | <span class='neutral'>    }</span>
 1516 |     | <span class='neutral'></span>
 1517 |     | <span class='neutral'>    function log(address p0, address p1, address p2, uint p3) internal view {</span>
 1518 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,address,uint)&quot;, p0, p1, p2, p3));</span>
 1519 |     | <span class='neutral'>    }</span>
 1520 |     | <span class='neutral'></span>
 1521 |     | <span class='neutral'>    function log(address p0, address p1, address p2, string memory p3) internal view {</span>
 1522 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,address,string)&quot;, p0, p1, p2, p3));</span>
 1523 |     | <span class='neutral'>    }</span>
 1524 |     | <span class='neutral'></span>
 1525 |     | <span class='neutral'>    function log(address p0, address p1, address p2, bool p3) internal view {</span>
 1526 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,address,bool)&quot;, p0, p1, p2, p3));</span>
 1527 |     | <span class='neutral'>    }</span>
 1528 |     | <span class='neutral'></span>
 1529 |     | <span class='neutral'>    function log(address p0, address p1, address p2, address p3) internal view {</span>
 1530 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,address,address)&quot;, p0, p1, p2, p3));</span>
 1531 |     | <span class='neutral'>    }</span>
 1532 |     | <span class='neutral'></span>
 1533 |     | <span class='neutral'>}</span>

</code>
<br />

<b>/Users/nelsonpereira/Documents/GitHub/Auditing/Fuzzy/Blogs/ElasticSwap_Recon/elasticswap-recon/node_modules/@openzeppelin/contracts/access/Ownable.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable.sol)</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>import &quot;../utils/Context.sol&quot;;</span>
  7 |     | <span class='neutral'></span>
  8 |     | <span class='neutral'>/**</span>
  9 |     | <span class='neutral'> * @dev Contract module which provides a basic access control mechanism, where</span>
 10 |     | <span class='neutral'> * there is an account (an owner) that can be granted exclusive access to</span>
 11 |     | <span class='neutral'> * specific functions.</span>
 12 |     | <span class='neutral'> *</span>
 13 |     | <span class='neutral'> * By default, the owner account will be the one that deploys the contract. This</span>
 14 |     | <span class='neutral'> * can later be changed with {transferOwnership}.</span>
 15 |     | <span class='neutral'> *</span>
 16 |     | <span class='neutral'> * This module is used through inheritance. It will make available the modifier</span>
 17 |     | <span class='neutral'> * `onlyOwner`, which can be applied to your functions to restrict their use to</span>
 18 |     | <span class='neutral'> * the owner.</span>
 19 |     | <span class='neutral'> */</span>
 20 |     | <span class='neutral'>abstract contract Ownable is Context {</span>
 21 |     | <span class='neutral'>    address private _owner;</span>
 22 |     | <span class='neutral'></span>
 23 |     | <span class='neutral'>    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);</span>
 24 |     | <span class='neutral'></span>
 25 |     | <span class='neutral'>    /**</span>
 26 |     | <span class='neutral'>     * @dev Initializes the contract setting the deployer as the initial owner.</span>
 27 |     | <span class='neutral'>     */</span>
 28 |     | <span class='neutral'>    constructor() {</span>
 29 |     | <span class='unexecuted'>        _transferOwnership(_msgSender());</span>
 30 |     | <span class='neutral'>    }</span>
 31 |     | <span class='neutral'></span>
 32 |     | <span class='neutral'>    /**</span>
 33 |     | <span class='neutral'>     * @dev Throws if called by any account other than the owner.</span>
 34 |     | <span class='neutral'>     */</span>
 35 |     | <span class='neutral'>    modifier onlyOwner() {</span>
 36 |     | <span class='unexecuted'>        _checkOwner();</span>
 37 |     | <span class='neutral'>        _;</span>
 38 |     | <span class='neutral'>    }</span>
 39 |     | <span class='neutral'></span>
 40 |     | <span class='neutral'>    /**</span>
 41 |     | <span class='neutral'>     * @dev Returns the address of the current owner.</span>
 42 |     | <span class='neutral'>     */</span>
 43 |     | <span class='unexecuted'>    function owner() public view virtual returns (address) {</span>
 44 |     | <span class='unexecuted'>        return _owner;</span>
 45 |     | <span class='neutral'>    }</span>
 46 |     | <span class='neutral'></span>
 47 |     | <span class='neutral'>    /**</span>
 48 |     | <span class='neutral'>     * @dev Throws if the sender is not the owner.</span>
 49 |     | <span class='neutral'>     */</span>
 50 |     | <span class='unexecuted'>    function _checkOwner() internal view virtual {</span>
 51 |     | <span class='unexecuted'>        require(owner() == _msgSender(), &quot;Ownable: caller is not the owner&quot;);</span>
 52 |     | <span class='neutral'>    }</span>
 53 |     | <span class='neutral'></span>
 54 |     | <span class='neutral'>    /**</span>
 55 |     | <span class='neutral'>     * @dev Leaves the contract without owner. It will not be possible to call</span>
 56 |     | <span class='neutral'>     * `onlyOwner` functions. Can only be called by the current owner.</span>
 57 |     | <span class='neutral'>     *</span>
 58 |     | <span class='neutral'>     * NOTE: Renouncing ownership will leave the contract without an owner,</span>
 59 |     | <span class='neutral'>     * thereby disabling any functionality that is only available to the owner.</span>
 60 |     | <span class='neutral'>     */</span>
 61 |     | <span class='unexecuted'>    function renounceOwnership() public virtual onlyOwner {</span>
 62 |     | <span class='unexecuted'>        _transferOwnership(address(0));</span>
 63 |     | <span class='neutral'>    }</span>
 64 |     | <span class='neutral'></span>
 65 |     | <span class='neutral'>    /**</span>
 66 |     | <span class='neutral'>     * @dev Transfers ownership of the contract to a new account (`newOwner`).</span>
 67 |     | <span class='neutral'>     * Can only be called by the current owner.</span>
 68 |     | <span class='neutral'>     */</span>
 69 |     | <span class='unexecuted'>    function transferOwnership(address newOwner) public virtual onlyOwner {</span>
 70 |     | <span class='unexecuted'>        require(newOwner != address(0), &quot;Ownable: new owner is the zero address&quot;);</span>
 71 |     | <span class='unexecuted'>        _transferOwnership(newOwner);</span>
 72 |     | <span class='neutral'>    }</span>
 73 |     | <span class='neutral'></span>
 74 |     | <span class='neutral'>    /**</span>
 75 |     | <span class='neutral'>     * @dev Transfers ownership of the contract to a new account (`newOwner`).</span>
 76 |     | <span class='neutral'>     * Internal function without access restriction.</span>
 77 |     | <span class='neutral'>     */</span>
 78 | *   | <span class='executed'>    function _transferOwnership(address newOwner) internal virtual {</span>
 79 | *   | <span class='executed'>        address oldOwner = _owner;</span>
 80 | *   | <span class='executed'>        _owner = newOwner;</span>
 81 |     | <span class='unexecuted'>        emit OwnershipTransferred(oldOwner, newOwner);</span>
 82 |     | <span class='neutral'>    }</span>
 83 |     | <span class='neutral'>}</span>
 84 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/nelsonpereira/Documents/GitHub/Auditing/Fuzzy/Blogs/ElasticSwap_Recon/elasticswap-recon/node_modules/@openzeppelin/contracts/security/ReentrancyGuard.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>// OpenZeppelin Contracts (last updated v4.9.0) (security/ReentrancyGuard.sol)</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>/**</span>
  7 |     | <span class='neutral'> * @dev Contract module that helps prevent reentrant calls to a function.</span>
  8 |     | <span class='neutral'> *</span>
  9 |     | <span class='neutral'> * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier</span>
 10 |     | <span class='neutral'> * available, which can be applied to functions to make sure there are no nested</span>
 11 |     | <span class='neutral'> * (reentrant) calls to them.</span>
 12 |     | <span class='neutral'> *</span>
 13 |     | <span class='neutral'> * Note that because there is a single `nonReentrant` guard, functions marked as</span>
 14 |     | <span class='neutral'> * `nonReentrant` may not call one another. This can be worked around by making</span>
 15 |     | <span class='neutral'> * those functions `private`, and then adding `external` `nonReentrant` entry</span>
 16 |     | <span class='neutral'> * points to them.</span>
 17 |     | <span class='neutral'> *</span>
 18 |     | <span class='neutral'> * TIP: If you would like to learn more about reentrancy and alternative ways</span>
 19 |     | <span class='neutral'> * to protect against it, check out our blog post</span>
 20 |     | <span class='neutral'> * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].</span>
 21 |     | <span class='neutral'> */</span>
 22 |     | <span class='neutral'>abstract contract ReentrancyGuard {</span>
 23 |     | <span class='neutral'>    // Booleans are more expensive than uint256 or any type that takes up a full</span>
 24 |     | <span class='neutral'>    // word because each write operation emits an extra SLOAD to first read the</span>
 25 |     | <span class='neutral'>    // slot&#39;s contents, replace the bits taken up by the boolean, and then write</span>
 26 |     | <span class='neutral'>    // back. This is the compiler&#39;s defense against contract upgrades and</span>
 27 |     | <span class='neutral'>    // pointer aliasing, and it cannot be disabled.</span>
 28 |     | <span class='neutral'></span>
 29 |     | <span class='neutral'>    // The values being non-zero value makes deployment a bit more expensive,</span>
 30 |     | <span class='neutral'>    // but in exchange the refund on every call to nonReentrant will be lower in</span>
 31 |     | <span class='neutral'>    // amount. Since refunds are capped to a percentage of the total</span>
 32 |     | <span class='neutral'>    // transaction&#39;s gas, it is best to keep them low in cases like this one, to</span>
 33 |     | <span class='neutral'>    // increase the likelihood of the full refund coming into effect.</span>
 34 |     | <span class='unexecuted'>    uint256 private constant _NOT_ENTERED = 1;</span>
 35 | *   | <span class='executed'>    uint256 private constant _ENTERED = 2;</span>
 36 |     | <span class='neutral'></span>
 37 |     | <span class='neutral'>    uint256 private _status;</span>
 38 |     | <span class='neutral'></span>
 39 |     | <span class='neutral'>    constructor() {</span>
 40 |     | <span class='unexecuted'>        _status = _NOT_ENTERED;</span>
 41 |     | <span class='neutral'>    }</span>
 42 |     | <span class='neutral'></span>
 43 |     | <span class='neutral'>    /**</span>
 44 |     | <span class='neutral'>     * @dev Prevents a contract from calling itself, directly or indirectly.</span>
 45 |     | <span class='neutral'>     * Calling a `nonReentrant` function from another `nonReentrant`</span>
 46 |     | <span class='neutral'>     * function is not supported. It is possible to prevent this from happening</span>
 47 |     | <span class='neutral'>     * by making the `nonReentrant` function external, and making it call a</span>
 48 |     | <span class='neutral'>     * `private` function that does the actual work.</span>
 49 |     | <span class='neutral'>     */</span>
 50 |     | <span class='neutral'>    modifier nonReentrant() {</span>
 51 | *   | <span class='executed'>        _nonReentrantBefore();</span>
 52 |     | <span class='unexecuted'>        _;</span>
 53 | *   | <span class='executed'>        _nonReentrantAfter();</span>
 54 |     | <span class='neutral'>    }</span>
 55 |     | <span class='neutral'></span>
 56 | *   | <span class='executed'>    function _nonReentrantBefore() private {</span>
 57 |     | <span class='neutral'>        // On the first call to nonReentrant, _status will be _NOT_ENTERED</span>
 58 | *   | <span class='executed'>        require(_status != _ENTERED, &quot;ReentrancyGuard: reentrant call&quot;);</span>
 59 |     | <span class='neutral'></span>
 60 |     | <span class='neutral'>        // Any calls to nonReentrant after this point will fail</span>
 61 | *   | <span class='executed'>        _status = _ENTERED;</span>
 62 |     | <span class='neutral'>    }</span>
 63 |     | <span class='neutral'></span>
 64 | *   | <span class='executed'>    function _nonReentrantAfter() private {</span>
 65 |     | <span class='neutral'>        // By storing the original value once again, a refund is triggered (see</span>
 66 |     | <span class='neutral'>        // https://eips.ethereum.org/EIPS/eip-2200)</span>
 67 | *   | <span class='executed'>        _status = _NOT_ENTERED;</span>
 68 |     | <span class='neutral'>    }</span>
 69 |     | <span class='neutral'></span>
 70 |     | <span class='neutral'>    /**</span>
 71 |     | <span class='neutral'>     * @dev Returns true if the reentrancy guard is currently set to &quot;entered&quot;, which indicates there is a</span>
 72 |     | <span class='neutral'>     * `nonReentrant` function in the call stack.</span>
 73 |     | <span class='neutral'>     */</span>
 74 |     | <span class='neutral'>    function _reentrancyGuardEntered() internal view returns (bool) {</span>
 75 |     | <span class='neutral'>        return _status == _ENTERED;</span>
 76 |     | <span class='neutral'>    }</span>
 77 |     | <span class='neutral'>}</span>
 78 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/nelsonpereira/Documents/GitHub/Auditing/Fuzzy/Blogs/ElasticSwap_Recon/elasticswap-recon/node_modules/@openzeppelin/contracts/token/ERC20/ERC20.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/ERC20.sol)</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
   5 |     | <span class='neutral'></span>
   6 |     | <span class='neutral'>import &quot;./IERC20.sol&quot;;</span>
   7 |     | <span class='neutral'>import &quot;./extensions/IERC20Metadata.sol&quot;;</span>
   8 |     | <span class='neutral'>import &quot;../../utils/Context.sol&quot;;</span>
   9 |     | <span class='neutral'></span>
  10 |     | <span class='neutral'>/**</span>
  11 |     | <span class='neutral'> * @dev Implementation of the {IERC20} interface.</span>
  12 |     | <span class='neutral'> *</span>
  13 |     | <span class='neutral'> * This implementation is agnostic to the way tokens are created. This means</span>
  14 |     | <span class='neutral'> * that a supply mechanism has to be added in a derived contract using {_mint}.</span>
  15 |     | <span class='neutral'> * For a generic mechanism see {ERC20PresetMinterPauser}.</span>
  16 |     | <span class='neutral'> *</span>
  17 |     | <span class='neutral'> * TIP: For a detailed writeup see our guide</span>
  18 |     | <span class='neutral'> * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How</span>
  19 |     | <span class='neutral'> * to implement supply mechanisms].</span>
  20 |     | <span class='neutral'> *</span>
  21 |     | <span class='neutral'> * The default value of {decimals} is 18. To change this, you should override</span>
  22 |     | <span class='neutral'> * this function so it returns a different value.</span>
  23 |     | <span class='neutral'> *</span>
  24 |     | <span class='neutral'> * We have followed general OpenZeppelin Contracts guidelines: functions revert</span>
  25 |     | <span class='neutral'> * instead returning `false` on failure. This behavior is nonetheless</span>
  26 |     | <span class='neutral'> * conventional and does not conflict with the expectations of ERC20</span>
  27 |     | <span class='neutral'> * applications.</span>
  28 |     | <span class='neutral'> *</span>
  29 |     | <span class='neutral'> * Additionally, an {Approval} event is emitted on calls to {transferFrom}.</span>
  30 |     | <span class='neutral'> * This allows applications to reconstruct the allowance for all accounts just</span>
  31 |     | <span class='neutral'> * by listening to said events. Other implementations of the EIP may not emit</span>
  32 |     | <span class='neutral'> * these events, as it isn&#39;t required by the specification.</span>
  33 |     | <span class='neutral'> *</span>
  34 |     | <span class='neutral'> * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}</span>
  35 |     | <span class='neutral'> * functions have been added to mitigate the well-known issues around setting</span>
  36 |     | <span class='neutral'> * allowances. See {IERC20-approve}.</span>
  37 |     | <span class='neutral'> */</span>
  38 |     | <span class='unexecuted'>contract ERC20 is Context, IERC20, IERC20Metadata {</span>
  39 |     | <span class='neutral'>    mapping(address =&gt; uint256) private _balances;</span>
  40 |     | <span class='neutral'></span>
  41 |     | <span class='neutral'>    mapping(address =&gt; mapping(address =&gt; uint256)) private _allowances;</span>
  42 |     | <span class='neutral'></span>
  43 |     | <span class='neutral'>    uint256 private _totalSupply;</span>
  44 |     | <span class='neutral'></span>
  45 |     | <span class='neutral'>    string private _name;</span>
  46 |     | <span class='neutral'>    string private _symbol;</span>
  47 |     | <span class='neutral'></span>
  48 |     | <span class='neutral'>    /**</span>
  49 |     | <span class='neutral'>     * @dev Sets the values for {name} and {symbol}.</span>
  50 |     | <span class='neutral'>     *</span>
  51 |     | <span class='neutral'>     * All two of these values are immutable: they can only be set once during</span>
  52 |     | <span class='neutral'>     * construction.</span>
  53 |     | <span class='neutral'>     */</span>
  54 |     | <span class='unexecuted'>    constructor(string memory name_, string memory symbol_) {</span>
  55 |     | <span class='unexecuted'>        _name = name_;</span>
  56 |     | <span class='unexecuted'>        _symbol = symbol_;</span>
  57 |     | <span class='neutral'>    }</span>
  58 |     | <span class='neutral'></span>
  59 |     | <span class='neutral'>    /**</span>
  60 |     | <span class='neutral'>     * @dev Returns the name of the token.</span>
  61 |     | <span class='neutral'>     */</span>
  62 | *   | <span class='executed'>    function name() public view virtual override returns (string memory) {</span>
  63 | *   | <span class='executed'>        return _name;</span>
  64 |     | <span class='neutral'>    }</span>
  65 |     | <span class='neutral'></span>
  66 |     | <span class='neutral'>    /**</span>
  67 |     | <span class='neutral'>     * @dev Returns the symbol of the token, usually a shorter version of the</span>
  68 |     | <span class='neutral'>     * name.</span>
  69 |     | <span class='neutral'>     */</span>
  70 | *   | <span class='executed'>    function symbol() public view virtual override returns (string memory) {</span>
  71 | *   | <span class='executed'>        return _symbol;</span>
  72 |     | <span class='neutral'>    }</span>
  73 |     | <span class='neutral'></span>
  74 |     | <span class='neutral'>    /**</span>
  75 |     | <span class='neutral'>     * @dev Returns the number of decimals used to get its user representation.</span>
  76 |     | <span class='neutral'>     * For example, if `decimals` equals `2`, a balance of `505` tokens should</span>
  77 |     | <span class='neutral'>     * be displayed to a user as `5.05` (`505 / 10 ** 2`).</span>
  78 |     | <span class='neutral'>     *</span>
  79 |     | <span class='neutral'>     * Tokens usually opt for a value of 18, imitating the relationship between</span>
  80 |     | <span class='neutral'>     * Ether and Wei. This is the default value returned by this function, unless</span>
  81 |     | <span class='neutral'>     * it&#39;s overridden.</span>
  82 |     | <span class='neutral'>     *</span>
  83 |     | <span class='neutral'>     * NOTE: This information is only used for _display_ purposes: it in</span>
  84 |     | <span class='neutral'>     * no way affects any of the arithmetic of the contract, including</span>
  85 |     | <span class='neutral'>     * {IERC20-balanceOf} and {IERC20-transfer}.</span>
  86 |     | <span class='neutral'>     */</span>
  87 |     | <span class='unexecuted'>    function decimals() public view virtual override returns (uint8) {</span>
  88 |     | <span class='unexecuted'>        return 18;</span>
  89 |     | <span class='neutral'>    }</span>
  90 |     | <span class='neutral'></span>
  91 |     | <span class='neutral'>    /**</span>
  92 |     | <span class='neutral'>     * @dev See {IERC20-totalSupply}.</span>
  93 |     | <span class='neutral'>     */</span>
  94 | *   | <span class='executed'>    function totalSupply() public view virtual override returns (uint256) {</span>
  95 | *   | <span class='executed'>        return _totalSupply;</span>
  96 |     | <span class='neutral'>    }</span>
  97 |     | <span class='neutral'></span>
  98 |     | <span class='neutral'>    /**</span>
  99 |     | <span class='neutral'>     * @dev See {IERC20-balanceOf}.</span>
 100 |     | <span class='neutral'>     */</span>
 101 | *   | <span class='executed'>    function balanceOf(address account) public view virtual override returns (uint256) {</span>
 102 | *   | <span class='executed'>        return _balances[account];</span>
 103 |     | <span class='neutral'>    }</span>
 104 |     | <span class='neutral'></span>
 105 |     | <span class='neutral'>    /**</span>
 106 |     | <span class='neutral'>     * @dev See {IERC20-transfer}.</span>
 107 |     | <span class='neutral'>     *</span>
 108 |     | <span class='neutral'>     * Requirements:</span>
 109 |     | <span class='neutral'>     *</span>
 110 |     | <span class='neutral'>     * - `to` cannot be the zero address.</span>
 111 |     | <span class='neutral'>     * - the caller must have a balance of at least `amount`.</span>
 112 |     | <span class='neutral'>     */</span>
 113 | *   | <span class='executed'>    function transfer(address to, uint256 amount) public virtual override returns (bool) {</span>
 114 |     | <span class='neutral'>        address owner = _msgSender();</span>
 115 | *   | <span class='executed'>        _transfer(owner, to, amount);</span>
 116 |     | <span class='neutral'>        return true;</span>
 117 |     | <span class='neutral'>    }</span>
 118 |     | <span class='neutral'></span>
 119 |     | <span class='neutral'>    /**</span>
 120 |     | <span class='neutral'>     * @dev See {IERC20-allowance}.</span>
 121 |     | <span class='neutral'>     */</span>
 122 | *   | <span class='executed'>    function allowance(address owner, address spender) public view virtual override returns (uint256) {</span>
 123 | *   | <span class='executed'>        return _allowances[owner][spender];</span>
 124 |     | <span class='neutral'>    }</span>
 125 |     | <span class='neutral'></span>
 126 |     | <span class='neutral'>    /**</span>
 127 |     | <span class='neutral'>     * @dev See {IERC20-approve}.</span>
 128 |     | <span class='neutral'>     *</span>
 129 |     | <span class='neutral'>     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on</span>
 130 |     | <span class='neutral'>     * `transferFrom`. This is semantically equivalent to an infinite approval.</span>
 131 |     | <span class='neutral'>     *</span>
 132 |     | <span class='neutral'>     * Requirements:</span>
 133 |     | <span class='neutral'>     *</span>
 134 |     | <span class='neutral'>     * - `spender` cannot be the zero address.</span>
 135 |     | <span class='neutral'>     */</span>
 136 | *   | <span class='executed'>    function approve(address spender, uint256 amount) public virtual override returns (bool) {</span>
 137 |     | <span class='neutral'>        address owner = _msgSender();</span>
 138 | *   | <span class='executed'>        _approve(owner, spender, amount);</span>
 139 | *   | <span class='executed'>        return true;</span>
 140 |     | <span class='neutral'>    }</span>
 141 |     | <span class='neutral'></span>
 142 |     | <span class='neutral'>    /**</span>
 143 |     | <span class='neutral'>     * @dev See {IERC20-transferFrom}.</span>
 144 |     | <span class='neutral'>     *</span>
 145 |     | <span class='neutral'>     * Emits an {Approval} event indicating the updated allowance. This is not</span>
 146 |     | <span class='neutral'>     * required by the EIP. See the note at the beginning of {ERC20}.</span>
 147 |     | <span class='neutral'>     *</span>
 148 |     | <span class='neutral'>     * NOTE: Does not update the allowance if the current allowance</span>
 149 |     | <span class='neutral'>     * is the maximum `uint256`.</span>
 150 |     | <span class='neutral'>     *</span>
 151 |     | <span class='neutral'>     * Requirements:</span>
 152 |     | <span class='neutral'>     *</span>
 153 |     | <span class='neutral'>     * - `from` and `to` cannot be the zero address.</span>
 154 |     | <span class='neutral'>     * - `from` must have a balance of at least `amount`.</span>
 155 |     | <span class='neutral'>     * - the caller must have allowance for ``from``&#39;s tokens of at least</span>
 156 |     | <span class='neutral'>     * `amount`.</span>
 157 |     | <span class='neutral'>     */</span>
 158 | *   | <span class='executed'>    function transferFrom(address from, address to, uint256 amount) public virtual override returns (bool) {</span>
 159 |     | <span class='neutral'>        address spender = _msgSender();</span>
 160 | *   | <span class='executed'>        _spendAllowance(from, spender, amount);</span>
 161 |     | <span class='unexecuted'>        _transfer(from, to, amount);</span>
 162 | *   | <span class='executed'>        return true;</span>
 163 |     | <span class='neutral'>    }</span>
 164 |     | <span class='neutral'></span>
 165 |     | <span class='neutral'>    /**</span>
 166 |     | <span class='neutral'>     * @dev Atomically increases the allowance granted to `spender` by the caller.</span>
 167 |     | <span class='neutral'>     *</span>
 168 |     | <span class='neutral'>     * This is an alternative to {approve} that can be used as a mitigation for</span>
 169 |     | <span class='neutral'>     * problems described in {IERC20-approve}.</span>
 170 |     | <span class='neutral'>     *</span>
 171 |     | <span class='neutral'>     * Emits an {Approval} event indicating the updated allowance.</span>
 172 |     | <span class='neutral'>     *</span>
 173 |     | <span class='neutral'>     * Requirements:</span>
 174 |     | <span class='neutral'>     *</span>
 175 |     | <span class='neutral'>     * - `spender` cannot be the zero address.</span>
 176 |     | <span class='neutral'>     */</span>
 177 |     | <span class='unexecuted'>    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {</span>
 178 |     | <span class='neutral'>        address owner = _msgSender();</span>
 179 |     | <span class='unexecuted'>        _approve(owner, spender, allowance(owner, spender) + addedValue);</span>
 180 |     | <span class='neutral'>        return true;</span>
 181 |     | <span class='neutral'>    }</span>
 182 |     | <span class='neutral'></span>
 183 |     | <span class='neutral'>    /**</span>
 184 |     | <span class='neutral'>     * @dev Atomically decreases the allowance granted to `spender` by the caller.</span>
 185 |     | <span class='neutral'>     *</span>
 186 |     | <span class='neutral'>     * This is an alternative to {approve} that can be used as a mitigation for</span>
 187 |     | <span class='neutral'>     * problems described in {IERC20-approve}.</span>
 188 |     | <span class='neutral'>     *</span>
 189 |     | <span class='neutral'>     * Emits an {Approval} event indicating the updated allowance.</span>
 190 |     | <span class='neutral'>     *</span>
 191 |     | <span class='neutral'>     * Requirements:</span>
 192 |     | <span class='neutral'>     *</span>
 193 |     | <span class='neutral'>     * - `spender` cannot be the zero address.</span>
 194 |     | <span class='neutral'>     * - `spender` must have allowance for the caller of at least</span>
 195 |     | <span class='neutral'>     * `subtractedValue`.</span>
 196 |     | <span class='neutral'>     */</span>
 197 | *   | <span class='executed'>    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {</span>
 198 |     | <span class='neutral'>        address owner = _msgSender();</span>
 199 |     | <span class='unexecuted'>        uint256 currentAllowance = allowance(owner, spender);</span>
 200 | *   | <span class='executed'>        require(currentAllowance &gt;= subtractedValue, &quot;ERC20: decreased allowance below zero&quot;);</span>
 201 |     | <span class='neutral'>        unchecked {</span>
 202 | *   | <span class='executed'>            _approve(owner, spender, currentAllowance - subtractedValue);</span>
 203 |     | <span class='neutral'>        }</span>
 204 |     | <span class='neutral'></span>
 205 |     | <span class='neutral'>        return true;</span>
 206 |     | <span class='neutral'>    }</span>
 207 |     | <span class='neutral'></span>
 208 |     | <span class='neutral'>    /**</span>
 209 |     | <span class='neutral'>     * @dev Moves `amount` of tokens from `from` to `to`.</span>
 210 |     | <span class='neutral'>     *</span>
 211 |     | <span class='neutral'>     * This internal function is equivalent to {transfer}, and can be used to</span>
 212 |     | <span class='neutral'>     * e.g. implement automatic token fees, slashing mechanisms, etc.</span>
 213 |     | <span class='neutral'>     *</span>
 214 |     | <span class='neutral'>     * Emits a {Transfer} event.</span>
 215 |     | <span class='neutral'>     *</span>
 216 |     | <span class='neutral'>     * Requirements:</span>
 217 |     | <span class='neutral'>     *</span>
 218 |     | <span class='neutral'>     * - `from` cannot be the zero address.</span>
 219 |     | <span class='neutral'>     * - `to` cannot be the zero address.</span>
 220 |     | <span class='neutral'>     * - `from` must have a balance of at least `amount`.</span>
 221 |     | <span class='neutral'>     */</span>
 222 | *   | <span class='executed'>    function _transfer(address from, address to, uint256 amount) internal virtual {</span>
 223 | *   | <span class='executed'>        require(from != address(0), &quot;ERC20: transfer from the zero address&quot;);</span>
 224 | *   | <span class='executed'>        require(to != address(0), &quot;ERC20: transfer to the zero address&quot;);</span>
 225 |     | <span class='neutral'></span>
 226 |     | <span class='neutral'>        _beforeTokenTransfer(from, to, amount);</span>
 227 |     | <span class='neutral'></span>
 228 | *   | <span class='executed'>        uint256 fromBalance = _balances[from];</span>
 229 | *   | <span class='executed'>        require(fromBalance &gt;= amount, &quot;ERC20: transfer amount exceeds balance&quot;);</span>
 230 |     | <span class='neutral'>        unchecked {</span>
 231 | *   | <span class='executed'>            _balances[from] = fromBalance - amount;</span>
 232 |     | <span class='neutral'>            // Overflow not possible: the sum of all balances is capped by totalSupply, and the sum is preserved by</span>
 233 |     | <span class='neutral'>            // decrementing then incrementing.</span>
 234 | *   | <span class='executed'>            _balances[to] += amount;</span>
 235 |     | <span class='neutral'>        }</span>
 236 |     | <span class='neutral'></span>
 237 | *   | <span class='executed'>        emit Transfer(from, to, amount);</span>
 238 |     | <span class='neutral'></span>
 239 | *   | <span class='executed'>        _afterTokenTransfer(from, to, amount);</span>
 240 |     | <span class='neutral'>    }</span>
 241 |     | <span class='neutral'></span>
 242 |     | <span class='neutral'>    /** @dev Creates `amount` tokens and assigns them to `account`, increasing</span>
 243 |     | <span class='neutral'>     * the total supply.</span>
 244 |     | <span class='neutral'>     *</span>
 245 |     | <span class='neutral'>     * Emits a {Transfer} event with `from` set to the zero address.</span>
 246 |     | <span class='neutral'>     *</span>
 247 |     | <span class='neutral'>     * Requirements:</span>
 248 |     | <span class='neutral'>     *</span>
 249 |     | <span class='neutral'>     * - `account` cannot be the zero address.</span>
 250 |     | <span class='neutral'>     */</span>
 251 | *   | <span class='executed'>    function _mint(address account, uint256 amount) internal virtual {</span>
 252 | *   | <span class='executed'>        require(account != address(0), &quot;ERC20: mint to the zero address&quot;);</span>
 253 |     | <span class='neutral'></span>
 254 |     | <span class='neutral'>        _beforeTokenTransfer(address(0), account, amount);</span>
 255 |     | <span class='neutral'></span>
 256 | *   | <span class='executed'>        _totalSupply += amount;</span>
 257 |     | <span class='neutral'>        unchecked {</span>
 258 |     | <span class='neutral'>            // Overflow not possible: balance + amount is at most totalSupply + amount, which is checked above.</span>
 259 |     | <span class='unexecuted'>            _balances[account] += amount;</span>
 260 |     | <span class='neutral'>        }</span>
 261 | *   | <span class='executed'>        emit Transfer(address(0), account, amount);</span>
 262 |     | <span class='neutral'></span>
 263 |     | <span class='neutral'>        _afterTokenTransfer(address(0), account, amount);</span>
 264 |     | <span class='neutral'>    }</span>
 265 |     | <span class='neutral'></span>
 266 |     | <span class='neutral'>    /**</span>
 267 |     | <span class='neutral'>     * @dev Destroys `amount` tokens from `account`, reducing the</span>
 268 |     | <span class='neutral'>     * total supply.</span>
 269 |     | <span class='neutral'>     *</span>
 270 |     | <span class='neutral'>     * Emits a {Transfer} event with `to` set to the zero address.</span>
 271 |     | <span class='neutral'>     *</span>
 272 |     | <span class='neutral'>     * Requirements:</span>
 273 |     | <span class='neutral'>     *</span>
 274 |     | <span class='neutral'>     * - `account` cannot be the zero address.</span>
 275 |     | <span class='neutral'>     * - `account` must have at least `amount` tokens.</span>
 276 |     | <span class='neutral'>     */</span>
 277 |     | <span class='unexecuted'>    function _burn(address account, uint256 amount) internal virtual {</span>
 278 | *   | <span class='executed'>        require(account != address(0), &quot;ERC20: burn from the zero address&quot;);</span>
 279 |     | <span class='neutral'></span>
 280 |     | <span class='neutral'>        _beforeTokenTransfer(account, address(0), amount);</span>
 281 |     | <span class='neutral'></span>
 282 | *   | <span class='executed'>        uint256 accountBalance = _balances[account];</span>
 283 | *   | <span class='executed'>        require(accountBalance &gt;= amount, &quot;ERC20: burn amount exceeds balance&quot;);</span>
 284 |     | <span class='neutral'>        unchecked {</span>
 285 | *   | <span class='executed'>            _balances[account] = accountBalance - amount;</span>
 286 |     | <span class='neutral'>            // Overflow not possible: amount &lt;= accountBalance &lt;= totalSupply.</span>
 287 | *   | <span class='executed'>            _totalSupply -= amount;</span>
 288 |     | <span class='neutral'>        }</span>
 289 |     | <span class='neutral'></span>
 290 | *   | <span class='executed'>        emit Transfer(account, address(0), amount);</span>
 291 |     | <span class='neutral'></span>
 292 |     | <span class='neutral'>        _afterTokenTransfer(account, address(0), amount);</span>
 293 |     | <span class='neutral'>    }</span>
 294 |     | <span class='neutral'></span>
 295 |     | <span class='neutral'>    /**</span>
 296 |     | <span class='neutral'>     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.</span>
 297 |     | <span class='neutral'>     *</span>
 298 |     | <span class='neutral'>     * This internal function is equivalent to `approve`, and can be used to</span>
 299 |     | <span class='neutral'>     * e.g. set automatic allowances for certain subsystems, etc.</span>
 300 |     | <span class='neutral'>     *</span>
 301 |     | <span class='neutral'>     * Emits an {Approval} event.</span>
 302 |     | <span class='neutral'>     *</span>
 303 |     | <span class='neutral'>     * Requirements:</span>
 304 |     | <span class='neutral'>     *</span>
 305 |     | <span class='neutral'>     * - `owner` cannot be the zero address.</span>
 306 |     | <span class='neutral'>     * - `spender` cannot be the zero address.</span>
 307 |     | <span class='neutral'>     */</span>
 308 | *   | <span class='executed'>    function _approve(address owner, address spender, uint256 amount) internal virtual {</span>
 309 | *   | <span class='executed'>        require(owner != address(0), &quot;ERC20: approve from the zero address&quot;);</span>
 310 | *   | <span class='executed'>        require(spender != address(0), &quot;ERC20: approve to the zero address&quot;);</span>
 311 |     | <span class='neutral'></span>
 312 | *   | <span class='executed'>        _allowances[owner][spender] = amount;</span>
 313 | *   | <span class='executed'>        emit Approval(owner, spender, amount);</span>
 314 |     | <span class='neutral'>    }</span>
 315 |     | <span class='neutral'></span>
 316 |     | <span class='neutral'>    /**</span>
 317 |     | <span class='neutral'>     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.</span>
 318 |     | <span class='neutral'>     *</span>
 319 |     | <span class='neutral'>     * Does not update the allowance amount in case of infinite allowance.</span>
 320 |     | <span class='neutral'>     * Revert if not enough allowance is available.</span>
 321 |     | <span class='neutral'>     *</span>
 322 |     | <span class='neutral'>     * Might emit an {Approval} event.</span>
 323 |     | <span class='neutral'>     */</span>
 324 | *   | <span class='executed'>    function _spendAllowance(address owner, address spender, uint256 amount) internal virtual {</span>
 325 | *   | <span class='executed'>        uint256 currentAllowance = allowance(owner, spender);</span>
 326 |     | <span class='unexecuted'>        if (currentAllowance != type(uint256).max) {</span>
 327 | *   | <span class='executed'>            require(currentAllowance &gt;= amount, &quot;ERC20: insufficient allowance&quot;);</span>
 328 |     | <span class='neutral'>            unchecked {</span>
 329 | *   | <span class='executed'>                _approve(owner, spender, currentAllowance - amount);</span>
 330 |     | <span class='neutral'>            }</span>
 331 |     | <span class='neutral'>        }</span>
 332 |     | <span class='neutral'>    }</span>
 333 |     | <span class='neutral'></span>
 334 |     | <span class='neutral'>    /**</span>
 335 |     | <span class='neutral'>     * @dev Hook that is called before any transfer of tokens. This includes</span>
 336 |     | <span class='neutral'>     * minting and burning.</span>
 337 |     | <span class='neutral'>     *</span>
 338 |     | <span class='neutral'>     * Calling conditions:</span>
 339 |     | <span class='neutral'>     *</span>
 340 |     | <span class='neutral'>     * - when `from` and `to` are both non-zero, `amount` of ``from``&#39;s tokens</span>
 341 |     | <span class='neutral'>     * will be transferred to `to`.</span>
 342 |     | <span class='neutral'>     * - when `from` is zero, `amount` tokens will be minted for `to`.</span>
 343 |     | <span class='neutral'>     * - when `to` is zero, `amount` of ``from``&#39;s tokens will be burned.</span>
 344 |     | <span class='neutral'>     * - `from` and `to` are never both zero.</span>
 345 |     | <span class='neutral'>     *</span>
 346 |     | <span class='neutral'>     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].</span>
 347 |     | <span class='neutral'>     */</span>
 348 |     | <span class='unexecuted'>    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual {}</span>
 349 |     | <span class='neutral'></span>
 350 |     | <span class='neutral'>    /**</span>
 351 |     | <span class='neutral'>     * @dev Hook that is called after any transfer of tokens. This includes</span>
 352 |     | <span class='neutral'>     * minting and burning.</span>
 353 |     | <span class='neutral'>     *</span>
 354 |     | <span class='neutral'>     * Calling conditions:</span>
 355 |     | <span class='neutral'>     *</span>
 356 |     | <span class='neutral'>     * - when `from` and `to` are both non-zero, `amount` of ``from``&#39;s tokens</span>
 357 |     | <span class='neutral'>     * has been transferred to `to`.</span>
 358 |     | <span class='neutral'>     * - when `from` is zero, `amount` tokens have been minted for `to`.</span>
 359 |     | <span class='neutral'>     * - when `to` is zero, `amount` of ``from``&#39;s tokens have been burned.</span>
 360 |     | <span class='neutral'>     * - `from` and `to` are never both zero.</span>
 361 |     | <span class='neutral'>     *</span>
 362 |     | <span class='neutral'>     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].</span>
 363 |     | <span class='neutral'>     */</span>
 364 |     | <span class='neutral'>    function _afterTokenTransfer(address from, address to, uint256 amount) internal virtual {}</span>
 365 |     | <span class='neutral'>}</span>
 366 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/nelsonpereira/Documents/GitHub/Auditing/Fuzzy/Blogs/ElasticSwap_Recon/elasticswap-recon/node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>/**</span>
  7 |     | <span class='neutral'> * @dev Interface of the ERC20 standard as defined in the EIP.</span>
  8 |     | <span class='neutral'> */</span>
  9 |     | <span class='neutral'>interface IERC20 {</span>
 10 |     | <span class='neutral'>    /**</span>
 11 |     | <span class='neutral'>     * @dev Emitted when `value` tokens are moved from one account (`from`) to</span>
 12 |     | <span class='neutral'>     * another (`to`).</span>
 13 |     | <span class='neutral'>     *</span>
 14 |     | <span class='neutral'>     * Note that `value` may be zero.</span>
 15 |     | <span class='neutral'>     */</span>
 16 |     | <span class='neutral'>    event Transfer(address indexed from, address indexed to, uint256 value);</span>
 17 |     | <span class='neutral'></span>
 18 |     | <span class='neutral'>    /**</span>
 19 |     | <span class='neutral'>     * @dev Emitted when the allowance of a `spender` for an `owner` is set by</span>
 20 |     | <span class='neutral'>     * a call to {approve}. `value` is the new allowance.</span>
 21 |     | <span class='neutral'>     */</span>
 22 |     | <span class='neutral'>    event Approval(address indexed owner, address indexed spender, uint256 value);</span>
 23 |     | <span class='neutral'></span>
 24 |     | <span class='neutral'>    /**</span>
 25 |     | <span class='neutral'>     * @dev Returns the amount of tokens in existence.</span>
 26 |     | <span class='neutral'>     */</span>
 27 |     | <span class='neutral'>    function totalSupply() external view returns (uint256);</span>
 28 |     | <span class='neutral'></span>
 29 |     | <span class='neutral'>    /**</span>
 30 |     | <span class='neutral'>     * @dev Returns the amount of tokens owned by `account`.</span>
 31 |     | <span class='neutral'>     */</span>
 32 |     | <span class='neutral'>    function balanceOf(address account) external view returns (uint256);</span>
 33 |     | <span class='neutral'></span>
 34 |     | <span class='neutral'>    /**</span>
 35 |     | <span class='neutral'>     * @dev Moves `amount` tokens from the caller&#39;s account to `to`.</span>
 36 |     | <span class='neutral'>     *</span>
 37 |     | <span class='neutral'>     * Returns a boolean value indicating whether the operation succeeded.</span>
 38 |     | <span class='neutral'>     *</span>
 39 |     | <span class='neutral'>     * Emits a {Transfer} event.</span>
 40 |     | <span class='neutral'>     */</span>
 41 |     | <span class='neutral'>    function transfer(address to, uint256 amount) external returns (bool);</span>
 42 |     | <span class='neutral'></span>
 43 |     | <span class='neutral'>    /**</span>
 44 |     | <span class='neutral'>     * @dev Returns the remaining number of tokens that `spender` will be</span>
 45 |     | <span class='neutral'>     * allowed to spend on behalf of `owner` through {transferFrom}. This is</span>
 46 |     | <span class='neutral'>     * zero by default.</span>
 47 |     | <span class='neutral'>     *</span>
 48 |     | <span class='neutral'>     * This value changes when {approve} or {transferFrom} are called.</span>
 49 |     | <span class='neutral'>     */</span>
 50 |     | <span class='neutral'>    function allowance(address owner, address spender) external view returns (uint256);</span>
 51 |     | <span class='neutral'></span>
 52 |     | <span class='neutral'>    /**</span>
 53 |     | <span class='neutral'>     * @dev Sets `amount` as the allowance of `spender` over the caller&#39;s tokens.</span>
 54 |     | <span class='neutral'>     *</span>
 55 |     | <span class='neutral'>     * Returns a boolean value indicating whether the operation succeeded.</span>
 56 |     | <span class='neutral'>     *</span>
 57 |     | <span class='neutral'>     * IMPORTANT: Beware that changing an allowance with this method brings the risk</span>
 58 |     | <span class='neutral'>     * that someone may use both the old and the new allowance by unfortunate</span>
 59 |     | <span class='neutral'>     * transaction ordering. One possible solution to mitigate this race</span>
 60 |     | <span class='neutral'>     * condition is to first reduce the spender&#39;s allowance to 0 and set the</span>
 61 |     | <span class='neutral'>     * desired value afterwards:</span>
 62 |     | <span class='neutral'>     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729</span>
 63 |     | <span class='neutral'>     *</span>
 64 |     | <span class='neutral'>     * Emits an {Approval} event.</span>
 65 |     | <span class='neutral'>     */</span>
 66 |     | <span class='neutral'>    function approve(address spender, uint256 amount) external returns (bool);</span>
 67 |     | <span class='neutral'></span>
 68 |     | <span class='neutral'>    /**</span>
 69 |     | <span class='neutral'>     * @dev Moves `amount` tokens from `from` to `to` using the</span>
 70 |     | <span class='neutral'>     * allowance mechanism. `amount` is then deducted from the caller&#39;s</span>
 71 |     | <span class='neutral'>     * allowance.</span>
 72 |     | <span class='neutral'>     *</span>
 73 |     | <span class='neutral'>     * Returns a boolean value indicating whether the operation succeeded.</span>
 74 |     | <span class='neutral'>     *</span>
 75 |     | <span class='neutral'>     * Emits a {Transfer} event.</span>
 76 |     | <span class='neutral'>     */</span>
 77 |     | <span class='neutral'>    function transferFrom(address from, address to, uint256 amount) external returns (bool);</span>
 78 |     | <span class='neutral'>}</span>
 79 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/nelsonpereira/Documents/GitHub/Auditing/Fuzzy/Blogs/ElasticSwap_Recon/elasticswap-recon/node_modules/@openzeppelin/contracts/token/ERC20/extensions/ERC20Burnable.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/extensions/ERC20Burnable.sol)</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>import &quot;../ERC20.sol&quot;;</span>
  7 |     | <span class='neutral'>import &quot;../../../utils/Context.sol&quot;;</span>
  8 |     | <span class='neutral'></span>
  9 |     | <span class='neutral'>/**</span>
 10 |     | <span class='neutral'> * @dev Extension of {ERC20} that allows token holders to destroy both their own</span>
 11 |     | <span class='neutral'> * tokens and those that they have an allowance for, in a way that can be</span>
 12 |     | <span class='neutral'> * recognized off-chain (via event analysis).</span>
 13 |     | <span class='neutral'> */</span>
 14 |     | <span class='neutral'>abstract contract ERC20Burnable is Context, ERC20 {</span>
 15 |     | <span class='neutral'>    /**</span>
 16 |     | <span class='neutral'>     * @dev Destroys `amount` tokens from the caller.</span>
 17 |     | <span class='neutral'>     *</span>
 18 |     | <span class='neutral'>     * See {ERC20-_burn}.</span>
 19 |     | <span class='neutral'>     */</span>
 20 |     | <span class='unexecuted'>    function burn(uint256 amount) public virtual {</span>
 21 |     | <span class='unexecuted'>        _burn(_msgSender(), amount);</span>
 22 |     | <span class='neutral'>    }</span>
 23 |     | <span class='neutral'></span>
 24 |     | <span class='neutral'>    /**</span>
 25 |     | <span class='neutral'>     * @dev Destroys `amount` tokens from `account`, deducting from the caller&#39;s</span>
 26 |     | <span class='neutral'>     * allowance.</span>
 27 |     | <span class='neutral'>     *</span>
 28 |     | <span class='neutral'>     * See {ERC20-_burn} and {ERC20-allowance}.</span>
 29 |     | <span class='neutral'>     *</span>
 30 |     | <span class='neutral'>     * Requirements:</span>
 31 |     | <span class='neutral'>     *</span>
 32 |     | <span class='neutral'>     * - the caller must have allowance for ``accounts``&#39;s tokens of at least</span>
 33 |     | <span class='neutral'>     * `amount`.</span>
 34 |     | <span class='neutral'>     */</span>
 35 |     | <span class='unexecuted'>    function burnFrom(address account, uint256 amount) public virtual {</span>
 36 |     | <span class='unexecuted'>        _spendAllowance(account, _msgSender(), amount);</span>
 37 | *   | <span class='executed'>        _burn(account, amount);</span>
 38 |     | <span class='neutral'>    }</span>
 39 |     | <span class='neutral'>}</span>
 40 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/nelsonpereira/Documents/GitHub/Auditing/Fuzzy/Blogs/ElasticSwap_Recon/elasticswap-recon/node_modules/@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>import &quot;../IERC20.sol&quot;;</span>
  7 |     | <span class='neutral'></span>
  8 |     | <span class='neutral'>/**</span>
  9 |     | <span class='neutral'> * @dev Interface for the optional metadata functions from the ERC20 standard.</span>
 10 |     | <span class='neutral'> *</span>
 11 |     | <span class='neutral'> * _Available since v4.1._</span>
 12 |     | <span class='neutral'> */</span>
 13 |     | <span class='neutral'>interface IERC20Metadata is IERC20 {</span>
 14 |     | <span class='neutral'>    /**</span>
 15 |     | <span class='neutral'>     * @dev Returns the name of the token.</span>
 16 |     | <span class='neutral'>     */</span>
 17 |     | <span class='neutral'>    function name() external view returns (string memory);</span>
 18 |     | <span class='neutral'></span>
 19 |     | <span class='neutral'>    /**</span>
 20 |     | <span class='neutral'>     * @dev Returns the symbol of the token.</span>
 21 |     | <span class='neutral'>     */</span>
 22 |     | <span class='neutral'>    function symbol() external view returns (string memory);</span>
 23 |     | <span class='neutral'></span>
 24 |     | <span class='neutral'>    /**</span>
 25 |     | <span class='neutral'>     * @dev Returns the decimals places of the token.</span>
 26 |     | <span class='neutral'>     */</span>
 27 |     | <span class='neutral'>    function decimals() external view returns (uint8);</span>
 28 |     | <span class='neutral'>}</span>
 29 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/nelsonpereira/Documents/GitHub/Auditing/Fuzzy/Blogs/ElasticSwap_Recon/elasticswap-recon/node_modules/@openzeppelin/contracts/token/ERC20/extensions/IERC20Permit.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>// OpenZeppelin Contracts (last updated v4.9.4) (token/ERC20/extensions/IERC20Permit.sol)</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>/**</span>
  7 |     | <span class='neutral'> * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in</span>
  8 |     | <span class='neutral'> * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].</span>
  9 |     | <span class='neutral'> *</span>
 10 |     | <span class='neutral'> * Adds the {permit} method, which can be used to change an account&#39;s ERC20 allowance (see {IERC20-allowance}) by</span>
 11 |     | <span class='neutral'> * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn&#39;t</span>
 12 |     | <span class='neutral'> * need to send a transaction, and thus is not required to hold Ether at all.</span>
 13 |     | <span class='neutral'> *</span>
 14 |     | <span class='neutral'> * ==== Security Considerations</span>
 15 |     | <span class='neutral'> *</span>
 16 |     | <span class='neutral'> * There are two important considerations concerning the use of `permit`. The first is that a valid permit signature</span>
 17 |     | <span class='neutral'> * expresses an allowance, and it should not be assumed to convey additional meaning. In particular, it should not be</span>
 18 |     | <span class='neutral'> * considered as an intention to spend the allowance in any specific way. The second is that because permits have</span>
 19 |     | <span class='neutral'> * built-in replay protection and can be submitted by anyone, they can be frontrun. A protocol that uses permits should</span>
 20 |     | <span class='neutral'> * take this into consideration and allow a `permit` call to fail. Combining these two aspects, a pattern that may be</span>
 21 |     | <span class='neutral'> * generally recommended is:</span>
 22 |     | <span class='neutral'> *</span>
 23 |     | <span class='neutral'> * ```solidity</span>
 24 |     | <span class='neutral'> * function doThingWithPermit(..., uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) public {</span>
 25 |     | <span class='neutral'> *     try token.permit(msg.sender, address(this), value, deadline, v, r, s) {} catch {}</span>
 26 |     | <span class='neutral'> *     doThing(..., value);</span>
 27 |     | <span class='neutral'> * }</span>
 28 |     | <span class='neutral'> *</span>
 29 |     | <span class='neutral'> * function doThing(..., uint256 value) public {</span>
 30 |     | <span class='neutral'> *     token.safeTransferFrom(msg.sender, address(this), value);</span>
 31 |     | <span class='neutral'> *     ...</span>
 32 |     | <span class='neutral'> * }</span>
 33 |     | <span class='neutral'> * ```</span>
 34 |     | <span class='neutral'> *</span>
 35 |     | <span class='neutral'> * Observe that: 1) `msg.sender` is used as the owner, leaving no ambiguity as to the signer intent, and 2) the use of</span>
 36 |     | <span class='neutral'> * `try/catch` allows the permit to fail and makes the code tolerant to frontrunning. (See also</span>
 37 |     | <span class='neutral'> * {SafeERC20-safeTransferFrom}).</span>
 38 |     | <span class='neutral'> *</span>
 39 |     | <span class='neutral'> * Additionally, note that smart contract wallets (such as Argent or Safe) are not able to produce permit signatures, so</span>
 40 |     | <span class='neutral'> * contracts should have entry points that don&#39;t rely on permit.</span>
 41 |     | <span class='neutral'> */</span>
 42 |     | <span class='neutral'>interface IERC20Permit {</span>
 43 |     | <span class='neutral'>    /**</span>
 44 |     | <span class='neutral'>     * @dev Sets `value` as the allowance of `spender` over ``owner``&#39;s tokens,</span>
 45 |     | <span class='neutral'>     * given ``owner``&#39;s signed approval.</span>
 46 |     | <span class='neutral'>     *</span>
 47 |     | <span class='neutral'>     * IMPORTANT: The same issues {IERC20-approve} has related to transaction</span>
 48 |     | <span class='neutral'>     * ordering also apply here.</span>
 49 |     | <span class='neutral'>     *</span>
 50 |     | <span class='neutral'>     * Emits an {Approval} event.</span>
 51 |     | <span class='neutral'>     *</span>
 52 |     | <span class='neutral'>     * Requirements:</span>
 53 |     | <span class='neutral'>     *</span>
 54 |     | <span class='neutral'>     * - `spender` cannot be the zero address.</span>
 55 |     | <span class='neutral'>     * - `deadline` must be a timestamp in the future.</span>
 56 |     | <span class='neutral'>     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`</span>
 57 |     | <span class='neutral'>     * over the EIP712-formatted function arguments.</span>
 58 |     | <span class='neutral'>     * - the signature must use ``owner``&#39;s current nonce (see {nonces}).</span>
 59 |     | <span class='neutral'>     *</span>
 60 |     | <span class='neutral'>     * For more information on the signature format, see the</span>
 61 |     | <span class='neutral'>     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP</span>
 62 |     | <span class='neutral'>     * section].</span>
 63 |     | <span class='neutral'>     *</span>
 64 |     | <span class='neutral'>     * CAUTION: See Security Considerations above.</span>
 65 |     | <span class='neutral'>     */</span>
 66 |     | <span class='neutral'>    function permit(</span>
 67 |     | <span class='neutral'>        address owner,</span>
 68 |     | <span class='neutral'>        address spender,</span>
 69 |     | <span class='neutral'>        uint256 value,</span>
 70 |     | <span class='neutral'>        uint256 deadline,</span>
 71 |     | <span class='neutral'>        uint8 v,</span>
 72 |     | <span class='neutral'>        bytes32 r,</span>
 73 |     | <span class='neutral'>        bytes32 s</span>
 74 |     | <span class='neutral'>    ) external;</span>
 75 |     | <span class='neutral'></span>
 76 |     | <span class='neutral'>    /**</span>
 77 |     | <span class='neutral'>     * @dev Returns the current nonce for `owner`. This value must be</span>
 78 |     | <span class='neutral'>     * included whenever a signature is generated for {permit}.</span>
 79 |     | <span class='neutral'>     *</span>
 80 |     | <span class='neutral'>     * Every successful call to {permit} increases ``owner``&#39;s nonce by one. This</span>
 81 |     | <span class='neutral'>     * prevents a signature from being used multiple times.</span>
 82 |     | <span class='neutral'>     */</span>
 83 |     | <span class='neutral'>    function nonces(address owner) external view returns (uint256);</span>
 84 |     | <span class='neutral'></span>
 85 |     | <span class='neutral'>    /**</span>
 86 |     | <span class='neutral'>     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.</span>
 87 |     | <span class='neutral'>     */</span>
 88 |     | <span class='neutral'>    // solhint-disable-next-line func-name-mixedcase</span>
 89 |     | <span class='neutral'>    function DOMAIN_SEPARATOR() external view returns (bytes32);</span>
 90 |     | <span class='neutral'>}</span>
 91 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/nelsonpereira/Documents/GitHub/Auditing/Fuzzy/Blogs/ElasticSwap_Recon/elasticswap-recon/node_modules/@openzeppelin/contracts/token/ERC20/presets/ERC20PresetFixedSupply.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/presets/ERC20PresetFixedSupply.sol)</span>
  3 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  4 |     | <span class='neutral'></span>
  5 |     | <span class='neutral'>import &quot;../extensions/ERC20Burnable.sol&quot;;</span>
  6 |     | <span class='neutral'></span>
  7 |     | <span class='neutral'>/**</span>
  8 |     | <span class='neutral'> * @dev {ERC20} token, including:</span>
  9 |     | <span class='neutral'> *</span>
 10 |     | <span class='neutral'> *  - Preminted initial supply</span>
 11 |     | <span class='neutral'> *  - Ability for holders to burn (destroy) their tokens</span>
 12 |     | <span class='neutral'> *  - No access control mechanism (for minting/pausing) and hence no governance</span>
 13 |     | <span class='neutral'> *</span>
 14 |     | <span class='neutral'> * This contract uses {ERC20Burnable} to include burn capabilities - head to</span>
 15 |     | <span class='neutral'> * its documentation for details.</span>
 16 |     | <span class='neutral'> *</span>
 17 |     | <span class='neutral'> * _Available since v3.4._</span>
 18 |     | <span class='neutral'> *</span>
 19 |     | <span class='neutral'> * _Deprecated in favor of https://wizard.openzeppelin.com/[Contracts Wizard]._</span>
 20 |     | <span class='neutral'> */</span>
 21 |     | <span class='unexecuted'>contract ERC20PresetFixedSupply is ERC20Burnable {</span>
 22 |     | <span class='neutral'>    /**</span>
 23 |     | <span class='neutral'>     * @dev Mints `initialSupply` amount of token and transfers them to `owner`.</span>
 24 |     | <span class='neutral'>     *</span>
 25 |     | <span class='neutral'>     * See {ERC20-constructor}.</span>
 26 |     | <span class='neutral'>     */</span>
 27 |     | <span class='unexecuted'>    constructor(string memory name, string memory symbol, uint256 initialSupply, address owner) ERC20(name, symbol) {</span>
 28 |     | <span class='unexecuted'>        _mint(owner, initialSupply);</span>
 29 |     | <span class='neutral'>    }</span>
 30 |     | <span class='neutral'>}</span>
 31 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/nelsonpereira/Documents/GitHub/Auditing/Fuzzy/Blogs/ElasticSwap_Recon/elasticswap-recon/node_modules/@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>// OpenZeppelin Contracts (last updated v4.9.3) (token/ERC20/utils/SafeERC20.sol)</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
   5 |     | <span class='neutral'></span>
   6 |     | <span class='neutral'>import &quot;../IERC20.sol&quot;;</span>
   7 |     | <span class='neutral'>import &quot;../extensions/IERC20Permit.sol&quot;;</span>
   8 |     | <span class='neutral'>import &quot;../../../utils/Address.sol&quot;;</span>
   9 |     | <span class='neutral'></span>
  10 |     | <span class='neutral'>/**</span>
  11 |     | <span class='neutral'> * @title SafeERC20</span>
  12 |     | <span class='neutral'> * @dev Wrappers around ERC20 operations that throw on failure (when the token</span>
  13 |     | <span class='neutral'> * contract returns false). Tokens that return no value (and instead revert or</span>
  14 |     | <span class='neutral'> * throw on failure) are also supported, non-reverting calls are assumed to be</span>
  15 |     | <span class='neutral'> * successful.</span>
  16 |     | <span class='neutral'> * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,</span>
  17 |     | <span class='neutral'> * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.</span>
  18 |     | <span class='neutral'> */</span>
  19 |     | <span class='unexecuted'>library SafeERC20 {</span>
  20 |     | <span class='neutral'>    using Address for address;</span>
  21 |     | <span class='neutral'></span>
  22 |     | <span class='neutral'>    /**</span>
  23 |     | <span class='neutral'>     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,</span>
  24 |     | <span class='neutral'>     * non-reverting calls are assumed to be successful.</span>
  25 |     | <span class='neutral'>     */</span>
  26 | *   | <span class='executed'>    function safeTransfer(IERC20 token, address to, uint256 value) internal {</span>
  27 | *   | <span class='executed'>        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));</span>
  28 |     | <span class='neutral'>    }</span>
  29 |     | <span class='neutral'></span>
  30 |     | <span class='neutral'>    /**</span>
  31 |     | <span class='neutral'>     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the</span>
  32 |     | <span class='neutral'>     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.</span>
  33 |     | <span class='neutral'>     */</span>
  34 |     | <span class='unexecuted'>    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {</span>
  35 | *   | <span class='executed'>        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));</span>
  36 |     | <span class='neutral'>    }</span>
  37 |     | <span class='neutral'></span>
  38 |     | <span class='neutral'>    /**</span>
  39 |     | <span class='neutral'>     * @dev Deprecated. This function has issues similar to the ones found in</span>
  40 |     | <span class='neutral'>     * {IERC20-approve}, and its usage is discouraged.</span>
  41 |     | <span class='neutral'>     *</span>
  42 |     | <span class='neutral'>     * Whenever possible, use {safeIncreaseAllowance} and</span>
  43 |     | <span class='neutral'>     * {safeDecreaseAllowance} instead.</span>
  44 |     | <span class='neutral'>     */</span>
  45 |     | <span class='neutral'>    function safeApprove(IERC20 token, address spender, uint256 value) internal {</span>
  46 |     | <span class='neutral'>        // safeApprove should only be called when setting an initial allowance,</span>
  47 |     | <span class='neutral'>        // or when resetting it to zero. To increase and decrease it, use</span>
  48 |     | <span class='neutral'>        // &#39;safeIncreaseAllowance&#39; and &#39;safeDecreaseAllowance&#39;</span>
  49 |     | <span class='neutral'>        require(</span>
  50 |     | <span class='neutral'>            (value == 0) || (token.allowance(address(this), spender) == 0),</span>
  51 |     | <span class='neutral'>            &quot;SafeERC20: approve from non-zero to non-zero allowance&quot;</span>
  52 |     | <span class='neutral'>        );</span>
  53 |     | <span class='neutral'>        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));</span>
  54 |     | <span class='neutral'>    }</span>
  55 |     | <span class='neutral'></span>
  56 |     | <span class='neutral'>    /**</span>
  57 |     | <span class='neutral'>     * @dev Increase the calling contract&#39;s allowance toward `spender` by `value`. If `token` returns no value,</span>
  58 |     | <span class='neutral'>     * non-reverting calls are assumed to be successful.</span>
  59 |     | <span class='neutral'>     */</span>
  60 |     | <span class='neutral'>    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {</span>
  61 |     | <span class='neutral'>        uint256 oldAllowance = token.allowance(address(this), spender);</span>
  62 |     | <span class='neutral'>        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance + value));</span>
  63 |     | <span class='neutral'>    }</span>
  64 |     | <span class='neutral'></span>
  65 |     | <span class='neutral'>    /**</span>
  66 |     | <span class='neutral'>     * @dev Decrease the calling contract&#39;s allowance toward `spender` by `value`. If `token` returns no value,</span>
  67 |     | <span class='neutral'>     * non-reverting calls are assumed to be successful.</span>
  68 |     | <span class='neutral'>     */</span>
  69 |     | <span class='neutral'>    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {</span>
  70 |     | <span class='neutral'>        unchecked {</span>
  71 |     | <span class='neutral'>            uint256 oldAllowance = token.allowance(address(this), spender);</span>
  72 |     | <span class='neutral'>            require(oldAllowance &gt;= value, &quot;SafeERC20: decreased allowance below zero&quot;);</span>
  73 |     | <span class='neutral'>            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance - value));</span>
  74 |     | <span class='neutral'>        }</span>
  75 |     | <span class='neutral'>    }</span>
  76 |     | <span class='neutral'></span>
  77 |     | <span class='neutral'>    /**</span>
  78 |     | <span class='neutral'>     * @dev Set the calling contract&#39;s allowance toward `spender` to `value`. If `token` returns no value,</span>
  79 |     | <span class='neutral'>     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval</span>
  80 |     | <span class='neutral'>     * to be set to zero before setting it to a non-zero value, such as USDT.</span>
  81 |     | <span class='neutral'>     */</span>
  82 |     | <span class='neutral'>    function forceApprove(IERC20 token, address spender, uint256 value) internal {</span>
  83 |     | <span class='neutral'>        bytes memory approvalCall = abi.encodeWithSelector(token.approve.selector, spender, value);</span>
  84 |     | <span class='neutral'></span>
  85 |     | <span class='neutral'>        if (!_callOptionalReturnBool(token, approvalCall)) {</span>
  86 |     | <span class='neutral'>            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, 0));</span>
  87 |     | <span class='neutral'>            _callOptionalReturn(token, approvalCall);</span>
  88 |     | <span class='neutral'>        }</span>
  89 |     | <span class='neutral'>    }</span>
  90 |     | <span class='neutral'></span>
  91 |     | <span class='neutral'>    /**</span>
  92 |     | <span class='neutral'>     * @dev Use a ERC-2612 signature to set the `owner` approval toward `spender` on `token`.</span>
  93 |     | <span class='neutral'>     * Revert on invalid signature.</span>
  94 |     | <span class='neutral'>     */</span>
  95 |     | <span class='neutral'>    function safePermit(</span>
  96 |     | <span class='neutral'>        IERC20Permit token,</span>
  97 |     | <span class='neutral'>        address owner,</span>
  98 |     | <span class='neutral'>        address spender,</span>
  99 |     | <span class='neutral'>        uint256 value,</span>
 100 |     | <span class='neutral'>        uint256 deadline,</span>
 101 |     | <span class='neutral'>        uint8 v,</span>
 102 |     | <span class='neutral'>        bytes32 r,</span>
 103 |     | <span class='neutral'>        bytes32 s</span>
 104 |     | <span class='neutral'>    ) internal {</span>
 105 |     | <span class='neutral'>        uint256 nonceBefore = token.nonces(owner);</span>
 106 |     | <span class='neutral'>        token.permit(owner, spender, value, deadline, v, r, s);</span>
 107 |     | <span class='neutral'>        uint256 nonceAfter = token.nonces(owner);</span>
 108 |     | <span class='neutral'>        require(nonceAfter == nonceBefore + 1, &quot;SafeERC20: permit did not succeed&quot;);</span>
 109 |     | <span class='neutral'>    }</span>
 110 |     | <span class='neutral'></span>
 111 |     | <span class='neutral'>    /**</span>
 112 |     | <span class='neutral'>     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement</span>
 113 |     | <span class='neutral'>     * on the return value: the return value is optional (but if data is returned, it must not be false).</span>
 114 |     | <span class='neutral'>     * @param token The token targeted by the call.</span>
 115 |     | <span class='neutral'>     * @param data The call data (encoded using abi.encode or one of its variants).</span>
 116 |     | <span class='neutral'>     */</span>
 117 | *   | <span class='executed'>    function _callOptionalReturn(IERC20 token, bytes memory data) private {</span>
 118 |     | <span class='neutral'>        // We need to perform a low level call here, to bypass Solidity&#39;s return data size checking mechanism, since</span>
 119 |     | <span class='neutral'>        // we&#39;re implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that</span>
 120 |     | <span class='neutral'>        // the target address contains contract code and also asserts for success in the low-level call.</span>
 121 |     | <span class='neutral'></span>
 122 | *   | <span class='executed'>        bytes memory returndata = address(token).functionCall(data, &quot;SafeERC20: low-level call failed&quot;);</span>
 123 | *   | <span class='executed'>        require(returndata.length == 0 || abi.decode(returndata, (bool)), &quot;SafeERC20: ERC20 operation did not succeed&quot;);</span>
 124 |     | <span class='neutral'>    }</span>
 125 |     | <span class='neutral'></span>
 126 |     | <span class='neutral'>    /**</span>
 127 |     | <span class='neutral'>     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement</span>
 128 |     | <span class='neutral'>     * on the return value: the return value is optional (but if data is returned, it must not be false).</span>
 129 |     | <span class='neutral'>     * @param token The token targeted by the call.</span>
 130 |     | <span class='neutral'>     * @param data The call data (encoded using abi.encode or one of its variants).</span>
 131 |     | <span class='neutral'>     *</span>
 132 |     | <span class='neutral'>     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.</span>
 133 |     | <span class='neutral'>     */</span>
 134 |     | <span class='neutral'>    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {</span>
 135 |     | <span class='neutral'>        // We need to perform a low level call here, to bypass Solidity&#39;s return data size checking mechanism, since</span>
 136 |     | <span class='neutral'>        // we&#39;re implementing it ourselves. We cannot use {Address-functionCall} here since this should return false</span>
 137 |     | <span class='neutral'>        // and not revert is the subcall reverts.</span>
 138 |     | <span class='neutral'></span>
 139 |     | <span class='neutral'>        (bool success, bytes memory returndata) = address(token).call(data);</span>
 140 |     | <span class='neutral'>        return</span>
 141 |     | <span class='neutral'>            success &amp;&amp; (returndata.length == 0 || abi.decode(returndata, (bool))) &amp;&amp; Address.isContract(address(token));</span>
 142 |     | <span class='neutral'>    }</span>
 143 |     | <span class='neutral'>}</span>
 144 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/nelsonpereira/Documents/GitHub/Auditing/Fuzzy/Blogs/ElasticSwap_Recon/elasticswap-recon/node_modules/@openzeppelin/contracts/utils/Address.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>// OpenZeppelin Contracts (last updated v4.9.0) (utils/Address.sol)</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>pragma solidity ^0.8.1;</span>
   5 |     | <span class='neutral'></span>
   6 |     | <span class='neutral'>/**</span>
   7 |     | <span class='neutral'> * @dev Collection of functions related to the address type</span>
   8 |     | <span class='neutral'> */</span>
   9 |     | <span class='unexecuted'>library Address {</span>
  10 |     | <span class='neutral'>    /**</span>
  11 |     | <span class='neutral'>     * @dev Returns true if `account` is a contract.</span>
  12 |     | <span class='neutral'>     *</span>
  13 |     | <span class='neutral'>     * [IMPORTANT]</span>
  14 |     | <span class='neutral'>     * ====</span>
  15 |     | <span class='neutral'>     * It is unsafe to assume that an address for which this function returns</span>
  16 |     | <span class='neutral'>     * false is an externally-owned account (EOA) and not a contract.</span>
  17 |     | <span class='neutral'>     *</span>
  18 |     | <span class='neutral'>     * Among others, `isContract` will return false for the following</span>
  19 |     | <span class='neutral'>     * types of addresses:</span>
  20 |     | <span class='neutral'>     *</span>
  21 |     | <span class='neutral'>     *  - an externally-owned account</span>
  22 |     | <span class='neutral'>     *  - a contract in construction</span>
  23 |     | <span class='neutral'>     *  - an address where a contract will be created</span>
  24 |     | <span class='neutral'>     *  - an address where a contract lived, but was destroyed</span>
  25 |     | <span class='neutral'>     *</span>
  26 |     | <span class='neutral'>     * Furthermore, `isContract` will also return true if the target contract within</span>
  27 |     | <span class='neutral'>     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,</span>
  28 |     | <span class='neutral'>     * which only has an effect at the end of a transaction.</span>
  29 |     | <span class='neutral'>     * ====</span>
  30 |     | <span class='neutral'>     *</span>
  31 |     | <span class='neutral'>     * [IMPORTANT]</span>
  32 |     | <span class='neutral'>     * ====</span>
  33 |     | <span class='neutral'>     * You shouldn&#39;t rely on `isContract` to protect against flash loan attacks!</span>
  34 |     | <span class='neutral'>     *</span>
  35 |     | <span class='neutral'>     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets</span>
  36 |     | <span class='neutral'>     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract</span>
  37 |     | <span class='neutral'>     * constructor.</span>
  38 |     | <span class='neutral'>     * ====</span>
  39 |     | <span class='neutral'>     */</span>
  40 |     | <span class='neutral'>    function isContract(address account) internal view returns (bool) {</span>
  41 |     | <span class='neutral'>        // This method relies on extcodesize/address.code.length, which returns 0</span>
  42 |     | <span class='neutral'>        // for contracts in construction, since the code is only stored at the end</span>
  43 |     | <span class='neutral'>        // of the constructor execution.</span>
  44 |     | <span class='neutral'></span>
  45 |     | <span class='unexecuted'>        return account.code.length &gt; 0;</span>
  46 |     | <span class='neutral'>    }</span>
  47 |     | <span class='neutral'></span>
  48 |     | <span class='neutral'>    /**</span>
  49 |     | <span class='neutral'>     * @dev Replacement for Solidity&#39;s `transfer`: sends `amount` wei to</span>
  50 |     | <span class='neutral'>     * `recipient`, forwarding all available gas and reverting on errors.</span>
  51 |     | <span class='neutral'>     *</span>
  52 |     | <span class='neutral'>     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost</span>
  53 |     | <span class='neutral'>     * of certain opcodes, possibly making contracts go over the 2300 gas limit</span>
  54 |     | <span class='neutral'>     * imposed by `transfer`, making them unable to receive funds via</span>
  55 |     | <span class='neutral'>     * `transfer`. {sendValue} removes this limitation.</span>
  56 |     | <span class='neutral'>     *</span>
  57 |     | <span class='neutral'>     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].</span>
  58 |     | <span class='neutral'>     *</span>
  59 |     | <span class='neutral'>     * IMPORTANT: because control is transferred to `recipient`, care must be</span>
  60 |     | <span class='neutral'>     * taken to not create reentrancy vulnerabilities. Consider using</span>
  61 |     | <span class='neutral'>     * {ReentrancyGuard} or the</span>
  62 |     | <span class='neutral'>     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].</span>
  63 |     | <span class='neutral'>     */</span>
  64 |     | <span class='neutral'>    function sendValue(address payable recipient, uint256 amount) internal {</span>
  65 |     | <span class='neutral'>        require(address(this).balance &gt;= amount, &quot;Address: insufficient balance&quot;);</span>
  66 |     | <span class='neutral'></span>
  67 |     | <span class='neutral'>        (bool success, ) = recipient.call{value: amount}(&quot;&quot;);</span>
  68 |     | <span class='neutral'>        require(success, &quot;Address: unable to send value, recipient may have reverted&quot;);</span>
  69 |     | <span class='neutral'>    }</span>
  70 |     | <span class='neutral'></span>
  71 |     | <span class='neutral'>    /**</span>
  72 |     | <span class='neutral'>     * @dev Performs a Solidity function call using a low level `call`. A</span>
  73 |     | <span class='neutral'>     * plain `call` is an unsafe replacement for a function call: use this</span>
  74 |     | <span class='neutral'>     * function instead.</span>
  75 |     | <span class='neutral'>     *</span>
  76 |     | <span class='neutral'>     * If `target` reverts with a revert reason, it is bubbled up by this</span>
  77 |     | <span class='neutral'>     * function (like regular Solidity function calls).</span>
  78 |     | <span class='neutral'>     *</span>
  79 |     | <span class='neutral'>     * Returns the raw returned data. To convert to the expected return value,</span>
  80 |     | <span class='neutral'>     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].</span>
  81 |     | <span class='neutral'>     *</span>
  82 |     | <span class='neutral'>     * Requirements:</span>
  83 |     | <span class='neutral'>     *</span>
  84 |     | <span class='neutral'>     * - `target` must be a contract.</span>
  85 |     | <span class='neutral'>     * - calling `target` with `data` must not revert.</span>
  86 |     | <span class='neutral'>     *</span>
  87 |     | <span class='neutral'>     * _Available since v3.1._</span>
  88 |     | <span class='neutral'>     */</span>
  89 |     | <span class='neutral'>    function functionCall(address target, bytes memory data) internal returns (bytes memory) {</span>
  90 |     | <span class='neutral'>        return functionCallWithValue(target, data, 0, &quot;Address: low-level call failed&quot;);</span>
  91 |     | <span class='neutral'>    }</span>
  92 |     | <span class='neutral'></span>
  93 |     | <span class='neutral'>    /**</span>
  94 |     | <span class='neutral'>     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with</span>
  95 |     | <span class='neutral'>     * `errorMessage` as a fallback revert reason when `target` reverts.</span>
  96 |     | <span class='neutral'>     *</span>
  97 |     | <span class='neutral'>     * _Available since v3.1._</span>
  98 |     | <span class='neutral'>     */</span>
  99 |     | <span class='unexecuted'>    function functionCall(</span>
 100 |     | <span class='neutral'>        address target,</span>
 101 |     | <span class='neutral'>        bytes memory data,</span>
 102 |     | <span class='neutral'>        string memory errorMessage</span>
 103 |     | <span class='unexecuted'>    ) internal returns (bytes memory) {</span>
 104 |     | <span class='unexecuted'>        return functionCallWithValue(target, data, 0, errorMessage);</span>
 105 |     | <span class='neutral'>    }</span>
 106 |     | <span class='neutral'></span>
 107 |     | <span class='neutral'>    /**</span>
 108 |     | <span class='neutral'>     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],</span>
 109 |     | <span class='neutral'>     * but also transferring `value` wei to `target`.</span>
 110 |     | <span class='neutral'>     *</span>
 111 |     | <span class='neutral'>     * Requirements:</span>
 112 |     | <span class='neutral'>     *</span>
 113 |     | <span class='neutral'>     * - the calling contract must have an ETH balance of at least `value`.</span>
 114 |     | <span class='neutral'>     * - the called Solidity function must be `payable`.</span>
 115 |     | <span class='neutral'>     *</span>
 116 |     | <span class='neutral'>     * _Available since v3.1._</span>
 117 |     | <span class='neutral'>     */</span>
 118 |     | <span class='neutral'>    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {</span>
 119 |     | <span class='neutral'>        return functionCallWithValue(target, data, value, &quot;Address: low-level call with value failed&quot;);</span>
 120 |     | <span class='neutral'>    }</span>
 121 |     | <span class='neutral'></span>
 122 |     | <span class='neutral'>    /**</span>
 123 |     | <span class='neutral'>     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but</span>
 124 |     | <span class='neutral'>     * with `errorMessage` as a fallback revert reason when `target` reverts.</span>
 125 |     | <span class='neutral'>     *</span>
 126 |     | <span class='neutral'>     * _Available since v3.1._</span>
 127 |     | <span class='neutral'>     */</span>
 128 |     | <span class='unexecuted'>    function functionCallWithValue(</span>
 129 |     | <span class='neutral'>        address target,</span>
 130 |     | <span class='neutral'>        bytes memory data,</span>
 131 |     | <span class='neutral'>        uint256 value,</span>
 132 |     | <span class='neutral'>        string memory errorMessage</span>
 133 |     | <span class='unexecuted'>    ) internal returns (bytes memory) {</span>
 134 | *   | <span class='executed'>        require(address(this).balance &gt;= value, &quot;Address: insufficient balance for call&quot;);</span>
 135 | *   | <span class='executed'>        (bool success, bytes memory returndata) = target.call{value: value}(data);</span>
 136 |     | <span class='unexecuted'>        return verifyCallResultFromTarget(target, success, returndata, errorMessage);</span>
 137 |     | <span class='neutral'>    }</span>
 138 |     | <span class='neutral'></span>
 139 |     | <span class='neutral'>    /**</span>
 140 |     | <span class='neutral'>     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],</span>
 141 |     | <span class='neutral'>     * but performing a static call.</span>
 142 |     | <span class='neutral'>     *</span>
 143 |     | <span class='neutral'>     * _Available since v3.3._</span>
 144 |     | <span class='neutral'>     */</span>
 145 |     | <span class='neutral'>    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {</span>
 146 |     | <span class='neutral'>        return functionStaticCall(target, data, &quot;Address: low-level static call failed&quot;);</span>
 147 |     | <span class='neutral'>    }</span>
 148 |     | <span class='neutral'></span>
 149 |     | <span class='neutral'>    /**</span>
 150 |     | <span class='neutral'>     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],</span>
 151 |     | <span class='neutral'>     * but performing a static call.</span>
 152 |     | <span class='neutral'>     *</span>
 153 |     | <span class='neutral'>     * _Available since v3.3._</span>
 154 |     | <span class='neutral'>     */</span>
 155 |     | <span class='neutral'>    function functionStaticCall(</span>
 156 |     | <span class='neutral'>        address target,</span>
 157 |     | <span class='neutral'>        bytes memory data,</span>
 158 |     | <span class='neutral'>        string memory errorMessage</span>
 159 |     | <span class='neutral'>    ) internal view returns (bytes memory) {</span>
 160 |     | <span class='neutral'>        (bool success, bytes memory returndata) = target.staticcall(data);</span>
 161 |     | <span class='neutral'>        return verifyCallResultFromTarget(target, success, returndata, errorMessage);</span>
 162 |     | <span class='neutral'>    }</span>
 163 |     | <span class='neutral'></span>
 164 |     | <span class='neutral'>    /**</span>
 165 |     | <span class='neutral'>     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],</span>
 166 |     | <span class='neutral'>     * but performing a delegate call.</span>
 167 |     | <span class='neutral'>     *</span>
 168 |     | <span class='neutral'>     * _Available since v3.4._</span>
 169 |     | <span class='neutral'>     */</span>
 170 |     | <span class='neutral'>    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {</span>
 171 |     | <span class='neutral'>        return functionDelegateCall(target, data, &quot;Address: low-level delegate call failed&quot;);</span>
 172 |     | <span class='neutral'>    }</span>
 173 |     | <span class='neutral'></span>
 174 |     | <span class='neutral'>    /**</span>
 175 |     | <span class='neutral'>     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],</span>
 176 |     | <span class='neutral'>     * but performing a delegate call.</span>
 177 |     | <span class='neutral'>     *</span>
 178 |     | <span class='neutral'>     * _Available since v3.4._</span>
 179 |     | <span class='neutral'>     */</span>
 180 |     | <span class='neutral'>    function functionDelegateCall(</span>
 181 |     | <span class='neutral'>        address target,</span>
 182 |     | <span class='neutral'>        bytes memory data,</span>
 183 |     | <span class='neutral'>        string memory errorMessage</span>
 184 |     | <span class='neutral'>    ) internal returns (bytes memory) {</span>
 185 |     | <span class='neutral'>        (bool success, bytes memory returndata) = target.delegatecall(data);</span>
 186 |     | <span class='neutral'>        return verifyCallResultFromTarget(target, success, returndata, errorMessage);</span>
 187 |     | <span class='neutral'>    }</span>
 188 |     | <span class='neutral'></span>
 189 |     | <span class='neutral'>    /**</span>
 190 |     | <span class='neutral'>     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling</span>
 191 |     | <span class='neutral'>     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.</span>
 192 |     | <span class='neutral'>     *</span>
 193 |     | <span class='neutral'>     * _Available since v4.8._</span>
 194 |     | <span class='neutral'>     */</span>
 195 |     | <span class='unexecuted'>    function verifyCallResultFromTarget(</span>
 196 |     | <span class='neutral'>        address target,</span>
 197 |     | <span class='neutral'>        bool success,</span>
 198 |     | <span class='neutral'>        bytes memory returndata,</span>
 199 |     | <span class='neutral'>        string memory errorMessage</span>
 200 |     | <span class='unexecuted'>    ) internal view returns (bytes memory) {</span>
 201 |     | <span class='unexecuted'>        if (success) {</span>
 202 |     | <span class='unexecuted'>            if (returndata.length == 0) {</span>
 203 |     | <span class='neutral'>                // only check isContract if the call was successful and the return data is empty</span>
 204 |     | <span class='neutral'>                // otherwise we already know that it was a contract</span>
 205 |     | <span class='unexecuted'>                require(isContract(target), &quot;Address: call to non-contract&quot;);</span>
 206 |     | <span class='neutral'>            }</span>
 207 |     | <span class='unexecuted'>            return returndata;</span>
 208 |     | <span class='neutral'>        } else {</span>
 209 |     | <span class='unexecuted'>            _revert(returndata, errorMessage);</span>
 210 |     | <span class='neutral'>        }</span>
 211 |     | <span class='neutral'>    }</span>
 212 |     | <span class='neutral'></span>
 213 |     | <span class='neutral'>    /**</span>
 214 |     | <span class='neutral'>     * @dev Tool to verify that a low level call was successful, and revert if it wasn&#39;t, either by bubbling the</span>
 215 |     | <span class='neutral'>     * revert reason or using the provided one.</span>
 216 |     | <span class='neutral'>     *</span>
 217 |     | <span class='neutral'>     * _Available since v4.3._</span>
 218 |     | <span class='neutral'>     */</span>
 219 |     | <span class='neutral'>    function verifyCallResult(</span>
 220 |     | <span class='neutral'>        bool success,</span>
 221 |     | <span class='neutral'>        bytes memory returndata,</span>
 222 |     | <span class='neutral'>        string memory errorMessage</span>
 223 |     | <span class='neutral'>    ) internal pure returns (bytes memory) {</span>
 224 |     | <span class='neutral'>        if (success) {</span>
 225 |     | <span class='neutral'>            return returndata;</span>
 226 |     | <span class='neutral'>        } else {</span>
 227 |     | <span class='neutral'>            _revert(returndata, errorMessage);</span>
 228 |     | <span class='neutral'>        }</span>
 229 |     | <span class='neutral'>    }</span>
 230 |     | <span class='neutral'></span>
 231 |     | <span class='neutral'>    function _revert(bytes memory returndata, string memory errorMessage) private pure {</span>
 232 |     | <span class='neutral'>        // Look for revert reason and bubble it up if present</span>
 233 |     | <span class='unexecuted'>        if (returndata.length &gt; 0) {</span>
 234 |     | <span class='neutral'>            // The easiest way to bubble the revert reason is using memory via assembly</span>
 235 |     | <span class='neutral'>            /// @solidity memory-safe-assembly</span>
 236 |     | <span class='unexecuted'>            assembly {</span>
 237 |     | <span class='unexecuted'>                let returndata_size := mload(returndata)</span>
 238 |     | <span class='unexecuted'>                revert(add(32, returndata), returndata_size)</span>
 239 |     | <span class='neutral'>            }</span>
 240 |     | <span class='neutral'>        } else {</span>
 241 |     | <span class='unexecuted'>            revert(errorMessage);</span>
 242 |     | <span class='neutral'>        }</span>
 243 |     | <span class='neutral'>    }</span>
 244 |     | <span class='neutral'>}</span>
 245 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/nelsonpereira/Documents/GitHub/Auditing/Fuzzy/Blogs/ElasticSwap_Recon/elasticswap-recon/node_modules/@openzeppelin/contracts/utils/Context.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>// OpenZeppelin Contracts (last updated v4.9.4) (utils/Context.sol)</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>/**</span>
  7 |     | <span class='neutral'> * @dev Provides information about the current execution context, including the</span>
  8 |     | <span class='neutral'> * sender of the transaction and its data. While these are generally available</span>
  9 |     | <span class='neutral'> * via msg.sender and msg.data, they should not be accessed in such a direct</span>
 10 |     | <span class='neutral'> * manner, since when dealing with meta-transactions the account sending and</span>
 11 |     | <span class='neutral'> * paying for execution may not be the actual sender (as far as an application</span>
 12 |     | <span class='neutral'> * is concerned).</span>
 13 |     | <span class='neutral'> *</span>
 14 |     | <span class='neutral'> * This contract is only required for intermediate, library-like contracts.</span>
 15 |     | <span class='neutral'> */</span>
 16 |     | <span class='neutral'>abstract contract Context {</span>
 17 |     | <span class='unexecuted'>    function _msgSender() internal view virtual returns (address) {</span>
 18 | *   | <span class='executed'>        return msg.sender;</span>
 19 |     | <span class='neutral'>    }</span>
 20 |     | <span class='neutral'></span>
 21 |     | <span class='neutral'>    function _msgData() internal view virtual returns (bytes calldata) {</span>
 22 |     | <span class='neutral'>        return msg.data;</span>
 23 |     | <span class='neutral'>    }</span>
 24 |     | <span class='neutral'></span>
 25 |     | <span class='neutral'>    function _contextSuffixLength() internal view virtual returns (uint256) {</span>
 26 |     | <span class='neutral'>        return 0;</span>
 27 |     | <span class='neutral'>    }</span>
 28 |     | <span class='neutral'>}</span>
 29 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/nelsonpereira/Documents/GitHub/Auditing/Fuzzy/Blogs/ElasticSwap_Recon/elasticswap-recon/src/contracts/Exchange.sol</b>
<code>
   1 |     | <span class='neutral'>//SPDX-License-Identifier: GPL-3.0</span>
   2 |     | <span class='neutral'>pragma solidity 0.8.4;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import &quot;../libraries/MathLib.sol&quot;;</span>
   5 |     | <span class='neutral'>import &quot;@openzeppelin/contracts/token/ERC20/ERC20.sol&quot;;</span>
   6 |     | <span class='neutral'>import &quot;@openzeppelin/contracts/token/ERC20/IERC20.sol&quot;;</span>
   7 |     | <span class='neutral'>import &quot;@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol&quot;;</span>
   8 |     | <span class='neutral'>import &quot;@openzeppelin/contracts/security/ReentrancyGuard.sol&quot;;</span>
   9 |     | <span class='neutral'>import &quot;../interfaces/IExchangeFactory.sol&quot;;</span>
  10 |     | <span class='neutral'></span>
  11 |     | <span class='neutral'>/**</span>
  12 |     | <span class='neutral'> * @title Exchange contract for Elastic Swap representing a single ERC20 pair of tokens to be swapped.</span>
  13 |     | <span class='neutral'> * @author Elastic DAO</span>
  14 |     | <span class='neutral'> * @notice This contract provides all of the needed functionality for a liquidity provider to supply/withdraw ERC20</span>
  15 |     | <span class='neutral'> * tokens and traders to swap tokens for one another.</span>
  16 |     | <span class='neutral'> */</span>
  17 | *   | <span class='executed'>contract Exchange is ERC20, ReentrancyGuard {</span>
  18 |     | <span class='neutral'>    using MathLib for uint256;</span>
  19 |     | <span class='neutral'>    using SafeERC20 for IERC20;</span>
  20 |     | <span class='neutral'></span>
  21 |     | <span class='unexecuted'>    address public immutable baseToken; // address of ERC20 base token (elastic or fixed supply)</span>
  22 |     | <span class='unexecuted'>    address public immutable quoteToken; // address of ERC20 quote token (WETH or a stable coin w/ fixed supply)</span>
  23 |     | <span class='unexecuted'>    address public immutable exchangeFactoryAddress;</span>
  24 |     | <span class='neutral'></span>
  25 | *   | <span class='executed'>    uint256 public constant TOTAL_LIQUIDITY_FEE = 50; // fee provided to liquidity providers + DAO in basis points</span>
  26 | *   | <span class='executed'>    uint256 public constant MINIMUM_LIQUIDITY = 1e3;</span>
  27 |     | <span class='neutral'></span>
  28 |     | <span class='neutral'>    // @audit cant be changed to private because makes it inaccesible in BeforeAfter</span>
  29 |     | <span class='unexecuted'>    MathLib.InternalBalances public internalBalances;</span>
  30 |     | <span class='neutral'></span>
  31 |     | <span class='neutral'>    event AddLiquidity(</span>
  32 |     | <span class='neutral'>        address indexed liquidityProvider,</span>
  33 |     | <span class='neutral'>        uint256 baseTokenQtyAdded,</span>
  34 |     | <span class='neutral'>        uint256 quoteTokenQtyAdded</span>
  35 |     | <span class='neutral'>    );</span>
  36 |     | <span class='neutral'>    event RemoveLiquidity(</span>
  37 |     | <span class='neutral'>        address indexed liquidityProvider,</span>
  38 |     | <span class='neutral'>        uint256 baseTokenQtyRemoved,</span>
  39 |     | <span class='neutral'>        uint256 quoteTokenQtyRemoved</span>
  40 |     | <span class='neutral'>    );</span>
  41 |     | <span class='neutral'>    event Swap(</span>
  42 |     | <span class='neutral'>        address indexed sender,</span>
  43 |     | <span class='neutral'>        uint256 baseTokenQtyIn,</span>
  44 |     | <span class='neutral'>        uint256 quoteTokenQtyIn,</span>
  45 |     | <span class='neutral'>        uint256 baseTokenQtyOut,</span>
  46 |     | <span class='neutral'>        uint256 quoteTokenQtyOut</span>
  47 |     | <span class='neutral'>    );</span>
  48 |     | <span class='neutral'></span>
  49 |     | <span class='neutral'>    /**</span>
  50 |     | <span class='neutral'>     * @dev Called to check timestamps from users for expiration of their calls.</span>
  51 |     | <span class='neutral'>     */</span>
  52 |     | <span class='neutral'>    modifier isNotExpired(uint256 _expirationTimeStamp) {</span>
  53 | *   | <span class='executed'>        require(_expirationTimeStamp &gt;= block.timestamp, &quot;Exchange: EXPIRED&quot;);</span>
  54 |     | <span class='unexecuted'>        _;</span>
  55 |     | <span class='neutral'>    }</span>
  56 |     | <span class='neutral'></span>
  57 |     | <span class='neutral'>    /**</span>
  58 |     | <span class='neutral'>     * @notice called by the exchange factory to create a new erc20 token swap pair (do not call this directly!)</span>
  59 |     | <span class='neutral'>     * @param _name The human readable name of this pair (also used for the liquidity token name)</span>
  60 |     | <span class='neutral'>     * @param _symbol Shortened symbol for trading pair (also used for the liquidity token symbol)</span>
  61 |     | <span class='neutral'>     * @param _baseToken address of the ERC20 base token in the pair. This token can have a fixed or elastic supply</span>
  62 |     | <span class='neutral'>     * @param _quoteToken address of the ERC20 quote token in the pair. This token is assumed to have a fixed supply.</span>
  63 |     | <span class='neutral'>     * @param _exchangeFactoryAddress address of the exchange factory</span>
  64 |     | <span class='neutral'>     */</span>
  65 |     | <span class='unexecuted'>    constructor(</span>
  66 |     | <span class='neutral'>        string memory _name,</span>
  67 |     | <span class='neutral'>        string memory _symbol,</span>
  68 |     | <span class='neutral'>        address _baseToken,</span>
  69 |     | <span class='neutral'>        address _quoteToken,</span>
  70 |     | <span class='neutral'>        address _exchangeFactoryAddress</span>
  71 |     | <span class='unexecuted'>    ) ERC20(_name, _symbol) {</span>
  72 |     | <span class='unexecuted'>        baseToken = _baseToken;</span>
  73 |     | <span class='unexecuted'>        quoteToken = _quoteToken;</span>
  74 |     | <span class='unexecuted'>        exchangeFactoryAddress = _exchangeFactoryAddress;</span>
  75 |     | <span class='neutral'>    }</span>
  76 |     | <span class='neutral'></span>
  77 |     | <span class='neutral'>    /**</span>
  78 |     | <span class='neutral'>     * @notice primary entry point for a liquidity provider to add new liquidity (base and quote tokens) to the exchange</span>
  79 |     | <span class='neutral'>     * and receive liquidity tokens in return.</span>
  80 |     | <span class='neutral'>     * Requires approvals to be granted to this exchange for both base and quote tokens.</span>
  81 |     | <span class='neutral'>     * @param _baseTokenQtyDesired qty of baseTokens that you would like to add to the exchange</span>
  82 |     | <span class='neutral'>     * @param _quoteTokenQtyDesired qty of quoteTokens that you would like to add to the exchange</span>
  83 |     | <span class='neutral'>     * @param _baseTokenQtyMin minimum acceptable qty of baseTokens that will be added (or transaction will revert)</span>
  84 |     | <span class='neutral'>     * @param _quoteTokenQtyMin minimum acceptable qty of quoteTokens that will be added (or transaction will revert)</span>
  85 |     | <span class='neutral'>     * @param _liquidityTokenRecipient address for the exchange to issue the resulting liquidity tokens from</span>
  86 |     | <span class='neutral'>     * this transaction to</span>
  87 |     | <span class='neutral'>     * @param _expirationTimestamp timestamp that this transaction must occur before (or transaction will revert)</span>
  88 |     | <span class='neutral'>     */</span>
  89 | *   | <span class='executed'>    function addLiquidity(</span>
  90 |     | <span class='neutral'>        uint256 _baseTokenQtyDesired,</span>
  91 |     | <span class='neutral'>        uint256 _quoteTokenQtyDesired,</span>
  92 |     | <span class='neutral'>        uint256 _baseTokenQtyMin,</span>
  93 |     | <span class='neutral'>        uint256 _quoteTokenQtyMin,</span>
  94 |     | <span class='neutral'>        address _liquidityTokenRecipient,</span>
  95 |     | <span class='neutral'>        uint256 _expirationTimestamp</span>
  96 |     | <span class='unexecuted'>    ) external nonReentrant() isNotExpired(_expirationTimestamp) {</span>
  97 | *   | <span class='executed'>        uint256 totalSupply = this.totalSupply();</span>
  98 | *   | <span class='executed'>        MathLib.TokenQtys memory tokenQtys =</span>
  99 | *   | <span class='executed'>            MathLib.calculateAddLiquidityQuantities(</span>
 100 | *   | <span class='executed'>                _baseTokenQtyDesired,</span>
 101 | *   | <span class='executed'>                _quoteTokenQtyDesired,</span>
 102 | *   | <span class='executed'>                _baseTokenQtyMin,</span>
 103 | *   | <span class='executed'>                _quoteTokenQtyMin,</span>
 104 | *   | <span class='executed'>                IERC20(baseToken).balanceOf(address(this)),</span>
 105 |     | <span class='unexecuted'>                totalSupply,</span>
 106 |     | <span class='unexecuted'>                internalBalances</span>
 107 |     | <span class='neutral'>            );</span>
 108 |     | <span class='neutral'></span>
 109 |     | <span class='unexecuted'>        internalBalances.kLast =</span>
 110 |     | <span class='unexecuted'>            internalBalances.baseTokenReserveQty *</span>
 111 |     | <span class='unexecuted'>            internalBalances.quoteTokenReserveQty;</span>
 112 |     | <span class='neutral'></span>
 113 |     | <span class='unexecuted'>        if (tokenQtys.liquidityTokenFeeQty != 0) {</span>
 114 |     | <span class='neutral'>            // mint liquidity tokens to fee address for k growth.</span>
 115 | *   | <span class='executed'>            _mint(</span>
 116 | *   | <span class='executed'>                IExchangeFactory(exchangeFactoryAddress).feeAddress(),</span>
 117 | *   | <span class='executed'>                tokenQtys.liquidityTokenFeeQty</span>
 118 |     | <span class='neutral'>            );</span>
 119 |     | <span class='neutral'>        }</span>
 120 |     | <span class='neutral'></span>
 121 |     | <span class='unexecuted'>        bool isExchangeEmpty = totalSupply == 0;</span>
 122 |     | <span class='unexecuted'>        if (isExchangeEmpty) {</span>
 123 |     | <span class='neutral'>            // check if this the first LP provider, if so, we need to lock some minimum dust liquidity.</span>
 124 |     | <span class='unexecuted'>            require(</span>
 125 |     | <span class='unexecuted'>                tokenQtys.liquidityTokenQty &gt; MINIMUM_LIQUIDITY,</span>
 126 |     | <span class='neutral'>                &quot;Exchange: INITIAL_DEPOSIT_MIN&quot;</span>
 127 |     | <span class='neutral'>            );</span>
 128 |     | <span class='neutral'>            unchecked {</span>
 129 |     | <span class='unexecuted'>                tokenQtys.liquidityTokenQty -= MINIMUM_LIQUIDITY;</span>
 130 |     | <span class='neutral'>            }</span>
 131 |     | <span class='unexecuted'>            _mint(address(this), MINIMUM_LIQUIDITY); // mint to this address, total supply will never be 0 again</span>
 132 |     | <span class='neutral'>        }</span>
 133 |     | <span class='neutral'></span>
 134 |     | <span class='unexecuted'>        _mint(_liquidityTokenRecipient, tokenQtys.liquidityTokenQty); // mint liquidity tokens to recipient</span>
 135 |     | <span class='neutral'></span>
 136 |     | <span class='unexecuted'>        if (tokenQtys.baseTokenQty != 0) {</span>
 137 |     | <span class='neutral'>            // transfer base tokens to Exchange</span>
 138 |     | <span class='unexecuted'>            IERC20(baseToken).safeTransferFrom(</span>
 139 |     | <span class='unexecuted'>                msg.sender,</span>
 140 |     | <span class='unexecuted'>                address(this),</span>
 141 |     | <span class='unexecuted'>                tokenQtys.baseTokenQty</span>
 142 |     | <span class='neutral'>            );</span>
 143 |     | <span class='neutral'></span>
 144 |     | <span class='unexecuted'>            if (isExchangeEmpty) {</span>
 145 |     | <span class='unexecuted'>                require(</span>
 146 |     | <span class='unexecuted'>                    IERC20(baseToken).balanceOf(address(this)) ==</span>
 147 |     | <span class='unexecuted'>                        tokenQtys.baseTokenQty,</span>
 148 |     | <span class='neutral'>                    &quot;Exchange: FEE_ON_TRANSFER_NOT_SUPPORTED&quot;</span>
 149 |     | <span class='neutral'>                );</span>
 150 |     | <span class='neutral'>            }</span>
 151 |     | <span class='neutral'>        }</span>
 152 |     | <span class='neutral'></span>
 153 |     | <span class='unexecuted'>        if (tokenQtys.quoteTokenQty != 0) {</span>
 154 |     | <span class='neutral'>            // transfer quote tokens to Exchange</span>
 155 | *   | <span class='executed'>            IERC20(quoteToken).safeTransferFrom(</span>
 156 | *   | <span class='executed'>                msg.sender,</span>
 157 | *   | <span class='executed'>                address(this),</span>
 158 | *   | <span class='executed'>                tokenQtys.quoteTokenQty</span>
 159 |     | <span class='neutral'>            );</span>
 160 |     | <span class='neutral'>        }</span>
 161 |     | <span class='neutral'></span>
 162 | *   | <span class='executed'>        emit AddLiquidity(</span>
 163 |     | <span class='unexecuted'>            msg.sender,</span>
 164 | *   | <span class='executed'>            tokenQtys.baseTokenQty,</span>
 165 | *   | <span class='executed'>            tokenQtys.quoteTokenQty</span>
 166 |     | <span class='neutral'>        );</span>
 167 |     | <span class='neutral'>    }</span>
 168 |     | <span class='neutral'></span>
 169 |     | <span class='neutral'>    /**</span>
 170 |     | <span class='neutral'>     * @notice called by a liquidity provider to redeem liquidity tokens from the exchange and receive back</span>
 171 |     | <span class='neutral'>     * base and quote tokens. Required approvals to be granted to this exchange for the liquidity token</span>
 172 |     | <span class='neutral'>     * @param _liquidityTokenQty qty of liquidity tokens that you would like to redeem</span>
 173 |     | <span class='neutral'>     * @param _baseTokenQtyMin minimum acceptable qty of base tokens to receive back (or transaction will revert)</span>
 174 |     | <span class='neutral'>     * @param _quoteTokenQtyMin minimum acceptable qty of quote tokens to receive back (or transaction will revert)</span>
 175 |     | <span class='neutral'>     * @param _tokenRecipient address for the exchange to issue the resulting base and</span>
 176 |     | <span class='neutral'>     * quote tokens from this transaction to</span>
 177 |     | <span class='neutral'>     * @param _expirationTimestamp timestamp that this transaction must occur before (or transaction will revert)</span>
 178 |     | <span class='neutral'>     */</span>
 179 | *   | <span class='executed'>    function removeLiquidity(</span>
 180 |     | <span class='neutral'>        uint256 _liquidityTokenQty,</span>
 181 |     | <span class='neutral'>        uint256 _baseTokenQtyMin,</span>
 182 |     | <span class='neutral'>        uint256 _quoteTokenQtyMin,</span>
 183 |     | <span class='neutral'>        address _tokenRecipient,</span>
 184 |     | <span class='neutral'>        uint256 _expirationTimestamp</span>
 185 | *   | <span class='executed'>    ) external nonReentrant() isNotExpired(_expirationTimestamp) {</span>
 186 | *   | <span class='executed'>        require(this.totalSupply() != 0, &quot;Exchange: INSUFFICIENT_LIQUIDITY&quot;);</span>
 187 | *   | <span class='executed'>        require(</span>
 188 | *   | <span class='executed'>            _baseTokenQtyMin != 0 &amp;&amp; _quoteTokenQtyMin != 0,</span>
 189 |     | <span class='neutral'>            &quot;Exchange: MINS_MUST_BE_GREATER_THAN_ZERO&quot;</span>
 190 |     | <span class='neutral'>        );</span>
 191 |     | <span class='neutral'></span>
 192 | *   | <span class='executed'>        uint256 baseTokenReserveQty =</span>
 193 | *   | <span class='executed'>            IERC20(baseToken).balanceOf(address(this));</span>
 194 | *   | <span class='executed'>        uint256 quoteTokenReserveQty =</span>
 195 | *   | <span class='executed'>            IERC20(quoteToken).balanceOf(address(this));</span>
 196 |     | <span class='neutral'></span>
 197 | *   | <span class='executed'>        uint256 totalSupplyOfLiquidityTokens = this.totalSupply();</span>
 198 |     | <span class='neutral'>        // calculate any DAO fees here.</span>
 199 | *   | <span class='executed'>        uint256 liquidityTokenFeeQty =</span>
 200 | *   | <span class='executed'>            MathLib.calculateLiquidityTokenFees(</span>
 201 |     | <span class='neutral'>                totalSupplyOfLiquidityTokens,</span>
 202 | *   | <span class='executed'>                internalBalances</span>
 203 |     | <span class='neutral'>            );</span>
 204 |     | <span class='neutral'></span>
 205 |     | <span class='neutral'>        // we need to factor this quantity in to any total supply before redemption</span>
 206 | *   | <span class='executed'>        totalSupplyOfLiquidityTokens += liquidityTokenFeeQty;</span>
 207 |     | <span class='neutral'></span>
 208 | *   | <span class='executed'>        uint256 baseTokenQtyToReturn =</span>
 209 | *   | <span class='executed'>            (_liquidityTokenQty * baseTokenReserveQty) /</span>
 210 |     | <span class='neutral'>                totalSupplyOfLiquidityTokens;</span>
 211 | *   | <span class='executed'>        uint256 quoteTokenQtyToReturn =</span>
 212 | *   | <span class='executed'>            (_liquidityTokenQty * quoteTokenReserveQty) /</span>
 213 | *   | <span class='executed'>                totalSupplyOfLiquidityTokens;</span>
 214 |     | <span class='neutral'></span>
 215 | *   | <span class='executed'>        require(</span>
 216 | *   | <span class='executed'>            baseTokenQtyToReturn &gt;= _baseTokenQtyMin,</span>
 217 |     | <span class='neutral'>            &quot;Exchange: INSUFFICIENT_BASE_QTY&quot;</span>
 218 |     | <span class='neutral'>        );</span>
 219 |     | <span class='neutral'></span>
 220 | *   | <span class='executed'>        require(</span>
 221 | *   | <span class='executed'>            quoteTokenQtyToReturn &gt;= _quoteTokenQtyMin,</span>
 222 |     | <span class='neutral'>            &quot;Exchange: INSUFFICIENT_QUOTE_QTY&quot;</span>
 223 |     | <span class='neutral'>        );</span>
 224 |     | <span class='neutral'></span>
 225 |     | <span class='neutral'>        // this ensures that we are removing the equivalent amount of decay</span>
 226 |     | <span class='neutral'>        // when this person exits.</span>
 227 |     | <span class='neutral'>        {</span>
 228 |     | <span class='neutral'>            //scoping to avoid stack too deep errors</span>
 229 |     | <span class='unexecuted'>            uint256 internalBaseTokenReserveQty =</span>
 230 |     | <span class='unexecuted'>                internalBalances.baseTokenReserveQty;</span>
 231 |     | <span class='unexecuted'>            uint256 baseTokenQtyToRemoveFromInternalAccounting =</span>
 232 |     | <span class='unexecuted'>                (_liquidityTokenQty * internalBaseTokenReserveQty) /</span>
 233 |     | <span class='unexecuted'>                    totalSupplyOfLiquidityTokens;</span>
 234 |     | <span class='neutral'></span>
 235 |     | <span class='unexecuted'>            internalBalances.baseTokenReserveQty = internalBaseTokenReserveQty =</span>
 236 |     | <span class='unexecuted'>                internalBaseTokenReserveQty -</span>
 237 |     | <span class='neutral'>                baseTokenQtyToRemoveFromInternalAccounting;</span>
 238 |     | <span class='neutral'></span>
 239 |     | <span class='neutral'>            // We should ensure no possible overflow here.</span>
 240 |     | <span class='neutral'>            uint256 internalQuoteTokenReserveQty =</span>
 241 |     | <span class='unexecuted'>                internalBalances.quoteTokenReserveQty;</span>
 242 | *   | <span class='executed'>            if (quoteTokenQtyToReturn &gt; internalQuoteTokenReserveQty) {</span>
 243 |     | <span class='unexecuted'>                internalBalances</span>
 244 |     | <span class='unexecuted'>                    .quoteTokenReserveQty = internalQuoteTokenReserveQty = 0;</span>
 245 |     | <span class='neutral'>            } else {</span>
 246 |     | <span class='unexecuted'>                internalBalances</span>
 247 |     | <span class='unexecuted'>                    .quoteTokenReserveQty = internalQuoteTokenReserveQty =</span>
 248 |     | <span class='unexecuted'>                    internalQuoteTokenReserveQty -</span>
 249 |     | <span class='unexecuted'>                    quoteTokenQtyToReturn;</span>
 250 |     | <span class='neutral'>            }</span>
 251 |     | <span class='neutral'></span>
 252 |     | <span class='unexecuted'>            internalBalances.kLast =</span>
 253 | *   | <span class='executed'>                internalBaseTokenReserveQty *</span>
 254 | *   | <span class='executed'>                internalQuoteTokenReserveQty;</span>
 255 |     | <span class='neutral'>        }</span>
 256 |     | <span class='neutral'></span>
 257 |     | <span class='unexecuted'>        if (liquidityTokenFeeQty != 0) {</span>
 258 |     | <span class='unexecuted'>            _mint(</span>
 259 |     | <span class='unexecuted'>                IExchangeFactory(exchangeFactoryAddress).feeAddress(),</span>
 260 |     | <span class='unexecuted'>                liquidityTokenFeeQty</span>
 261 |     | <span class='neutral'>            );</span>
 262 |     | <span class='neutral'>        }</span>
 263 |     | <span class='neutral'></span>
 264 |     | <span class='unexecuted'>        _burn(msg.sender, _liquidityTokenQty);</span>
 265 |     | <span class='unexecuted'>        IERC20(baseToken).safeTransfer(_tokenRecipient, baseTokenQtyToReturn);</span>
 266 |     | <span class='unexecuted'>        IERC20(quoteToken).safeTransfer(_tokenRecipient, quoteTokenQtyToReturn);</span>
 267 |     | <span class='unexecuted'>        emit RemoveLiquidity(</span>
 268 |     | <span class='unexecuted'>            msg.sender,</span>
 269 |     | <span class='neutral'>            baseTokenQtyToReturn,</span>
 270 |     | <span class='neutral'>            quoteTokenQtyToReturn</span>
 271 |     | <span class='neutral'>        );</span>
 272 |     | <span class='neutral'>    }</span>
 273 |     | <span class='neutral'></span>
 274 |     | <span class='neutral'>    /**</span>
 275 |     | <span class='neutral'>     * @notice swaps base tokens for a minimum amount of quote tokens.  Fees are included in all transactions.</span>
 276 |     | <span class='neutral'>     * The exchange must be granted approvals for the base token by the caller.</span>
 277 |     | <span class='neutral'>     * @param _baseTokenQty qty of base tokens to swap</span>
 278 |     | <span class='neutral'>     * @param _minQuoteTokenQty minimum qty of quote tokens to receive in exchange for</span>
 279 |     | <span class='neutral'>     * your base tokens (or the transaction will revert)</span>
 280 |     | <span class='neutral'>     * @param _expirationTimestamp timestamp that this transaction must occur before (or transaction will revert)</span>
 281 |     | <span class='neutral'>     */</span>
 282 | *   | <span class='executed'>    function swapBaseTokenForQuoteToken(</span>
 283 |     | <span class='neutral'>        uint256 _baseTokenQty,</span>
 284 |     | <span class='neutral'>        uint256 _minQuoteTokenQty,</span>
 285 |     | <span class='neutral'>        uint256 _expirationTimestamp</span>
 286 | *   | <span class='executed'>    ) external nonReentrant() isNotExpired(_expirationTimestamp) {</span>
 287 | *   | <span class='executed'>        require(</span>
 288 | *   | <span class='executed'>            _baseTokenQty != 0 &amp;&amp; _minQuoteTokenQty != 0,</span>
 289 |     | <span class='neutral'>            &quot;Exchange: INSUFFICIENT_TOKEN_QTY&quot;</span>
 290 |     | <span class='neutral'>        );</span>
 291 |     | <span class='neutral'></span>
 292 |     | <span class='unexecuted'>        uint256 quoteTokenQty =</span>
 293 |     | <span class='unexecuted'>            MathLib.calculateQuoteTokenQty(</span>
 294 |     | <span class='unexecuted'>                _baseTokenQty,</span>
 295 |     | <span class='unexecuted'>                _minQuoteTokenQty,</span>
 296 |     | <span class='neutral'>                TOTAL_LIQUIDITY_FEE,</span>
 297 |     | <span class='unexecuted'>                internalBalances</span>
 298 |     | <span class='neutral'>            );</span>
 299 |     | <span class='neutral'></span>
 300 |     | <span class='unexecuted'>        IERC20(baseToken).safeTransferFrom(</span>
 301 |     | <span class='unexecuted'>            msg.sender,</span>
 302 |     | <span class='unexecuted'>            address(this),</span>
 303 |     | <span class='unexecuted'>            _baseTokenQty</span>
 304 |     | <span class='neutral'>        );</span>
 305 |     | <span class='neutral'></span>
 306 |     | <span class='unexecuted'>        IERC20(quoteToken).safeTransfer(msg.sender, quoteTokenQty);</span>
 307 |     | <span class='unexecuted'>        emit Swap(msg.sender, _baseTokenQty, 0, 0, quoteTokenQty);</span>
 308 |     | <span class='neutral'>    }</span>
 309 |     | <span class='neutral'></span>
 310 |     | <span class='neutral'>    /**</span>
 311 |     | <span class='neutral'>     * @notice swaps quote tokens for a minimum amount of base tokens.  Fees are included in all transactions.</span>
 312 |     | <span class='neutral'>     * The exchange must be granted approvals for the quote token by the caller.</span>
 313 |     | <span class='neutral'>     * @param _quoteTokenQty qty of quote tokens to swap</span>
 314 |     | <span class='neutral'>     * @param _minBaseTokenQty minimum qty of base tokens to receive in exchange for</span>
 315 |     | <span class='neutral'>     * your quote tokens (or the transaction will revert)</span>
 316 |     | <span class='neutral'>     * @param _expirationTimestamp timestamp that this transaction must occur before (or transaction will revert)</span>
 317 |     | <span class='neutral'>     */</span>
 318 | *   | <span class='executed'>    function swapQuoteTokenForBaseToken(</span>
 319 |     | <span class='neutral'>        uint256 _quoteTokenQty,</span>
 320 |     | <span class='neutral'>        uint256 _minBaseTokenQty,</span>
 321 |     | <span class='neutral'>        uint256 _expirationTimestamp</span>
 322 | *   | <span class='executed'>    ) external nonReentrant() isNotExpired(_expirationTimestamp) {</span>
 323 | *   | <span class='executed'>        require(</span>
 324 | *   | <span class='executed'>            _quoteTokenQty != 0 &amp;&amp; _minBaseTokenQty != 0,</span>
 325 |     | <span class='neutral'>            &quot;Exchange: INSUFFICIENT_TOKEN_QTY&quot;</span>
 326 |     | <span class='neutral'>        );</span>
 327 |     | <span class='neutral'></span>
 328 | *   | <span class='executed'>        uint256 baseTokenQty =</span>
 329 | *   | <span class='executed'>            MathLib.calculateBaseTokenQty(</span>
 330 |     | <span class='unexecuted'>                _quoteTokenQty,</span>
 331 |     | <span class='unexecuted'>                _minBaseTokenQty,</span>
 332 | *   | <span class='executed'>                IERC20(baseToken).balanceOf(address(this)),</span>
 333 |     | <span class='neutral'>                TOTAL_LIQUIDITY_FEE,</span>
 334 | *   | <span class='executed'>                internalBalances</span>
 335 |     | <span class='neutral'>            );</span>
 336 |     | <span class='neutral'></span>
 337 | *   | <span class='executed'>        IERC20(quoteToken).safeTransferFrom(</span>
 338 |     | <span class='unexecuted'>            msg.sender,</span>
 339 |     | <span class='unexecuted'>            address(this),</span>
 340 |     | <span class='unexecuted'>            _quoteTokenQty</span>
 341 |     | <span class='neutral'>        );</span>
 342 |     | <span class='neutral'></span>
 343 | *   | <span class='executed'>        IERC20(baseToken).safeTransfer(msg.sender, baseTokenQty);</span>
 344 | *   | <span class='executed'>        emit Swap(msg.sender, 0, _quoteTokenQty, baseTokenQty, 0);</span>
 345 |     | <span class='neutral'>    }</span>
 346 |     | <span class='neutral'>}</span>
 347 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/nelsonpereira/Documents/GitHub/Auditing/Fuzzy/Blogs/ElasticSwap_Recon/elasticswap-recon/src/contracts/ExchangeFactory.sol</b>
<code>
  1 |     | <span class='neutral'>//SPDX-License-Identifier: GPL-3.0</span>
  2 |     | <span class='neutral'>pragma solidity 0.8.4;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import &quot;@openzeppelin/contracts/access/Ownable.sol&quot;;</span>
  5 |     | <span class='neutral'>import &quot;@openzeppelin/contracts/token/ERC20/IERC20.sol&quot;;</span>
  6 |     | <span class='neutral'>import &quot;./Exchange.sol&quot;;</span>
  7 |     | <span class='neutral'>import &quot;../interfaces/IExchangeFactory.sol&quot;;</span>
  8 |     | <span class='neutral'>import &quot;../libraries/SafeMetadata.sol&quot;;</span>
  9 |     | <span class='neutral'></span>
 10 |     | <span class='neutral'>/**</span>
 11 |     | <span class='neutral'> * @title ExchangeFactory contract for Elastic Swap.</span>
 12 |     | <span class='neutral'> * @author Elastic DAO</span>
 13 |     | <span class='neutral'> * @notice The ExchangeFactory provides the needed functionality to create new Exchange&#39;s that represent</span>
 14 |     | <span class='neutral'> * a single token pair.  Additionally it houses records of all deployed Exchange&#39;s for validation and easy</span>
 15 |     | <span class='neutral'> * lookup.</span>
 16 |     | <span class='neutral'> */</span>
 17 |     | <span class='unexecuted'>contract ExchangeFactory is Ownable, IExchangeFactory {</span>
 18 |     | <span class='neutral'>    using SafeMetadata for IERC20;</span>
 19 |     | <span class='neutral'></span>
 20 |     | <span class='unexecuted'>    mapping(address =&gt; mapping(address =&gt; address))</span>
 21 |     | <span class='neutral'>        public exchangeAddressByTokenAddress;</span>
 22 |     | <span class='unexecuted'>    mapping(address =&gt; bool) public isValidExchangeAddress;</span>
 23 |     | <span class='neutral'></span>
 24 |     | <span class='neutral'>    address private feeAddress_;</span>
 25 |     | <span class='neutral'></span>
 26 |     | <span class='neutral'>    // events</span>
 27 |     | <span class='neutral'>    event NewExchange(address indexed creator, address indexed exchangeAddress);</span>
 28 |     | <span class='neutral'>    event SetFeeAddress(address indexed feeAddress);</span>
 29 |     | <span class='neutral'></span>
 30 |     | <span class='unexecuted'>    constructor(address _feeAddress) {</span>
 31 |     | <span class='unexecuted'>        require(_feeAddress != address(0), &quot;ExchangeFactory: INVALID_ADDRESS&quot;);</span>
 32 |     | <span class='unexecuted'>        feeAddress_ = _feeAddress;</span>
 33 |     | <span class='neutral'>    }</span>
 34 |     | <span class='neutral'></span>
 35 |     | <span class='neutral'>    /**</span>
 36 |     | <span class='neutral'>     * @notice called to create a new erc20 token pair exchange</span>
 37 |     | <span class='neutral'>     * @param _baseToken address of the ERC20 base token in the pair. This token can have a fixed or elastic supply</span>
 38 |     | <span class='neutral'>     * @param _quoteToken address of the ERC20 quote token in the pair. This token is assumed to have a fixed supply.</span>
 39 |     | <span class='neutral'>     */</span>
 40 |     | <span class='unexecuted'>    function createNewExchange(address _baseToken, address _quoteToken)</span>
 41 |     | <span class='neutral'>        external</span>
 42 |     | <span class='neutral'>    {</span>
 43 |     | <span class='unexecuted'>        require(_baseToken != _quoteToken, &quot;ExchangeFactory: IDENTICAL_TOKENS&quot;);</span>
 44 |     | <span class='unexecuted'>        require(</span>
 45 |     | <span class='unexecuted'>            _baseToken != address(0) &amp;&amp; _quoteToken != address(0),</span>
 46 |     | <span class='neutral'>            &quot;ExchangeFactory: INVALID_TOKEN_ADDRESS&quot;</span>
 47 |     | <span class='neutral'>        );</span>
 48 |     | <span class='unexecuted'>        require(</span>
 49 |     | <span class='unexecuted'>            exchangeAddressByTokenAddress[_baseToken][_quoteToken] ==</span>
 50 |     | <span class='unexecuted'>                address(0),</span>
 51 |     | <span class='neutral'>            &quot;ExchangeFactory: DUPLICATE_EXCHANGE&quot;</span>
 52 |     | <span class='neutral'>        );</span>
 53 |     | <span class='neutral'></span>
 54 |     | <span class='unexecuted'>        string memory baseSymbol = IERC20(_baseToken).safeSymbol();</span>
 55 |     | <span class='unexecuted'>        string memory quoteSymbol = IERC20(_quoteToken).safeSymbol();</span>
 56 |     | <span class='neutral'></span>
 57 |     | <span class='unexecuted'>        Exchange exchange =</span>
 58 |     | <span class='unexecuted'>            new Exchange(</span>
 59 |     | <span class='neutral'>                string(</span>
 60 |     | <span class='unexecuted'>                    abi.encodePacked(</span>
 61 |     | <span class='unexecuted'>                        baseSymbol,</span>
 62 |     | <span class='neutral'>                        &quot;v&quot;,</span>
 63 |     | <span class='unexecuted'>                        quoteSymbol,</span>
 64 |     | <span class='neutral'>                        &quot; ElasticSwap Liquidity Token&quot;</span>
 65 |     | <span class='neutral'>                    )</span>
 66 |     | <span class='neutral'>                ),</span>
 67 |     | <span class='unexecuted'>                string(abi.encodePacked(baseSymbol, &quot;v&quot;, quoteSymbol, &quot;-ELP&quot;)),</span>
 68 |     | <span class='unexecuted'>                _baseToken,</span>
 69 |     | <span class='unexecuted'>                _quoteToken,</span>
 70 |     | <span class='unexecuted'>                address(this)</span>
 71 |     | <span class='neutral'>            );</span>
 72 |     | <span class='neutral'></span>
 73 |     | <span class='unexecuted'>        exchangeAddressByTokenAddress[_baseToken][_quoteToken] = address(</span>
 74 |     | <span class='neutral'>            exchange</span>
 75 |     | <span class='neutral'>        );</span>
 76 |     | <span class='unexecuted'>        isValidExchangeAddress[address(exchange)] = true;</span>
 77 |     | <span class='neutral'></span>
 78 |     | <span class='unexecuted'>        emit NewExchange(msg.sender, address(exchange));</span>
 79 |     | <span class='neutral'>    }</span>
 80 |     | <span class='neutral'></span>
 81 |     | <span class='unexecuted'>    function setFeeAddress(address _feeAddress) external onlyOwner {</span>
 82 |     | <span class='unexecuted'>        require(</span>
 83 |     | <span class='unexecuted'>            _feeAddress != address(0) &amp;&amp; _feeAddress != feeAddress_,</span>
 84 |     | <span class='neutral'>            &quot;ExchangeFactory: INVAlID_FEE_ADDRESS&quot;</span>
 85 |     | <span class='neutral'>        );</span>
 86 |     | <span class='unexecuted'>        feeAddress_ = _feeAddress;</span>
 87 |     | <span class='unexecuted'>        emit SetFeeAddress(_feeAddress);</span>
 88 |     | <span class='neutral'>    }</span>
 89 |     | <span class='neutral'></span>
 90 |     | <span class='unexecuted'>    function feeAddress() public view virtual override returns (address) {</span>
 91 |     | <span class='unexecuted'>        return feeAddress_;</span>
 92 |     | <span class='neutral'>    }</span>
 93 |     | <span class='neutral'>}</span>
 94 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/nelsonpereira/Documents/GitHub/Auditing/Fuzzy/Blogs/ElasticSwap_Recon/elasticswap-recon/src/contracts/mocks/ElasticMock.sol</b>
<code>
  1 |     | <span class='neutral'>//SPDX-License-Identifier: GPL-3.0</span>
  2 |     | <span class='neutral'>pragma solidity 0.8.4;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import &quot;@openzeppelin/contracts/token/ERC20/presets/ERC20PresetFixedSupply.sol&quot;;</span>
  5 |     | <span class='neutral'>import &quot;@openzeppelin/contracts/access/Ownable.sol&quot;;</span>
  6 |     | <span class='neutral'></span>
  7 |     | <span class='neutral'>/**</span>
  8 |     | <span class='neutral'>@notice DO NOT USE IN PRODUCTION. FOR TEST PURPOSES ONLY</span>
  9 |     | <span class='neutral'> */</span>
 10 | *   | <span class='executed'>contract ElasticMock is ERC20PresetFixedSupply, Ownable {</span>
 11 |     | <span class='unexecuted'>    constructor(</span>
 12 |     | <span class='neutral'>        string memory name,</span>
 13 |     | <span class='neutral'>        string memory symbol,</span>
 14 |     | <span class='neutral'>        uint256 initialSupply,</span>
 15 |     | <span class='neutral'>        address owner</span>
 16 |     | <span class='unexecuted'>    ) ERC20PresetFixedSupply(name, symbol, initialSupply, owner) {}</span>
 17 |     | <span class='neutral'></span>
 18 |     | <span class='neutral'>    /**</span>
 19 |     | <span class='neutral'>    @dev Allows us to transfer away tokens from an address in our tests simulating a rebase down occurring</span>
 20 |     | <span class='neutral'>    */</span>
 21 |     | <span class='unexecuted'>    function simulateRebaseDown(</span>
 22 |     | <span class='neutral'>        address tokenHolder,</span>
 23 |     | <span class='neutral'>        uint256 tokenAmountToRemove</span>
 24 |     | <span class='neutral'>    ) external onlyOwner() {</span>
 25 |     | <span class='unexecuted'>        _transfer(tokenHolder, address(this), tokenAmountToRemove);</span>
 26 |     | <span class='neutral'>    }</span>
 27 |     | <span class='neutral'>}</span>
 28 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/nelsonpereira/Documents/GitHub/Auditing/Fuzzy/Blogs/ElasticSwap_Recon/elasticswap-recon/src/contracts/mocks/MockERC20.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-2.0</span>
  2 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import {ERC20} from &quot;@openzeppelin/contracts/token/ERC20/ERC20.sol&quot;;</span>
  5 |     | <span class='neutral'></span>
  6 | *   | <span class='executed'>contract MockERC20 is ERC20 {</span>
  7 |     | <span class='unexecuted'>    constructor(string memory name_, string memory symbol_) ERC20(name_, symbol_) {}</span>
  8 |     | <span class='neutral'></span>
  9 |     | <span class='unexecuted'>    function mint(address to, uint256 value) public virtual {</span>
 10 |     | <span class='unexecuted'>        _mint(to, value);</span>
 11 |     | <span class='neutral'>    }</span>
 12 |     | <span class='neutral'></span>
 13 | *   | <span class='executed'>    function burn(address from, uint256 value) public virtual {</span>
 14 | *   | <span class='executed'>        _burn(from, value);</span>
 15 |     | <span class='neutral'>    }</span>
 16 |     | <span class='neutral'></span>
 17 |     | <span class='neutral'>}</span>

</code>
<br />

<b>/Users/nelsonpereira/Documents/GitHub/Auditing/Fuzzy/Blogs/ElasticSwap_Recon/elasticswap-recon/src/interfaces/IExchangeFactory.sol</b>
<code>
 1 |     | <span class='neutral'>//SPDX-License-Identifier: GPL-3.0</span>
 2 |     | <span class='neutral'>pragma solidity 0.8.4;</span>
 3 |     | <span class='neutral'></span>
 4 |     | <span class='neutral'>interface IExchangeFactory {</span>
 5 |     | <span class='neutral'>    function feeAddress() external view returns (address);</span>
 6 |     | <span class='neutral'>}</span>
 7 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/nelsonpereira/Documents/GitHub/Auditing/Fuzzy/Blogs/ElasticSwap_Recon/elasticswap-recon/src/libraries/MathLib.sol</b>
<code>
   1 |     | <span class='neutral'>//SPDX-License-Identifier: GPL-3.0</span>
   2 |     | <span class='neutral'>pragma solidity 0.8.4;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>/**</span>
   5 |     | <span class='neutral'> * @title MathLib</span>
   6 |     | <span class='neutral'> * @author ElasticDAO</span>
   7 |     | <span class='neutral'> */</span>
   8 |     | <span class='unexecuted'>library MathLib {</span>
   9 |     | <span class='neutral'>    struct InternalBalances {</span>
  10 |     | <span class='neutral'>        // x*y=k - we track these internally to compare to actual balances of the ERC20&#39;s</span>
  11 |     | <span class='neutral'>        // in order to calculate the &quot;decay&quot; or the amount of balances that are not</span>
  12 |     | <span class='neutral'>        // participating in the pricing curve and adding additional liquidity to swap.</span>
  13 |     | <span class='neutral'>        uint256 baseTokenReserveQty; // x</span>
  14 |     | <span class='neutral'>        uint256 quoteTokenReserveQty; // y</span>
  15 |     | <span class='neutral'>        uint256 kLast; // as of the last add / rem liquidity event</span>
  16 |     | <span class='neutral'>    }</span>
  17 |     | <span class='neutral'></span>
  18 |     | <span class='neutral'>    // aids in avoiding stack too deep errors.</span>
  19 |     | <span class='neutral'>    struct TokenQtys {</span>
  20 |     | <span class='neutral'>        uint256 baseTokenQty;</span>
  21 |     | <span class='neutral'>        uint256 quoteTokenQty;</span>
  22 |     | <span class='neutral'>        uint256 liquidityTokenQty;</span>
  23 |     | <span class='neutral'>        uint256 liquidityTokenFeeQty;</span>
  24 |     | <span class='neutral'>    }</span>
  25 |     | <span class='neutral'></span>
  26 | *   | <span class='executed'>    uint256 public constant BASIS_POINTS = 10000;</span>
  27 | *   | <span class='executed'>    uint256 public constant WAD = 1e18; // represent a decimal with 18 digits of precision</span>
  28 |     | <span class='neutral'></span>
  29 |     | <span class='neutral'>    /**</span>
  30 |     | <span class='neutral'>     * @dev divides two float values, required since solidity does not handle</span>
  31 |     | <span class='neutral'>     * floating point values.</span>
  32 |     | <span class='neutral'>     *</span>
  33 |     | <span class='neutral'>     * inspiration: https://github.com/dapphub/ds-math/blob/master/src/math.sol</span>
  34 |     | <span class='neutral'>     *</span>
  35 |     | <span class='neutral'>     * NOTE: this rounds to the nearest integer (up or down). For example .666666 would end up</span>
  36 |     | <span class='neutral'>     * rounding to .66667.</span>
  37 |     | <span class='neutral'>     *</span>
  38 |     | <span class='neutral'>     * @return uint256 wad value (decimal with 18 digits of precision)</span>
  39 |     | <span class='neutral'>     */</span>
  40 |     | <span class='unexecuted'>    function wDiv(uint256 a, uint256 b) internal pure returns (uint256) {</span>
  41 |     | <span class='unexecuted'>        return ((a * WAD) + (b / 2)) / b;</span>
  42 |     | <span class='neutral'>    }</span>
  43 |     | <span class='neutral'></span>
  44 |     | <span class='neutral'>    /**</span>
  45 |     | <span class='neutral'>     * @dev rounds a integer (a) to the nearest n places.</span>
  46 |     | <span class='neutral'>     * IE roundToNearest(123, 10) would round to the nearest 10th place (120).</span>
  47 |     | <span class='neutral'>     */</span>
  48 |     | <span class='unexecuted'>    function roundToNearest(uint256 a, uint256 n)</span>
  49 |     | <span class='neutral'>        internal</span>
  50 |     | <span class='neutral'>        pure</span>
  51 |     | <span class='unexecuted'>        returns (uint256)</span>
  52 |     | <span class='neutral'>    {</span>
  53 | *   | <span class='executed'>        return ((a + (n / 2)) / n) * n;</span>
  54 |     | <span class='neutral'>    }</span>
  55 |     | <span class='neutral'></span>
  56 |     | <span class='neutral'>    /**</span>
  57 |     | <span class='neutral'>     * @dev multiplies two float values, required since solidity does not handle</span>
  58 |     | <span class='neutral'>     * floating point values</span>
  59 |     | <span class='neutral'>     *</span>
  60 |     | <span class='neutral'>     * inspiration: https://github.com/dapphub/ds-math/blob/master/src/math.sol</span>
  61 |     | <span class='neutral'>     *</span>
  62 |     | <span class='neutral'>     * @return uint256 wad value (decimal with 18 digits of precision)</span>
  63 |     | <span class='neutral'>     */</span>
  64 |     | <span class='unexecuted'>    function wMul(uint256 a, uint256 b) internal pure returns (uint256) {</span>
  65 |     | <span class='unexecuted'>        return ((a * b) + (WAD / 2)) / WAD;</span>
  66 |     | <span class='neutral'>    }</span>
  67 |     | <span class='neutral'></span>
  68 |     | <span class='neutral'>    /**</span>
  69 |     | <span class='neutral'>     * @dev calculates an absolute diff between two integers. Basically the solidity</span>
  70 |     | <span class='neutral'>     * equivalent of Math.abs(a-b);</span>
  71 |     | <span class='neutral'>     */</span>
  72 |     | <span class='unexecuted'>    function diff(uint256 a, uint256 b) internal pure returns (uint256) {</span>
  73 |     | <span class='unexecuted'>        if (a &gt;= b) {</span>
  74 |     | <span class='unexecuted'>            return a - b;</span>
  75 |     | <span class='neutral'>        }</span>
  76 |     | <span class='unexecuted'>        return b - a;</span>
  77 |     | <span class='neutral'>    }</span>
  78 |     | <span class='neutral'></span>
  79 |     | <span class='neutral'>    // babylonian method (https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method)</span>
  80 |     | <span class='unexecuted'>    function sqrt(uint256 x) internal pure returns (uint256 y) {</span>
  81 |     | <span class='unexecuted'>        uint256 z = (x + 1) / 2;</span>
  82 |     | <span class='unexecuted'>        y = x;</span>
  83 |     | <span class='unexecuted'>        while (z &lt; y) {</span>
  84 |     | <span class='unexecuted'>            y = z;</span>
  85 |     | <span class='unexecuted'>            z = (x / z + z) / 2;</span>
  86 |     | <span class='neutral'>        }</span>
  87 |     | <span class='neutral'>    }</span>
  88 |     | <span class='neutral'></span>
  89 |     | <span class='neutral'>    /**</span>
  90 |     | <span class='neutral'>     * @dev defines the amount of decay needed in order for us to require a user to handle the</span>
  91 |     | <span class='neutral'>     * decay prior to a double asset entry as the equivalent of 1 unit of quote token</span>
  92 |     | <span class='neutral'>     */</span>
  93 |     | <span class='unexecuted'>    function isSufficientDecayPresent(</span>
  94 |     | <span class='neutral'>        uint256 _baseTokenReserveQty,</span>
  95 |     | <span class='neutral'>        InternalBalances memory _internalBalances</span>
  96 |     | <span class='unexecuted'>    ) internal pure returns (bool) {</span>
  97 |     | <span class='unexecuted'>        return (wDiv(</span>
  98 |     | <span class='unexecuted'>            diff(_baseTokenReserveQty, _internalBalances.baseTokenReserveQty) *</span>
  99 |     | <span class='neutral'>                WAD,</span>
 100 |     | <span class='unexecuted'>            wDiv(</span>
 101 |     | <span class='unexecuted'>                _internalBalances.baseTokenReserveQty,</span>
 102 |     | <span class='unexecuted'>                _internalBalances.quoteTokenReserveQty</span>
 103 |     | <span class='neutral'>            )</span>
 104 |     | <span class='neutral'>        ) &gt;= WAD); // the amount of base token (a) decay is greater than 1 unit of quote token (token b)</span>
 105 |     | <span class='neutral'>    }</span>
 106 |     | <span class='neutral'></span>
 107 |     | <span class='neutral'>    /**</span>
 108 |     | <span class='neutral'>     * @dev used to calculate the qty of token a liquidity provider</span>
 109 |     | <span class='neutral'>     * must add in order to maintain the current reserve ratios</span>
 110 |     | <span class='neutral'>     * @param _tokenAQty base or quote token qty to be supplied by the liquidity provider</span>
 111 |     | <span class='neutral'>     * @param _tokenAReserveQty current reserve qty of the base or quote token (same token as tokenA)</span>
 112 |     | <span class='neutral'>     * @param _tokenBReserveQty current reserve qty of the other base or quote token (not tokenA)</span>
 113 |     | <span class='neutral'>     */</span>
 114 |     | <span class='unexecuted'>    function calculateQty(</span>
 115 |     | <span class='neutral'>        uint256 _tokenAQty,</span>
 116 |     | <span class='neutral'>        uint256 _tokenAReserveQty,</span>
 117 |     | <span class='neutral'>        uint256 _tokenBReserveQty</span>
 118 |     | <span class='unexecuted'>    ) internal pure returns (uint256 tokenBQty) {</span>
 119 | *   | <span class='executed'>        require(_tokenAQty != 0, &quot;MathLib: INSUFFICIENT_QTY&quot;);</span>
 120 | *   | <span class='executed'>        require(</span>
 121 | *   | <span class='executed'>            _tokenAReserveQty != 0 &amp;&amp; _tokenBReserveQty != 0,</span>
 122 |     | <span class='neutral'>            &quot;MathLib: INSUFFICIENT_LIQUIDITY&quot;</span>
 123 |     | <span class='neutral'>        );</span>
 124 | *   | <span class='executed'>        tokenBQty = (_tokenAQty * _tokenBReserveQty) / _tokenAReserveQty;</span>
 125 |     | <span class='neutral'>    }</span>
 126 |     | <span class='neutral'></span>
 127 |     | <span class='neutral'>    /**</span>
 128 |     | <span class='neutral'>     * @dev used to calculate the qty of token a trader will receive (less fees)</span>
 129 |     | <span class='neutral'>     * given the qty of token A they are providing</span>
 130 |     | <span class='neutral'>     * @param _tokenASwapQty base or quote token qty to be swapped by the trader</span>
 131 |     | <span class='neutral'>     * @param _tokenAReserveQty current reserve qty of the base or quote token (same token as tokenA)</span>
 132 |     | <span class='neutral'>     * @param _tokenBReserveQty current reserve qty of the other base or quote token (not tokenA)</span>
 133 |     | <span class='neutral'>     * @param _liquidityFeeInBasisPoints fee to liquidity providers represented in basis points</span>
 134 |     | <span class='neutral'>     */</span>
 135 | *   | <span class='executed'>    function calculateQtyToReturnAfterFees(</span>
 136 |     | <span class='neutral'>        uint256 _tokenASwapQty,</span>
 137 |     | <span class='neutral'>        uint256 _tokenAReserveQty,</span>
 138 |     | <span class='neutral'>        uint256 _tokenBReserveQty,</span>
 139 |     | <span class='neutral'>        uint256 _liquidityFeeInBasisPoints</span>
 140 |     | <span class='unexecuted'>    ) internal pure returns (uint256 qtyToReturn) {</span>
 141 | *   | <span class='executed'>        uint256 tokenASwapQtyLessFee =</span>
 142 |     | <span class='unexecuted'>            _tokenASwapQty * (BASIS_POINTS - _liquidityFeeInBasisPoints);</span>
 143 | *   | <span class='executed'>        qtyToReturn =</span>
 144 | *   | <span class='executed'>            (tokenASwapQtyLessFee * _tokenBReserveQty) /</span>
 145 | *   | <span class='executed'>            ((_tokenAReserveQty * BASIS_POINTS) + tokenASwapQtyLessFee);</span>
 146 |     | <span class='neutral'>    }</span>
 147 |     | <span class='neutral'></span>
 148 |     | <span class='neutral'>    /**</span>
 149 |     | <span class='neutral'>     * @dev used to calculate the qty of liquidity tokens (deltaRo) we will be issued to a supplier</span>
 150 |     | <span class='neutral'>     * of a single asset entry when base token decay is present.</span>
 151 |     | <span class='neutral'>     * @param _baseTokenReserveBalance the total balance (external) of base tokens in our pool (Alpha)</span>
 152 |     | <span class='neutral'>     * @param _totalSupplyOfLiquidityTokens the total supply of our exchange&#39;s liquidity tokens (aka Ro)</span>
 153 |     | <span class='neutral'>     * @param _tokenQtyAToAdd the amount of tokens being added by the caller to remove the current decay</span>
 154 |     | <span class='neutral'>     * @param _internalTokenAReserveQty the internal balance (X or Y) of token A as a result of this transaction</span>
 155 |     | <span class='neutral'>     * @param _omega - ratio of internal balances of baseToken and quoteToken: baseToken/quoteToken</span>
 156 |     | <span class='neutral'>     * @return liquidityTokenQty qty of liquidity tokens to be issued in exchange</span>
 157 |     | <span class='neutral'>     */</span>
 158 | *   | <span class='executed'>    function calculateLiquidityTokenQtyForSingleAssetEntryWithBaseTokenDecay(</span>
 159 |     | <span class='neutral'>        uint256 _baseTokenReserveBalance,</span>
 160 |     | <span class='neutral'>        uint256 _totalSupplyOfLiquidityTokens,</span>
 161 |     | <span class='neutral'>        uint256 _tokenQtyAToAdd,</span>
 162 |     | <span class='neutral'>        uint256 _internalTokenAReserveQty,</span>
 163 |     | <span class='neutral'>        uint256 _omega</span>
 164 | *   | <span class='executed'>    ) internal pure returns (uint256 liquidityTokenQty) {</span>
 165 |     | <span class='neutral'>        /**</span>
 166 |     | <span class='neutral'>        </span>
 167 |     | <span class='neutral'>        (is the formula in the terms of quoteToken)</span>
 168 |     | <span class='neutral'>                    Y </span>
 169 |     | <span class='neutral'>            = ---------------------                                                    </span>
 170 |     | <span class='neutral'>                Alpha/Omega + Y&#39;</span>
 171 |     | <span class='neutral'></span>
 172 |     | <span class='neutral'></span>
 173 |     | <span class='neutral'>         */</span>
 174 | *   | <span class='executed'>        uint256 wRatio = wDiv(_baseTokenReserveBalance, _omega);</span>
 175 | *   | <span class='executed'>        uint256 denominator = wRatio + _internalTokenAReserveQty;</span>
 176 | *   | <span class='executed'>        uint256 wGamma = wDiv(_tokenQtyAToAdd, denominator);</span>
 177 |     | <span class='neutral'></span>
 178 | *   | <span class='executed'>        liquidityTokenQty =</span>
 179 | *   | <span class='executed'>            wDiv(</span>
 180 |     | <span class='unexecuted'>                wMul(_totalSupplyOfLiquidityTokens * WAD, wGamma),</span>
 181 |     | <span class='unexecuted'>                WAD - wGamma</span>
 182 |     | <span class='neutral'>            ) /</span>
 183 |     | <span class='neutral'>            WAD;</span>
 184 |     | <span class='neutral'>    }</span>
 185 |     | <span class='neutral'></span>
 186 |     | <span class='neutral'>    /**</span>
 187 |     | <span class='neutral'>     * @dev used to calculate the qty of liquidity tokens (deltaRo) we will be issued to a supplier</span>
 188 |     | <span class='neutral'>     * of a single asset entry when quote decay is present.</span>
 189 |     | <span class='neutral'>     * @param _baseTokenReserveBalance the total balance (external) of base tokens in our pool (Alpha)</span>
 190 |     | <span class='neutral'>     * @param _totalSupplyOfLiquidityTokens the total supply of our exchange&#39;s liquidity tokens (aka Ro)</span>
 191 |     | <span class='neutral'>     * @param _tokenQtyAToAdd the amount of tokens being added by the caller to remove the current decay</span>
 192 |     | <span class='neutral'>     * @param _internalTokenAReserveQty the internal balance (X or Y) of token A as a result of this transaction</span>
 193 |     | <span class='neutral'>     * @return liquidityTokenQty qty of liquidity tokens to be issued in exchange</span>
 194 |     | <span class='neutral'>     */</span>
 195 | *   | <span class='executed'>    function calculateLiquidityTokenQtyForSingleAssetEntryWithQuoteTokenDecay(</span>
 196 |     | <span class='neutral'>        uint256 _baseTokenReserveBalance,</span>
 197 |     | <span class='neutral'>        uint256 _totalSupplyOfLiquidityTokens,</span>
 198 |     | <span class='neutral'>        uint256 _tokenQtyAToAdd,</span>
 199 |     | <span class='neutral'>        uint256 _internalTokenAReserveQty</span>
 200 | *   | <span class='executed'>    ) internal pure returns (uint256 liquidityTokenQty) {</span>
 201 |     | <span class='neutral'>        /**</span>
 202 |     | <span class='neutral'>        </span>
 203 |     | <span class='neutral'>               X</span>
 204 |     | <span class='neutral'>        = -------------------  / (denominator may be Alpha&#39; instead of X)</span>
 205 |     | <span class='neutral'>           X + (Alpha + X)</span>
 206 |     | <span class='neutral'></span>
 207 |     | <span class='neutral'>        */</span>
 208 |     | <span class='neutral'></span>
 209 |     | <span class='unexecuted'>        uint256 denominator =</span>
 210 | *   | <span class='executed'>            _internalTokenAReserveQty +</span>
 211 | *   | <span class='executed'>                _baseTokenReserveBalance +</span>
 212 | *   | <span class='executed'>                _tokenQtyAToAdd;</span>
 213 |     | <span class='unexecuted'>        uint256 wGamma = wDiv(_tokenQtyAToAdd, denominator);</span>
 214 |     | <span class='neutral'></span>
 215 |     | <span class='neutral'>        liquidityTokenQty =</span>
 216 |     | <span class='unexecuted'>            wDiv(</span>
 217 |     | <span class='unexecuted'>                wMul(_totalSupplyOfLiquidityTokens * WAD, wGamma),</span>
 218 |     | <span class='neutral'>                WAD - wGamma</span>
 219 |     | <span class='neutral'>            ) /</span>
 220 |     | <span class='neutral'>            WAD;</span>
 221 |     | <span class='neutral'>    }</span>
 222 |     | <span class='neutral'></span>
 223 |     | <span class='neutral'>    /**</span>
 224 |     | <span class='neutral'>     * @dev used to calculate the qty of liquidity tokens (deltaRo) we will be issued to a supplier</span>
 225 |     | <span class='neutral'>     * of a single asset entry when decay is present.</span>
 226 |     | <span class='neutral'>     * @param _totalSupplyOfLiquidityTokens the total supply of our exchange&#39;s liquidity tokens (aka Ro)</span>
 227 |     | <span class='neutral'>     * @param _quoteTokenQty the amount of quote token the user it adding to the pool (deltaB or deltaY)</span>
 228 |     | <span class='neutral'>     * @param _quoteTokenReserveBalance the total balance (external) of quote tokens in our pool (Beta)</span>
 229 |     | <span class='neutral'>     *</span>
 230 |     | <span class='neutral'>     * @return liquidityTokenQty qty of liquidity tokens to be issued in exchange</span>
 231 |     | <span class='neutral'>     */</span>
 232 | *   | <span class='executed'>    function calculateLiquidityTokenQtyForDoubleAssetEntry(</span>
 233 |     | <span class='neutral'>        uint256 _totalSupplyOfLiquidityTokens,</span>
 234 |     | <span class='neutral'>        uint256 _quoteTokenQty,</span>
 235 |     | <span class='neutral'>        uint256 _quoteTokenReserveBalance</span>
 236 | *   | <span class='executed'>    ) internal pure returns (uint256 liquidityTokenQty) {</span>
 237 |     | <span class='neutral'>        liquidityTokenQty =</span>
 238 |     | <span class='unexecuted'>            (_quoteTokenQty * _totalSupplyOfLiquidityTokens) /</span>
 239 |     | <span class='unexecuted'>            _quoteTokenReserveBalance;</span>
 240 |     | <span class='neutral'>    }</span>
 241 |     | <span class='neutral'></span>
 242 |     | <span class='neutral'>    /**</span>
 243 |     | <span class='neutral'>     * @dev used to calculate the qty of quote token required and liquidity tokens (deltaRo) to be issued</span>
 244 |     | <span class='neutral'>     * in order to add liquidity and remove base token decay.</span>
 245 |     | <span class='neutral'>     * @param _quoteTokenQtyDesired the amount of quote token the user wants to contribute</span>
 246 |     | <span class='neutral'>     * @param _baseTokenReserveQty the external base token reserve qty prior to this transaction</span>
 247 |     | <span class='neutral'>     * @param _totalSupplyOfLiquidityTokens the total supply of our exchange&#39;s liquidity tokens (aka Ro)</span>
 248 |     | <span class='neutral'>     * @param _internalBalances internal balances struct from our exchange&#39;s internal accounting</span>
 249 |     | <span class='neutral'>     *</span>
 250 |     | <span class='neutral'>     *</span>
 251 |     | <span class='neutral'>     * @return quoteTokenQty qty of quote token the user must supply</span>
 252 |     | <span class='neutral'>     * @return liquidityTokenQty qty of liquidity tokens to be issued in exchange</span>
 253 |     | <span class='neutral'>     */</span>
 254 |     | <span class='unexecuted'>    function calculateAddQuoteTokenLiquidityQuantities(</span>
 255 |     | <span class='neutral'>        uint256 _quoteTokenQtyDesired,</span>
 256 |     | <span class='neutral'>        uint256 _baseTokenReserveQty,</span>
 257 |     | <span class='neutral'>        uint256 _totalSupplyOfLiquidityTokens,</span>
 258 |     | <span class='neutral'>        InternalBalances storage _internalBalances</span>
 259 |     | <span class='unexecuted'>    ) internal returns (uint256 quoteTokenQty, uint256 liquidityTokenQty) {</span>
 260 |     | <span class='unexecuted'>        uint256 baseTokenDecay =</span>
 261 |     | <span class='unexecuted'>            _baseTokenReserveQty - _internalBalances.baseTokenReserveQty;</span>
 262 |     | <span class='neutral'></span>
 263 |     | <span class='neutral'>        // determine max amount of quote token that can be added to offset the current decay</span>
 264 |     | <span class='unexecuted'>        uint256 wInternalBaseTokenToQuoteTokenRatio =</span>
 265 |     | <span class='unexecuted'>            wDiv(</span>
 266 |     | <span class='unexecuted'>                _internalBalances.baseTokenReserveQty,</span>
 267 |     | <span class='unexecuted'>                _internalBalances.quoteTokenReserveQty</span>
 268 |     | <span class='neutral'>            );</span>
 269 |     | <span class='neutral'></span>
 270 |     | <span class='neutral'>        // alphaDecay / omega (A/B)</span>
 271 |     | <span class='unexecuted'>        uint256 maxQuoteTokenQty =</span>
 272 |     | <span class='unexecuted'>            wDiv(baseTokenDecay, wInternalBaseTokenToQuoteTokenRatio);</span>
 273 |     | <span class='neutral'></span>
 274 |     | <span class='unexecuted'>        if (_quoteTokenQtyDesired &gt; maxQuoteTokenQty) {</span>
 275 |     | <span class='unexecuted'>            quoteTokenQty = maxQuoteTokenQty;</span>
 276 |     | <span class='neutral'>        } else {</span>
 277 |     | <span class='unexecuted'>            quoteTokenQty = _quoteTokenQtyDesired;</span>
 278 |     | <span class='neutral'>        }</span>
 279 |     | <span class='neutral'></span>
 280 |     | <span class='unexecuted'>        uint256 baseTokenQtyDecayChange =</span>
 281 |     | <span class='unexecuted'>            roundToNearest(</span>
 282 |     | <span class='unexecuted'>                (quoteTokenQty * wInternalBaseTokenToQuoteTokenRatio),</span>
 283 |     | <span class='neutral'>                WAD</span>
 284 |     | <span class='neutral'>            ) / WAD;</span>
 285 |     | <span class='neutral'></span>
 286 |     | <span class='unexecuted'>        require(</span>
 287 |     | <span class='unexecuted'>            baseTokenQtyDecayChange != 0,</span>
 288 |     | <span class='neutral'>            &quot;MathLib: INSUFFICIENT_CHANGE_IN_DECAY&quot;</span>
 289 |     | <span class='neutral'>        );</span>
 290 |     | <span class='neutral'>        //x += alphaDecayChange</span>
 291 |     | <span class='neutral'>        //y += deltaBeta</span>
 292 |     | <span class='unexecuted'>        _internalBalances.baseTokenReserveQty += baseTokenQtyDecayChange;</span>
 293 |     | <span class='unexecuted'>        _internalBalances.quoteTokenReserveQty += quoteTokenQty;</span>
 294 |     | <span class='neutral'></span>
 295 |     | <span class='neutral'>        // calculate the number of liquidity tokens to return to user using</span>
 296 |     | <span class='unexecuted'>        liquidityTokenQty = calculateLiquidityTokenQtyForSingleAssetEntryWithBaseTokenDecay(</span>
 297 |     | <span class='unexecuted'>            _baseTokenReserveQty,</span>
 298 |     | <span class='unexecuted'>            _totalSupplyOfLiquidityTokens,</span>
 299 |     | <span class='unexecuted'>            quoteTokenQty,</span>
 300 |     | <span class='unexecuted'>            _internalBalances.quoteTokenReserveQty,</span>
 301 |     | <span class='unexecuted'>            wInternalBaseTokenToQuoteTokenRatio</span>
 302 |     | <span class='neutral'>        );</span>
 303 |     | <span class='unexecuted'>        return (quoteTokenQty, liquidityTokenQty);</span>
 304 |     | <span class='neutral'>    }</span>
 305 |     | <span class='neutral'></span>
 306 |     | <span class='neutral'>    /**</span>
 307 |     | <span class='neutral'>     * @dev used to calculate the qty of base tokens required and liquidity tokens (deltaRo) to be issued</span>
 308 |     | <span class='neutral'>     * in order to add liquidity and remove base token decay.</span>
 309 |     | <span class='neutral'>     * @param _baseTokenQtyDesired the amount of base token the user wants to contribute</span>
 310 |     | <span class='neutral'>     * @param _baseTokenQtyMin the minimum amount of base token the user wants to contribute (allows for slippage)</span>
 311 |     | <span class='neutral'>     * @param _baseTokenReserveQty the external base token reserve qty prior to this transaction</span>
 312 |     | <span class='neutral'>     * @param _totalSupplyOfLiquidityTokens the total supply of our exchange&#39;s liquidity tokens (aka Ro)</span>
 313 |     | <span class='neutral'>     * @param _internalBalances internal balances struct from our exchange&#39;s internal accounting</span>
 314 |     | <span class='neutral'>     *</span>
 315 |     | <span class='neutral'>     * @return baseTokenQty qty of base token the user must supply</span>
 316 |     | <span class='neutral'>     * @return liquidityTokenQty qty of liquidity tokens to be issued in exchange</span>
 317 |     | <span class='neutral'>     */</span>
 318 | *   | <span class='executed'>    function calculateAddBaseTokenLiquidityQuantities(</span>
 319 |     | <span class='neutral'>        uint256 _baseTokenQtyDesired,</span>
 320 |     | <span class='neutral'>        uint256 _baseTokenQtyMin,</span>
 321 |     | <span class='neutral'>        uint256 _baseTokenReserveQty,</span>
 322 |     | <span class='neutral'>        uint256 _totalSupplyOfLiquidityTokens,</span>
 323 |     | <span class='neutral'>        InternalBalances memory _internalBalances</span>
 324 |     | <span class='unexecuted'>    ) internal pure returns (uint256 baseTokenQty, uint256 liquidityTokenQty) {</span>
 325 |     | <span class='unexecuted'>        uint256 maxBaseTokenQty =</span>
 326 |     | <span class='unexecuted'>            _internalBalances.baseTokenReserveQty - _baseTokenReserveQty;</span>
 327 |     | <span class='unexecuted'>        require(</span>
 328 |     | <span class='unexecuted'>            _baseTokenQtyMin &lt;= maxBaseTokenQty,</span>
 329 |     | <span class='neutral'>            &quot;MathLib: INSUFFICIENT_DECAY&quot;</span>
 330 |     | <span class='neutral'>        );</span>
 331 |     | <span class='neutral'></span>
 332 | *   | <span class='executed'>        if (_baseTokenQtyDesired &gt; maxBaseTokenQty) {</span>
 333 | *   | <span class='executed'>            baseTokenQty = maxBaseTokenQty;</span>
 334 |     | <span class='neutral'>        } else {</span>
 335 | *   | <span class='executed'>            baseTokenQty = _baseTokenQtyDesired;</span>
 336 |     | <span class='neutral'>        }</span>
 337 |     | <span class='neutral'></span>
 338 |     | <span class='neutral'>        // determine the quote token qty decay change quoted on our current ratios</span>
 339 | *   | <span class='executed'>        uint256 wInternalQuoteToBaseTokenRatio =</span>
 340 | *   | <span class='executed'>            wDiv(</span>
 341 | *   | <span class='executed'>                _internalBalances.quoteTokenReserveQty,</span>
 342 | *   | <span class='executed'>                _internalBalances.baseTokenReserveQty</span>
 343 |     | <span class='neutral'>            );</span>
 344 |     | <span class='neutral'></span>
 345 |     | <span class='neutral'>        // NOTE we need this function to use the same</span>
 346 |     | <span class='neutral'>        // rounding scheme as wDiv in order to avoid a case</span>
 347 |     | <span class='neutral'>        // in which a user is trying to resolve decay in which</span>
 348 |     | <span class='neutral'>        // quoteTokenQtyDecayChange ends up being 0 and we are stuck in</span>
 349 |     | <span class='neutral'>        // a bad state.</span>
 350 | *   | <span class='executed'>        uint256 quoteTokenQtyDecayChange =</span>
 351 | *   | <span class='executed'>            roundToNearest(</span>
 352 | *   | <span class='executed'>                (baseTokenQty * wInternalQuoteToBaseTokenRatio),</span>
 353 |     | <span class='neutral'>                MathLib.WAD</span>
 354 |     | <span class='neutral'>            ) / WAD;</span>
 355 |     | <span class='neutral'></span>
 356 | *   | <span class='executed'>        require(</span>
 357 | *   | <span class='executed'>            quoteTokenQtyDecayChange != 0,</span>
 358 |     | <span class='neutral'>            &quot;MathLib: INSUFFICIENT_CHANGE_IN_DECAY&quot;</span>
 359 |     | <span class='neutral'>        );</span>
 360 |     | <span class='neutral'></span>
 361 |     | <span class='neutral'>        // we can now calculate the total amount of quote token decay</span>
 362 | *   | <span class='executed'>        uint256 quoteTokenDecay =</span>
 363 | *   | <span class='executed'>            (maxBaseTokenQty * wInternalQuoteToBaseTokenRatio) / WAD;</span>
 364 |     | <span class='neutral'></span>
 365 |     | <span class='neutral'>        // this may be redundant quoted on the above math, but will check to ensure the decay wasn&#39;t so small</span>
 366 |     | <span class='neutral'>        // that it was &lt;1 and rounded down to 0 saving the caller some gas</span>
 367 |     | <span class='neutral'>        // also could fix a potential revert due to div by zero.</span>
 368 | *   | <span class='executed'>        require(quoteTokenDecay != 0, &quot;MathLib: NO_QUOTE_DECAY&quot;);</span>
 369 |     | <span class='neutral'></span>
 370 |     | <span class='neutral'>        // we are not changing anything about our internal accounting here. We are simply adding tokens</span>
 371 |     | <span class='neutral'>        // to make our internal account &quot;right&quot;...or rather getting the external balances to match our internal</span>
 372 |     | <span class='neutral'>        // quoteTokenReserveQty += quoteTokenQtyDecayChange;</span>
 373 |     | <span class='neutral'>        // baseTokenReserveQty += baseTokenQty;</span>
 374 |     | <span class='neutral'></span>
 375 |     | <span class='neutral'>        // calculate the number of liquidity tokens to return to user using:</span>
 376 | *   | <span class='executed'>        liquidityTokenQty = calculateLiquidityTokenQtyForSingleAssetEntryWithQuoteTokenDecay(</span>
 377 | *   | <span class='executed'>            _baseTokenReserveQty,</span>
 378 | *   | <span class='executed'>            _totalSupplyOfLiquidityTokens,</span>
 379 | *   | <span class='executed'>            baseTokenQty,</span>
 380 | *   | <span class='executed'>            _internalBalances.baseTokenReserveQty</span>
 381 |     | <span class='neutral'>        );</span>
 382 |     | <span class='neutral'>    }</span>
 383 |     | <span class='neutral'></span>
 384 |     | <span class='neutral'>    /**</span>
 385 |     | <span class='neutral'>     * @dev used to calculate the qty of tokens a user will need to contribute and be issued in order to add liquidity</span>
 386 |     | <span class='neutral'>     * @param _baseTokenQtyDesired the amount of base token the user wants to contribute</span>
 387 |     | <span class='neutral'>     * @param _quoteTokenQtyDesired the amount of quote token the user wants to contribute</span>
 388 |     | <span class='neutral'>     * @param _baseTokenQtyMin the minimum amount of base token the user wants to contribute (allows for slippage)</span>
 389 |     | <span class='neutral'>     * @param _quoteTokenQtyMin the minimum amount of quote token the user wants to contribute (allows for slippage)</span>
 390 |     | <span class='neutral'>     * @param _baseTokenReserveQty the external base token reserve qty prior to this transaction</span>
 391 |     | <span class='neutral'>     * @param _totalSupplyOfLiquidityTokens the total supply of our exchange&#39;s liquidity tokens (aka Ro)</span>
 392 |     | <span class='neutral'>     * @param _internalBalances internal balances struct from our exchange&#39;s internal accounting</span>
 393 |     | <span class='neutral'>     *</span>
 394 |     | <span class='neutral'>     * @return tokenQtys qty of tokens needed to complete transaction</span>
 395 |     | <span class='neutral'>     */</span>
 396 | *   | <span class='executed'>    function calculateAddLiquidityQuantities(</span>
 397 |     | <span class='neutral'>        uint256 _baseTokenQtyDesired,</span>
 398 |     | <span class='neutral'>        uint256 _quoteTokenQtyDesired,</span>
 399 |     | <span class='neutral'>        uint256 _baseTokenQtyMin,</span>
 400 |     | <span class='neutral'>        uint256 _quoteTokenQtyMin,</span>
 401 |     | <span class='neutral'>        uint256 _baseTokenReserveQty,</span>
 402 |     | <span class='neutral'>        uint256 _totalSupplyOfLiquidityTokens,</span>
 403 |     | <span class='neutral'>        InternalBalances storage _internalBalances</span>
 404 |     | <span class='unexecuted'>    ) internal returns (TokenQtys memory tokenQtys) {</span>
 405 | *   | <span class='executed'>        if (_totalSupplyOfLiquidityTokens != 0) {</span>
 406 |     | <span class='neutral'>            // we have outstanding liquidity tokens present and an existing price curve</span>
 407 |     | <span class='neutral'></span>
 408 |     | <span class='unexecuted'>            tokenQtys.liquidityTokenFeeQty = calculateLiquidityTokenFees(</span>
 409 |     | <span class='unexecuted'>                _totalSupplyOfLiquidityTokens,</span>
 410 |     | <span class='neutral'>                _internalBalances</span>
 411 |     | <span class='neutral'>            );</span>
 412 |     | <span class='neutral'></span>
 413 |     | <span class='neutral'>            // we need to take this amount (that will be minted) into account for below calculations</span>
 414 |     | <span class='unexecuted'>            _totalSupplyOfLiquidityTokens += tokenQtys.liquidityTokenFeeQty;</span>
 415 |     | <span class='neutral'></span>
 416 |     | <span class='neutral'>            // confirm that we have no beta or alpha decay present</span>
 417 |     | <span class='neutral'>            // if we do, we need to resolve that first</span>
 418 |     | <span class='unexecuted'>            if (</span>
 419 |     | <span class='unexecuted'>                isSufficientDecayPresent(</span>
 420 |     | <span class='unexecuted'>                    _baseTokenReserveQty,</span>
 421 |     | <span class='unexecuted'>                    _internalBalances</span>
 422 |     | <span class='neutral'>                )</span>
 423 |     | <span class='neutral'>            ) {</span>
 424 |     | <span class='neutral'>                // decay is present and needs to be dealt with by the caller.</span>
 425 |     | <span class='neutral'></span>
 426 |     | <span class='unexecuted'>                uint256 baseTokenQtyFromDecay;</span>
 427 |     | <span class='unexecuted'>                uint256 quoteTokenQtyFromDecay;</span>
 428 |     | <span class='unexecuted'>                uint256 liquidityTokenQtyFromDecay;</span>
 429 |     | <span class='neutral'></span>
 430 |     | <span class='unexecuted'>                if (</span>
 431 |     | <span class='unexecuted'>                    _baseTokenReserveQty &gt; _internalBalances.baseTokenReserveQty</span>
 432 |     | <span class='neutral'>                ) {</span>
 433 |     | <span class='neutral'>                    // we have more base token than expected (base token decay) due to rebase up</span>
 434 |     | <span class='neutral'>                    // we first need to handle this situation by requiring this user</span>
 435 |     | <span class='neutral'>                    // to add quote tokens</span>
 436 |     | <span class='unexecuted'>                    (</span>
 437 |     | <span class='neutral'>                        quoteTokenQtyFromDecay,</span>
 438 |     | <span class='neutral'>                        liquidityTokenQtyFromDecay</span>
 439 |     | <span class='unexecuted'>                    ) = calculateAddQuoteTokenLiquidityQuantities(</span>
 440 |     | <span class='unexecuted'>                        _quoteTokenQtyDesired,</span>
 441 |     | <span class='unexecuted'>                        _baseTokenReserveQty,</span>
 442 |     | <span class='unexecuted'>                        _totalSupplyOfLiquidityTokens,</span>
 443 |     | <span class='unexecuted'>                        _internalBalances</span>
 444 |     | <span class='neutral'>                    );</span>
 445 |     | <span class='neutral'>                } else {</span>
 446 |     | <span class='neutral'>                    // we have less base token than expected (quote token decay) due to a rebase down</span>
 447 |     | <span class='neutral'>                    // we first need to handle this by adding base tokens to offset this.</span>
 448 |     | <span class='unexecuted'>                    (</span>
 449 |     | <span class='neutral'>                        baseTokenQtyFromDecay,</span>
 450 |     | <span class='neutral'>                        liquidityTokenQtyFromDecay</span>
 451 |     | <span class='unexecuted'>                    ) = calculateAddBaseTokenLiquidityQuantities(</span>
 452 |     | <span class='unexecuted'>                        _baseTokenQtyDesired,</span>
 453 |     | <span class='unexecuted'>                        0, // there is no minimum for this particular call since we may use base tokens later.</span>
 454 |     | <span class='unexecuted'>                        _baseTokenReserveQty,</span>
 455 |     | <span class='unexecuted'>                        _totalSupplyOfLiquidityTokens,</span>
 456 |     | <span class='unexecuted'>                        _internalBalances</span>
 457 |     | <span class='neutral'>                    );</span>
 458 |     | <span class='neutral'>                }</span>
 459 |     | <span class='neutral'></span>
 460 | *   | <span class='executed'>                if (</span>
 461 |     | <span class='unexecuted'>                    quoteTokenQtyFromDecay &lt; _quoteTokenQtyDesired &amp;&amp;</span>
 462 |     | <span class='unexecuted'>                    baseTokenQtyFromDecay &lt; _baseTokenQtyDesired</span>
 463 |     | <span class='neutral'>                ) {</span>
 464 |     | <span class='neutral'>                    // the user still has qty that they desire to contribute to the exchange for liquidity</span>
 465 | *   | <span class='executed'>                    (</span>
 466 |     | <span class='neutral'>                        tokenQtys.baseTokenQty,</span>
 467 | *   | <span class='executed'>                        tokenQtys.quoteTokenQty,</span>
 468 |     | <span class='unexecuted'>                        tokenQtys.liquidityTokenQty</span>
 469 |     | <span class='unexecuted'>                    ) = calculateAddTokenPairLiquidityQuantities(</span>
 470 |     | <span class='unexecuted'>                        _baseTokenQtyDesired - baseTokenQtyFromDecay, // safe from underflow quoted on above IF</span>
 471 |     | <span class='unexecuted'>                        _quoteTokenQtyDesired - quoteTokenQtyFromDecay, // safe from underflow quoted on above IF</span>
 472 |     | <span class='unexecuted'>                        0, // we will check minimums below</span>
 473 |     | <span class='neutral'>                        0, // we will check minimums below</span>
 474 |     | <span class='unexecuted'>                        _totalSupplyOfLiquidityTokens +</span>
 475 |     | <span class='unexecuted'>                            liquidityTokenQtyFromDecay,</span>
 476 |     | <span class='unexecuted'>                        _internalBalances // NOTE: these balances have already been updated when we did the decay math.</span>
 477 |     | <span class='neutral'>                    );</span>
 478 |     | <span class='neutral'>                }</span>
 479 | *   | <span class='executed'>                tokenQtys.baseTokenQty += baseTokenQtyFromDecay;</span>
 480 | *   | <span class='executed'>                tokenQtys.quoteTokenQty += quoteTokenQtyFromDecay;</span>
 481 |     | <span class='unexecuted'>                tokenQtys.liquidityTokenQty += liquidityTokenQtyFromDecay;</span>
 482 |     | <span class='neutral'></span>
 483 |     | <span class='unexecuted'>                require(</span>
 484 |     | <span class='unexecuted'>                    tokenQtys.baseTokenQty &gt;= _baseTokenQtyMin,</span>
 485 |     | <span class='neutral'>                    &quot;MathLib: INSUFFICIENT_BASE_QTY&quot;</span>
 486 |     | <span class='neutral'>                );</span>
 487 |     | <span class='neutral'></span>
 488 |     | <span class='unexecuted'>                require(</span>
 489 |     | <span class='unexecuted'>                    tokenQtys.quoteTokenQty &gt;= _quoteTokenQtyMin,</span>
 490 |     | <span class='neutral'>                    &quot;MathLib: INSUFFICIENT_QUOTE_QTY&quot;</span>
 491 |     | <span class='neutral'>                );</span>
 492 |     | <span class='neutral'>            } else {</span>
 493 |     | <span class='neutral'>                // the user is just doing a simple double asset entry / providing both base and quote.</span>
 494 |     | <span class='unexecuted'>                (</span>
 495 |     | <span class='neutral'>                    tokenQtys.baseTokenQty,</span>
 496 |     | <span class='unexecuted'>                    tokenQtys.quoteTokenQty,</span>
 497 |     | <span class='unexecuted'>                    tokenQtys.liquidityTokenQty</span>
 498 |     | <span class='unexecuted'>                ) = calculateAddTokenPairLiquidityQuantities(</span>
 499 |     | <span class='unexecuted'>                    _baseTokenQtyDesired,</span>
 500 |     | <span class='unexecuted'>                    _quoteTokenQtyDesired,</span>
 501 |     | <span class='unexecuted'>                    _baseTokenQtyMin,</span>
 502 |     | <span class='unexecuted'>                    _quoteTokenQtyMin,</span>
 503 |     | <span class='unexecuted'>                    _totalSupplyOfLiquidityTokens,</span>
 504 |     | <span class='unexecuted'>                    _internalBalances</span>
 505 |     | <span class='neutral'>                );</span>
 506 |     | <span class='neutral'>            }</span>
 507 |     | <span class='neutral'>        } else {</span>
 508 |     | <span class='neutral'>            // this user will set the initial pricing curve</span>
 509 | *   | <span class='executed'>            require(</span>
 510 |     | <span class='unexecuted'>                _baseTokenQtyDesired != 0,</span>
 511 |     | <span class='neutral'>                &quot;MathLib: INSUFFICIENT_BASE_QTY_DESIRED&quot;</span>
 512 |     | <span class='neutral'>            );</span>
 513 | *   | <span class='executed'>            require(</span>
 514 | *   | <span class='executed'>                _quoteTokenQtyDesired != 0,</span>
 515 |     | <span class='neutral'>                &quot;MathLib: INSUFFICIENT_QUOTE_QTY_DESIRED&quot;</span>
 516 |     | <span class='neutral'>            );</span>
 517 |     | <span class='neutral'></span>
 518 | *   | <span class='executed'>            tokenQtys.baseTokenQty = _baseTokenQtyDesired;</span>
 519 | *   | <span class='executed'>            tokenQtys.quoteTokenQty = _quoteTokenQtyDesired;</span>
 520 | *   | <span class='executed'>            tokenQtys.liquidityTokenQty = sqrt(</span>
 521 | *   | <span class='executed'>                _baseTokenQtyDesired * _quoteTokenQtyDesired</span>
 522 |     | <span class='neutral'>            );</span>
 523 |     | <span class='neutral'></span>
 524 | *   | <span class='executed'>            _internalBalances.baseTokenReserveQty += tokenQtys.baseTokenQty;</span>
 525 | *   | <span class='executed'>            _internalBalances.quoteTokenReserveQty += tokenQtys.quoteTokenQty;</span>
 526 |     | <span class='neutral'>        }</span>
 527 |     | <span class='neutral'>    }</span>
 528 |     | <span class='neutral'></span>
 529 |     | <span class='neutral'>    /**</span>
 530 |     | <span class='neutral'>     * @dev calculates the qty of base and quote tokens required and liquidity tokens (deltaRo) to be issued</span>
 531 |     | <span class='neutral'>     * in order to add liquidity when no decay is present.</span>
 532 |     | <span class='neutral'>     * @param _baseTokenQtyDesired the amount of base token the user wants to contribute</span>
 533 |     | <span class='neutral'>     * @param _quoteTokenQtyDesired the amount of quote token the user wants to contribute</span>
 534 |     | <span class='neutral'>     * @param _baseTokenQtyMin the minimum amount of base token the user wants to contribute (allows for slippage)</span>
 535 |     | <span class='neutral'>     * @param _quoteTokenQtyMin the minimum amount of quote token the user wants to contribute (allows for slippage)</span>
 536 |     | <span class='neutral'>     * @param _totalSupplyOfLiquidityTokens the total supply of our exchange&#39;s liquidity tokens (aka Ro)</span>
 537 |     | <span class='neutral'>     * @param _internalBalances internal balances struct from our exchange&#39;s internal accounting</span>
 538 |     | <span class='neutral'>     *</span>
 539 |     | <span class='neutral'>     * @return baseTokenQty qty of base token the user must supply</span>
 540 |     | <span class='neutral'>     * @return quoteTokenQty qty of quote token the user must supply</span>
 541 |     | <span class='neutral'>     * @return liquidityTokenQty qty of liquidity tokens to be issued in exchange</span>
 542 |     | <span class='neutral'>     */</span>
 543 | *   | <span class='executed'>    function calculateAddTokenPairLiquidityQuantities(</span>
 544 |     | <span class='neutral'>        uint256 _baseTokenQtyDesired,</span>
 545 |     | <span class='neutral'>        uint256 _quoteTokenQtyDesired,</span>
 546 |     | <span class='neutral'>        uint256 _baseTokenQtyMin,</span>
 547 |     | <span class='neutral'>        uint256 _quoteTokenQtyMin,</span>
 548 |     | <span class='neutral'>        uint256 _totalSupplyOfLiquidityTokens,</span>
 549 |     | <span class='neutral'>        InternalBalances storage _internalBalances</span>
 550 |     | <span class='neutral'>    )</span>
 551 |     | <span class='neutral'>        internal</span>
 552 |     | <span class='neutral'>        returns (</span>
 553 | *   | <span class='executed'>            uint256 baseTokenQty,</span>
 554 | *   | <span class='executed'>            uint256 quoteTokenQty,</span>
 555 | *   | <span class='executed'>            uint256 liquidityTokenQty</span>
 556 |     | <span class='neutral'>        )</span>
 557 |     | <span class='neutral'>    {</span>
 558 | *   | <span class='executed'>        uint256 requiredQuoteTokenQty =</span>
 559 | *   | <span class='executed'>            calculateQty(</span>
 560 | *   | <span class='executed'>                _baseTokenQtyDesired,</span>
 561 | *   | <span class='executed'>                _internalBalances.baseTokenReserveQty,</span>
 562 | *   | <span class='executed'>                _internalBalances.quoteTokenReserveQty</span>
 563 |     | <span class='neutral'>            );</span>
 564 |     | <span class='neutral'></span>
 565 | *   | <span class='executed'>        if (requiredQuoteTokenQty &lt;= _quoteTokenQtyDesired) {</span>
 566 |     | <span class='neutral'>            // user has to provide less than their desired amount</span>
 567 | *   | <span class='executed'>            require(</span>
 568 | *   | <span class='executed'>                requiredQuoteTokenQty &gt;= _quoteTokenQtyMin,</span>
 569 |     | <span class='neutral'>                &quot;MathLib: INSUFFICIENT_QUOTE_QTY&quot;</span>
 570 |     | <span class='neutral'>            );</span>
 571 | *   | <span class='executed'>            baseTokenQty = _baseTokenQtyDesired;</span>
 572 | *   | <span class='executed'>            quoteTokenQty = requiredQuoteTokenQty;</span>
 573 |     | <span class='neutral'>        } else {</span>
 574 |     | <span class='neutral'>            // we need to check the opposite way.</span>
 575 | *   | <span class='executed'>            uint256 requiredBaseTokenQty =</span>
 576 | *   | <span class='executed'>                calculateQty(</span>
 577 | *   | <span class='executed'>                    _quoteTokenQtyDesired,</span>
 578 | *   | <span class='executed'>                    _internalBalances.quoteTokenReserveQty,</span>
 579 | *   | <span class='executed'>                    _internalBalances.baseTokenReserveQty</span>
 580 |     | <span class='neutral'>                );</span>
 581 |     | <span class='neutral'></span>
 582 | *   | <span class='executed'>            require(</span>
 583 | *   | <span class='executed'>                requiredBaseTokenQty &gt;= _baseTokenQtyMin,</span>
 584 |     | <span class='neutral'>                &quot;MathLib: INSUFFICIENT_BASE_QTY&quot;</span>
 585 |     | <span class='neutral'>            );</span>
 586 | *   | <span class='executed'>            baseTokenQty = requiredBaseTokenQty;</span>
 587 | *   | <span class='executed'>            quoteTokenQty = _quoteTokenQtyDesired;</span>
 588 |     | <span class='neutral'>        }</span>
 589 |     | <span class='neutral'></span>
 590 | *   | <span class='executed'>        liquidityTokenQty = calculateLiquidityTokenQtyForDoubleAssetEntry(</span>
 591 | *   | <span class='executed'>            _totalSupplyOfLiquidityTokens,</span>
 592 | *   | <span class='executed'>            quoteTokenQty,</span>
 593 | *   | <span class='executed'>            _internalBalances.quoteTokenReserveQty</span>
 594 |     | <span class='neutral'>        );</span>
 595 |     | <span class='neutral'></span>
 596 | *   | <span class='executed'>        _internalBalances.baseTokenReserveQty += baseTokenQty;</span>
 597 |     | <span class='unexecuted'>        _internalBalances.quoteTokenReserveQty += quoteTokenQty;</span>
 598 |     | <span class='neutral'>    }</span>
 599 |     | <span class='neutral'></span>
 600 |     | <span class='neutral'>    /**</span>
 601 |     | <span class='neutral'>     * @dev calculates the qty of base tokens a user will receive for swapping their quote tokens (less fees)</span>
 602 |     | <span class='neutral'>     * @param _quoteTokenQty the amount of quote tokens the user wants to swap</span>
 603 |     | <span class='neutral'>     * @param _baseTokenQtyMin the minimum about of base tokens they are willing to receive in return (slippage)</span>
 604 |     | <span class='neutral'>     * @param _baseTokenReserveQty the external base token reserve qty prior to this transaction</span>
 605 |     | <span class='neutral'>     * @param _liquidityFeeInBasisPoints the current total liquidity fee represented as an integer of basis points</span>
 606 |     | <span class='neutral'>     * @param _internalBalances internal balances struct from our exchange&#39;s internal accounting</span>
 607 |     | <span class='neutral'>     *</span>
 608 |     | <span class='neutral'>     * @return baseTokenQty qty of base token the user will receive back</span>
 609 |     | <span class='neutral'>     */</span>
 610 | *   | <span class='executed'>    function calculateBaseTokenQty(</span>
 611 |     | <span class='neutral'>        uint256 _quoteTokenQty,</span>
 612 |     | <span class='neutral'>        uint256 _baseTokenQtyMin,</span>
 613 |     | <span class='neutral'>        uint256 _baseTokenReserveQty,</span>
 614 |     | <span class='neutral'>        uint256 _liquidityFeeInBasisPoints,</span>
 615 |     | <span class='neutral'>        InternalBalances storage _internalBalances</span>
 616 | *   | <span class='executed'>    ) internal returns (uint256 baseTokenQty) {</span>
 617 | *   | <span class='executed'>        require(</span>
 618 | *   | <span class='executed'>            _baseTokenReserveQty != 0 &amp;&amp;</span>
 619 | *   | <span class='executed'>                _internalBalances.baseTokenReserveQty != 0,</span>
 620 |     | <span class='neutral'>            &quot;MathLib: INSUFFICIENT_BASE_TOKEN_QTY&quot;</span>
 621 |     | <span class='neutral'>        );</span>
 622 |     | <span class='neutral'></span>
 623 |     | <span class='neutral'>        // check to see if we have experience quote token decay / a rebase down event</span>
 624 | *   | <span class='executed'>        if (_baseTokenReserveQty &lt; _internalBalances.baseTokenReserveQty) {</span>
 625 |     | <span class='neutral'>            // we have less reserves than our current price curve will expect, we need to adjust the curve</span>
 626 | *   | <span class='executed'>            uint256 wPricingRatio =</span>
 627 | *   | <span class='executed'>                wDiv(</span>
 628 | *   | <span class='executed'>                    _internalBalances.baseTokenReserveQty,</span>
 629 | *   | <span class='executed'>                    _internalBalances.quoteTokenReserveQty</span>
 630 |     | <span class='neutral'>                ); // omega</span>
 631 |     | <span class='neutral'></span>
 632 | *   | <span class='executed'>            uint256 impliedQuoteTokenQty =</span>
 633 | *   | <span class='executed'>                wDiv(_baseTokenReserveQty, wPricingRatio); // no need to divide by WAD, wPricingRatio is already a WAD.</span>
 634 |     | <span class='neutral'></span>
 635 | *   | <span class='executed'>            baseTokenQty = calculateQtyToReturnAfterFees(</span>
 636 | *   | <span class='executed'>                _quoteTokenQty,</span>
 637 | *   | <span class='executed'>                impliedQuoteTokenQty,</span>
 638 | *   | <span class='executed'>                _baseTokenReserveQty, // use the actual balance here since we adjusted the quote token to match ratio!</span>
 639 | *   | <span class='executed'>                _liquidityFeeInBasisPoints</span>
 640 |     | <span class='neutral'>            );</span>
 641 |     | <span class='neutral'>        } else {</span>
 642 |     | <span class='neutral'>            // we have the same or more reserves, no need to alter the curve.</span>
 643 | *   | <span class='executed'>            baseTokenQty = calculateQtyToReturnAfterFees(</span>
 644 | *   | <span class='executed'>                _quoteTokenQty,</span>
 645 | *   | <span class='executed'>                _internalBalances.quoteTokenReserveQty,</span>
 646 | *   | <span class='executed'>                _internalBalances.baseTokenReserveQty,</span>
 647 | *   | <span class='executed'>                _liquidityFeeInBasisPoints</span>
 648 |     | <span class='neutral'>            );</span>
 649 |     | <span class='neutral'>        }</span>
 650 |     | <span class='neutral'></span>
 651 | *   | <span class='executed'>        require(</span>
 652 | *   | <span class='executed'>            baseTokenQty &gt;= _baseTokenQtyMin,</span>
 653 |     | <span class='neutral'>            &quot;MathLib: INSUFFICIENT_BASE_TOKEN_QTY&quot;</span>
 654 |     | <span class='neutral'>        );</span>
 655 |     | <span class='neutral'></span>
 656 | *   | <span class='executed'>        _internalBalances.baseTokenReserveQty -= baseTokenQty;</span>
 657 | *   | <span class='executed'>        _internalBalances.quoteTokenReserveQty += _quoteTokenQty;</span>
 658 |     | <span class='neutral'>    }</span>
 659 |     | <span class='neutral'></span>
 660 |     | <span class='neutral'>    /**</span>
 661 |     | <span class='neutral'>     * @dev calculates the qty of quote tokens a user will receive for swapping their base tokens (less fees)</span>
 662 |     | <span class='neutral'>     * @param _baseTokenQty the amount of bases tokens the user wants to swap</span>
 663 |     | <span class='neutral'>     * @param _quoteTokenQtyMin the minimum about of quote tokens they are willing to receive in return (slippage)</span>
 664 |     | <span class='neutral'>     * @param _liquidityFeeInBasisPoints the current total liquidity fee represented as an integer of basis points</span>
 665 |     | <span class='neutral'>     * @param _internalBalances internal balances struct from our exchange&#39;s internal accounting</span>
 666 |     | <span class='neutral'>     *</span>
 667 |     | <span class='neutral'>     * @return quoteTokenQty qty of quote token the user will receive back</span>
 668 |     | <span class='neutral'>     */</span>
 669 | *   | <span class='executed'>    function calculateQuoteTokenQty(</span>
 670 |     | <span class='neutral'>        uint256 _baseTokenQty,</span>
 671 |     | <span class='neutral'>        uint256 _quoteTokenQtyMin,</span>
 672 |     | <span class='neutral'>        uint256 _liquidityFeeInBasisPoints,</span>
 673 |     | <span class='neutral'>        InternalBalances storage _internalBalances</span>
 674 | *   | <span class='executed'>    ) internal returns (uint256 quoteTokenQty) {</span>
 675 | *   | <span class='executed'>        require(</span>
 676 | *   | <span class='executed'>            _baseTokenQty != 0 &amp;&amp; _quoteTokenQtyMin != 0,</span>
 677 |     | <span class='neutral'>            &quot;MathLib: INSUFFICIENT_TOKEN_QTY&quot;</span>
 678 |     | <span class='neutral'>        );</span>
 679 |     | <span class='neutral'></span>
 680 | *   | <span class='executed'>        quoteTokenQty = calculateQtyToReturnAfterFees(</span>
 681 | *   | <span class='executed'>            _baseTokenQty,</span>
 682 | *   | <span class='executed'>            _internalBalances.baseTokenReserveQty,</span>
 683 | *   | <span class='executed'>            _internalBalances.quoteTokenReserveQty,</span>
 684 | *   | <span class='executed'>            _liquidityFeeInBasisPoints</span>
 685 |     | <span class='neutral'>        );</span>
 686 |     | <span class='neutral'></span>
 687 | *   | <span class='executed'>        require(</span>
 688 | *   | <span class='executed'>            quoteTokenQty &gt;= _quoteTokenQtyMin,</span>
 689 |     | <span class='neutral'>            &quot;MathLib: INSUFFICIENT_QUOTE_TOKEN_QTY&quot;</span>
 690 |     | <span class='neutral'>        );</span>
 691 |     | <span class='neutral'></span>
 692 |     | <span class='unexecuted'>        _internalBalances.baseTokenReserveQty += _baseTokenQty;</span>
 693 | *   | <span class='executed'>        _internalBalances.quoteTokenReserveQty -= quoteTokenQty;</span>
 694 |     | <span class='neutral'>    }</span>
 695 |     | <span class='neutral'></span>
 696 |     | <span class='neutral'>    /**</span>
 697 |     | <span class='neutral'>     * @dev calculates the qty of liquidity tokens that should be sent to the DAO due to the growth in K from trading.</span>
 698 |     | <span class='neutral'>     * 50BPS is the total fee, 25 goes to the LPs, 5 BP to the DAO, and 20 BP to staking rewards and liquidity incentives</span>
 699 |     | <span class='neutral'>     * @param _totalSupplyOfLiquidityTokens the total supply of our exchange&#39;s liquidity tokens (aka Ro)</span>
 700 |     | <span class='neutral'>     * @param _internalBalances internal balances struct from our exchange&#39;s internal accounting</span>
 701 |     | <span class='neutral'>     *</span>
 702 |     | <span class='neutral'>     * @return liquidityTokenFeeQty qty of tokens to be minted to the fee address for the growth in K</span>
 703 |     | <span class='neutral'>     */</span>
 704 | *   | <span class='executed'>    function calculateLiquidityTokenFees(</span>
 705 |     | <span class='neutral'>        uint256 _totalSupplyOfLiquidityTokens,</span>
 706 |     | <span class='neutral'>        InternalBalances memory _internalBalances</span>
 707 | *   | <span class='executed'>    ) internal pure returns (uint256 liquidityTokenFeeQty) {</span>
 708 | *   | <span class='executed'>        uint256 rootK =</span>
 709 | *   | <span class='executed'>            sqrt(</span>
 710 | *   | <span class='executed'>                _internalBalances.baseTokenReserveQty *</span>
 711 | *   | <span class='executed'>                    _internalBalances.quoteTokenReserveQty</span>
 712 |     | <span class='neutral'>            );</span>
 713 | *   | <span class='executed'>        uint256 rootKLast = sqrt(_internalBalances.kLast);</span>
 714 | *   | <span class='executed'>        if (rootK &gt; rootKLast) {</span>
 715 | *   | <span class='executed'>            uint256 numerator =</span>
 716 | *   | <span class='executed'>                _totalSupplyOfLiquidityTokens * (rootK - rootKLast);</span>
 717 |     | <span class='unexecuted'>            uint256 denominator = rootK * 2;</span>
 718 |     | <span class='unexecuted'>            liquidityTokenFeeQty = numerator / denominator;</span>
 719 |     | <span class='neutral'>        }</span>
 720 |     | <span class='neutral'>    }</span>
 721 |     | <span class='neutral'>}</span>
 722 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/nelsonpereira/Documents/GitHub/Auditing/Fuzzy/Blogs/ElasticSwap_Recon/elasticswap-recon/src/libraries/SafeMetadata.sol</b>
<code>
  1 |     | <span class='neutral'>//SPDX-License-Identifier: GPL-3.0</span>
  2 |     | <span class='neutral'>pragma solidity 0.8.4;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import &quot;@openzeppelin/contracts/token/ERC20/IERC20.sol&quot;;</span>
  5 |     | <span class='neutral'>import &quot;@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol&quot;;</span>
  6 |     | <span class='neutral'></span>
  7 |     | <span class='unexecuted'>library SafeMetadata {</span>
  8 |     | <span class='neutral'>    function safeName(IERC20 token) internal view returns (string memory) {</span>
  9 |     | <span class='neutral'>        (bool success, bytes memory data) =</span>
 10 |     | <span class='neutral'>            address(token).staticcall(</span>
 11 |     | <span class='neutral'>                abi.encodeWithSelector(IERC20Metadata.name.selector)</span>
 12 |     | <span class='neutral'>            );</span>
 13 |     | <span class='neutral'>        if (success) return abi.decode(data, (string));</span>
 14 |     | <span class='neutral'>        return &quot;Token&quot;;</span>
 15 |     | <span class='neutral'>    }</span>
 16 |     | <span class='neutral'></span>
 17 |     | <span class='unexecuted'>    function safeSymbol(IERC20 token) internal view returns (string memory) {</span>
 18 |     | <span class='unexecuted'>        (bool success, bytes memory data) =</span>
 19 |     | <span class='unexecuted'>            address(token).staticcall(</span>
 20 |     | <span class='unexecuted'>                abi.encodeWithSelector(IERC20Metadata.symbol.selector)</span>
 21 |     | <span class='neutral'>            );</span>
 22 |     | <span class='unexecuted'>        if (success) return abi.decode(data, (string));</span>
 23 |     | <span class='unexecuted'>        return &quot;TKN&quot;;</span>
 24 |     | <span class='neutral'>    }</span>
 25 |     | <span class='neutral'></span>
 26 |     | <span class='neutral'>    function safeDecimals(IERC20 token) internal view returns (uint8) {</span>
 27 |     | <span class='neutral'>        (bool success, bytes memory data) =</span>
 28 |     | <span class='neutral'>            address(token).staticcall(</span>
 29 |     | <span class='neutral'>                abi.encodeWithSelector(IERC20Metadata.decimals.selector)</span>
 30 |     | <span class='neutral'>            );</span>
 31 |     | <span class='neutral'>        if (success &amp;&amp; data.length &gt;= 32) return abi.decode(data, (uint8));</span>
 32 |     | <span class='neutral'>        return 18;</span>
 33 |     | <span class='neutral'>    }</span>
 34 |     | <span class='neutral'>}</span>
 35 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/nelsonpereira/Documents/GitHub/Auditing/Fuzzy/Blogs/ElasticSwap_Recon/elasticswap-recon/test/recon/BeforeAfter.sol</b>
<code>
  1 |     | <span class='neutral'></span>
  2 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-2.0</span>
  3 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  4 |     | <span class='neutral'></span>
  5 |     | <span class='neutral'>import {Setup} from &quot;./Setup.sol&quot;;</span>
  6 |     | <span class='neutral'></span>
  7 |     | <span class='neutral'>abstract contract BeforeAfter is Setup {</span>
  8 |     | <span class='neutral'></span>
  9 |     | <span class='neutral'>    struct InternalBalances {</span>
 10 |     | <span class='neutral'>        // x*y=k - we track these internally to compare to actual balances of the ERC20&#39;s</span>
 11 |     | <span class='neutral'>        // in order to calculate the &quot;decay&quot; or the amount of balances that are not</span>
 12 |     | <span class='neutral'>        // participating in the pricing curve and adding additional liquidity to swap.</span>
 13 |     | <span class='neutral'>        uint256 baseTokenReserveQty; // x</span>
 14 |     | <span class='neutral'>        uint256 quoteTokenReserveQty; // y</span>
 15 |     | <span class='neutral'>        uint256 kLast; // as of the last add / rem liquidity event</span>
 16 |     | <span class='neutral'>    }</span>
 17 |     | <span class='neutral'></span>
 18 |     | <span class='neutral'>    struct Vars {</span>
 19 |     | <span class='neutral'>        InternalBalances exchange_internalBalances;</span>
 20 |     | <span class='neutral'>    }</span>
 21 |     | <span class='neutral'></span>
 22 |     | <span class='neutral'>    Vars internal _before;</span>
 23 |     | <span class='neutral'>    Vars internal _after;</span>
 24 |     | <span class='neutral'></span>
 25 |     | <span class='neutral'>    function __before() internal {</span>
 26 |     | <span class='neutral'>        (</span>
 27 |     | <span class='neutral'>            _before.exchange_internalBalances.baseTokenReserveQty,</span>
 28 |     | <span class='neutral'>            _before.exchange_internalBalances.quoteTokenReserveQty,</span>
 29 |     | <span class='neutral'>            _before.exchange_internalBalances.kLast</span>
 30 |     | <span class='neutral'>        ) = exchange.internalBalances();</span>
 31 |     | <span class='neutral'>    }</span>
 32 |     | <span class='neutral'></span>
 33 |     | <span class='neutral'>    function __after() internal {</span>
 34 |     | <span class='neutral'>        (</span>
 35 |     | <span class='neutral'>            _after.exchange_internalBalances.baseTokenReserveQty,</span>
 36 |     | <span class='neutral'>            _after.exchange_internalBalances.quoteTokenReserveQty,</span>
 37 |     | <span class='neutral'>            _after.exchange_internalBalances.kLast</span>
 38 |     | <span class='neutral'>        ) = exchange.internalBalances();</span>
 39 |     | <span class='neutral'>    } </span>
 40 |     | <span class='neutral'>}</span>
 41 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/nelsonpereira/Documents/GitHub/Auditing/Fuzzy/Blogs/ElasticSwap_Recon/elasticswap-recon/test/recon/CryticTester.sol</b>
<code>
  1 |     | <span class='neutral'></span>
  2 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-2.0</span>
  3 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  4 |     | <span class='neutral'></span>
  5 |     | <span class='neutral'>import {TargetFunctions} from &quot;./TargetFunctions.sol&quot;;</span>
  6 |     | <span class='neutral'>import {CryticAsserts} from &quot;@chimera/CryticAsserts.sol&quot;;</span>
  7 |     | <span class='neutral'></span>
  8 |     | <span class='neutral'>// echidna . --contract CryticTester --config echidna.yaml</span>
  9 |     | <span class='neutral'>// medusa fuzz</span>
 10 | *or | <span class='executed'>contract CryticTester is TargetFunctions, CryticAsserts {</span>
 11 |     | <span class='neutral'>    constructor() payable {</span>
 12 |     | <span class='unexecuted'>        setup();</span>
 13 |     | <span class='neutral'>    }</span>
 14 |     | <span class='neutral'>}</span>
 15 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/nelsonpereira/Documents/GitHub/Auditing/Fuzzy/Blogs/ElasticSwap_Recon/elasticswap-recon/test/recon/Properties.sol</b>
<code>
  1 |     | <span class='neutral'></span>
  2 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-2.0</span>
  3 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  4 |     | <span class='neutral'></span>
  5 |     | <span class='neutral'>import {Asserts} from &quot;@chimera/Asserts.sol&quot;;</span>
  6 |     | <span class='neutral'>import {Setup} from &quot;./Setup.sol&quot;;</span>
  7 |     | <span class='neutral'></span>
  8 |     | <span class='neutral'>abstract contract Properties is Setup, Asserts {</span>
  9 |     | <span class='neutral'></span>
 10 |     | <span class='neutral'>    // need a property that allows calling both functions and price doesn&#39;t change</span>
 11 |     | <span class='neutral'>    // price starts at a value -&gt; functions get called -&gt; price stays at same value</span>
 12 |     | <span class='neutral'>    // function invariant_priceDoesntChange() public returns (bool) {</span>
 13 |     | <span class='neutral'>    //     // price before actions are executed is stored in setup as previousBaseSpotPrice</span>
 14 |     | <span class='neutral'>    //     // this reads from storage and updates after each call</span>
 15 |     | <span class='neutral'>    //     (uint256 baseTokenReserveQty, uint256 quoteTokenReserveQty,) = exchange.internalBalances();</span>
 16 |     | <span class='neutral'>    //     uint256 currentBaseSpotPrice =  quoteTokenReserveQty / baseTokenReserveQty;</span>
 17 |     | <span class='neutral'>        </span>
 18 |     | <span class='neutral'>    //     // may need to use a percentage here to deal with potential rounding errors</span>
 19 |     | <span class='neutral'>    //     eq(previousBaseSpotPrice, currentBaseSpotPrice, &quot;prices differ after call sequence&quot;);</span>
 20 |     | <span class='neutral'>    //     // return previousBaseSpotPrice == currentBaseSpotPrice;</span>
 21 |     | <span class='neutral'>    // }</span>
 22 |     | <span class='neutral'></span>
 23 | *   | <span class='executed'>    function invariant_user_cant_gain_value() public returns (bool) {</span>
 24 | *   | <span class='executed'>        return _getBalanceSum() &lt;= initialUserBalance;</span>
 25 |     | <span class='neutral'>    }</span>
 26 |     | <span class='neutral'></span>
 27 |     | <span class='neutral'>    function crytic_user_cant_gain_value() public returns (bool) {</span>
 28 |     | <span class='neutral'>        return _getBalanceSum() &lt;= initialUserBalance;</span>
 29 |     | <span class='neutral'>    }</span>
 30 |     | <span class='neutral'>}</span>
 31 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/nelsonpereira/Documents/GitHub/Auditing/Fuzzy/Blogs/ElasticSwap_Recon/elasticswap-recon/test/recon/Setup.sol</b>
<code>
  1 |     | <span class='neutral'></span>
  2 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-2.0</span>
  3 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  4 |     | <span class='neutral'></span>
  5 |     | <span class='neutral'>import {BaseSetup} from &quot;@chimera/BaseSetup.sol&quot;;</span>
  6 |     | <span class='neutral'>import {ElasticMock} from &quot;src/contracts/mocks/ElasticMock.sol&quot;;</span>
  7 |     | <span class='neutral'>// import {Token_ERC20} from &quot;lib/forge-std/test/mocks/MockERC20.t.sol&quot;;</span>
  8 |     | <span class='neutral'>import {MockERC20} from &quot;src/contracts/mocks/MockERC20.sol&quot;;</span>
  9 |     | <span class='neutral'>import {Exchange} from &quot;src/contracts/Exchange.sol&quot;;</span>
 10 |     | <span class='neutral'>import {ExchangeFactory} from &quot;src/contracts/ExchangeFactory.sol&quot;;</span>
 11 |     | <span class='neutral'>import &quot;forge-std/console.sol&quot;;</span>
 12 |     | <span class='neutral'>import &quot;lib/chimera/src/Hevm.sol&quot;;</span>
 13 |     | <span class='neutral'></span>
 14 |     | <span class='neutral'>// inheriting from Test to expose targetContracts function</span>
 15 |     | <span class='neutral'>abstract contract Setup is BaseSetup {</span>
 16 |     | <span class='neutral'></span>
 17 |     | <span class='neutral'>    ElasticMock elasticMockToken; // base token</span>
 18 |     | <span class='neutral'>    MockERC20 usdMockToken; // quote token</span>
 19 |     | <span class='neutral'>    ExchangeFactory exchangeFactory; </span>
 20 |     | <span class='neutral'>    Exchange exchange; </span>
 21 |     | <span class='neutral'></span>
 22 |     | <span class='neutral'>    uint256 previousBaseSpotPrice;</span>
 23 |     | <span class='neutral'></span>
 24 |     | <span class='neutral'>    uint256 initialUserBalance;</span>
 25 |     | <span class='neutral'></span>
 26 |     | <span class='unexecuted'>    function setup() internal virtual override {</span>
 27 |     | <span class='unexecuted'>      uint256 initialTokenBalance = 1000000000000000000000000000;</span>
 28 |     | <span class='neutral'>      // initial supply of ETM is minted to 0x10000 address</span>
 29 |     | <span class='unexecuted'>      elasticMockToken = new ElasticMock(&quot;ElasticTokenMock&quot;, &quot;ETM&quot;, 3 * initialTokenBalance, address(0x10000));</span>
 30 |     | <span class='neutral'>      </span>
 31 |     | <span class='neutral'>      // transfer elasticMockToken to other addresses since it has fixed supply</span>
 32 |     | <span class='unexecuted'>      vm.prank(address(0x10000));</span>
 33 |     | <span class='unexecuted'>      elasticMockToken.transfer(address(0x20000), initialTokenBalance);</span>
 34 |     | <span class='unexecuted'>      vm.prank(address(0x10000));</span>
 35 |     | <span class='unexecuted'>      elasticMockToken.transfer(address(0x30000), initialTokenBalance);</span>
 36 |     | <span class='neutral'></span>
 37 |     | <span class='unexecuted'>      usdMockToken = new MockERC20(&quot;Fake-USD&quot;, &quot;FUSD&quot;);</span>
 38 |     | <span class='neutral'>      // initialize the token and mint the initial supply to 0x10000 which is one of the senders so it can make donation to pool</span>
 39 |     | <span class='unexecuted'>      usdMockToken.mint(address(0x10000), initialTokenBalance);</span>
 40 |     | <span class='unexecuted'>      usdMockToken.mint(address(0x20000), initialTokenBalance);</span>
 41 |     | <span class='unexecuted'>      usdMockToken.mint(address(0x30000), initialTokenBalance);</span>
 42 |     | <span class='neutral'></span>
 43 |     | <span class='unexecuted'>      exchangeFactory = new ExchangeFactory(address(0x456));</span>
 44 |     | <span class='unexecuted'>      exchange = new Exchange(&quot;EGT LP Token&quot;, &quot;EGTLPS&quot;, address(elasticMockToken), address(usdMockToken), address(exchangeFactory));</span>
 45 |     | <span class='neutral'>    </span>
 46 |     | <span class='neutral'>      // grant exchange permissions for sender&#39;s tokens</span>
 47 |     | <span class='unexecuted'>      vm.prank(address(0x10000));</span>
 48 |     | <span class='unexecuted'>      usdMockToken.approve(address(exchange), type(uint256).max);</span>
 49 |     | <span class='unexecuted'>      vm.prank(address(0x10000));</span>
 50 |     | <span class='unexecuted'>      elasticMockToken.approve(address(exchange), type(uint256).max);</span>
 51 |     | <span class='neutral'></span>
 52 |     | <span class='unexecuted'>      vm.prank(address(0x20000));</span>
 53 |     | <span class='unexecuted'>      usdMockToken.approve(address(exchange), type(uint256).max);</span>
 54 |     | <span class='unexecuted'>      vm.prank(address(0x20000));</span>
 55 |     | <span class='unexecuted'>      elasticMockToken.approve(address(exchange), type(uint256).max);</span>
 56 |     | <span class='neutral'></span>
 57 |     | <span class='unexecuted'>      vm.prank(address(0x30000));</span>
 58 |     | <span class='unexecuted'>      usdMockToken.approve(address(exchange), type(uint256).max);</span>
 59 |     | <span class='unexecuted'>      vm.prank(address(0x30000));</span>
 60 |     | <span class='unexecuted'>      elasticMockToken.approve(address(exchange), type(uint256).max);</span>
 61 |     | <span class='neutral'></span>
 62 |     | <span class='neutral'>      // seed exchange with tokens</span>
 63 |     | <span class='unexecuted'>      uint256 halfOfTokenBalance = initialTokenBalance / 2;</span>
 64 |     | <span class='unexecuted'>      vm.prank(address(0x20000));</span>
 65 |     | <span class='unexecuted'>      exchange.addLiquidity(halfOfTokenBalance, halfOfTokenBalance, halfOfTokenBalance - 10, halfOfTokenBalance - 10, address(0x20000), block.timestamp + 1);</span>
 66 |     | <span class='neutral'>      </span>
 67 |     | <span class='unexecuted'>      initialUserBalance = _getBalanceSum();</span>
 68 |     | <span class='neutral'></span>
 69 |     | <span class='neutral'>      // user adds liquidity</span>
 70 |     | <span class='unexecuted'>      vm.prank(address(0x30000));</span>
 71 |     | <span class='unexecuted'>      exchange.addLiquidity(initialTokenBalance, initialTokenBalance, initialTokenBalance, initialTokenBalance, address(0x30000), block.timestamp + 1);</span>
 72 |     | <span class='neutral'>      </span>
 73 |     | <span class='neutral'>      // spot price is just the ratio of the two quantities of tokens in the pool</span>
 74 |     | <span class='neutral'>      // this is initially set here then set after all function calls by the invariant</span>
 75 |     | <span class='neutral'>      // (uint256 baseTokenReserveQty, uint256 quoteTokenReserveQty,) = exchange.internalBalances();</span>
 76 |     | <span class='neutral'>      // previousBaseSpotPrice = quoteTokenReserveQty / baseTokenReserveQty;</span>
 77 |     | <span class='neutral'></span>
 78 |     | <span class='neutral'>      // required for foundry invariant testing</span>
 79 |     | <span class='neutral'>      // targetContract(address(exchange));</span>
 80 |     | <span class='neutral'>      // address[] memory targetContracts =  targetContracts();</span>
 81 |     | <span class='neutral'>      // address targetContracts0 = targetContracts[0];</span>
 82 |     | <span class='neutral'>      // console.log(&quot;targetContracts: &quot;, targetContracts0);</span>
 83 |     | <span class='neutral'>    }</span>
 84 |     | <span class='neutral'></span>
 85 | *   | <span class='executed'>    function _getBalanceSum() internal returns (uint256) {</span>
 86 | *   | <span class='executed'>      return elasticMockToken.balanceOf(address(0x30000)) + usdMockToken.balanceOf(address(0x30000));</span>
 87 |     | <span class='neutral'>    }</span>
 88 |     | <span class='neutral'>}</span>
 89 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/nelsonpereira/Documents/GitHub/Auditing/Fuzzy/Blogs/ElasticSwap_Recon/elasticswap-recon/test/recon/TargetFunctions.sol</b>
<code>
  1 |     | <span class='neutral'></span>
  2 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-2.0</span>
  3 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  4 |     | <span class='neutral'></span>
  5 |     | <span class='neutral'>import {BaseTargetFunctions} from &quot;@chimera/BaseTargetFunctions.sol&quot;;</span>
  6 |     | <span class='neutral'>import {BeforeAfter} from &quot;./BeforeAfter.sol&quot;;</span>
  7 |     | <span class='neutral'>import {Properties} from &quot;./Properties.sol&quot;;</span>
  8 |     | <span class='neutral'>import {vm} from &quot;@chimera/Hevm.sol&quot;;</span>
  9 |     | <span class='neutral'>import &quot;forge-std/console.sol&quot;;</span>
 10 |     | <span class='neutral'></span>
 11 |     | <span class='neutral'>abstract contract TargetFunctions is BaseTargetFunctions, Properties, BeforeAfter {</span>
 12 |     | <span class='neutral'></span>
 13 | *   | <span class='executed'>  function eRC20_approve(address spender, uint256 amount) public {</span>
 14 | *r  | <span class='executed'>    usdMockToken.approve(spender, amount);</span>
 15 |     | <span class='neutral'>  }</span>
 16 |     | <span class='neutral'>  </span>
 17 | *   | <span class='executed'>  function eRC20_transfer(address to, uint256 amount) public {</span>
 18 | *   | <span class='executed'>    usdMockToken.transfer(to, amount);</span>
 19 |     | <span class='neutral'>  }</span>
 20 |     | <span class='neutral'></span>
 21 | *   | <span class='executed'>  function eRC20_transferFrom(address from, address to, uint256 amount) public {</span>
 22 | *r  | <span class='executed'>    usdMockToken.transferFrom(from, to, amount);</span>
 23 |     | <span class='neutral'>  }</span>
 24 |     | <span class='neutral'></span>
 25 |     | <span class='neutral'>  // all _expirationTimestamp parameters have been replaced with block.timestamp + 1 to reduce fuzz runs being wasted on different values of this parameter</span>
 26 | *   | <span class='executed'>  function exchange_addLiquidity(uint256 _baseTokenQtyDesired, uint256 _quoteTokenQtyDesired, uint256 _baseTokenQtyMin, uint256 _quoteTokenQtyMin, address _liquidityTokenRecipient) public {</span>
 27 | *r  | <span class='executed'>    exchange.addLiquidity(_baseTokenQtyDesired, _quoteTokenQtyDesired, _baseTokenQtyMin, _quoteTokenQtyMin, _liquidityTokenRecipient, block.timestamp + 1);</span>
 28 |     | <span class='neutral'>  }</span>
 29 |     | <span class='neutral'></span>
 30 | *   | <span class='executed'>  function exchange_removeLiquidity(uint256 _liquidityTokenQty, uint256 _baseTokenQtyMin, uint256 _quoteTokenQtyMin, address _tokenRecipient) public {</span>
 31 | *r  | <span class='executed'>    exchange.removeLiquidity(_liquidityTokenQty, _baseTokenQtyMin, _quoteTokenQtyMin, _tokenRecipient, block.timestamp + 1);</span>
 32 |     | <span class='neutral'>  }</span>
 33 |     | <span class='neutral'></span>
 34 | *   | <span class='executed'>  function exchange_swapBaseTokenForQuoteToken(uint256 _baseTokenQty, uint256 _minQuoteTokenQty) public {</span>
 35 | *r  | <span class='executed'>    exchange.swapBaseTokenForQuoteToken(_baseTokenQty, _minQuoteTokenQty, block.timestamp + 1);</span>
 36 |     | <span class='neutral'>  }</span>
 37 |     | <span class='neutral'></span>
 38 | *   | <span class='executed'>  function exchange_swapQuoteTokenForBaseToken(uint256 _quoteTokenQty, uint256 _minBaseTokenQty) public {</span>
 39 | *   | <span class='executed'>    exchange.swapQuoteTokenForBaseToken(_quoteTokenQty, _minBaseTokenQty, block.timestamp + 1);</span>
 40 |     | <span class='neutral'>  }</span>
 41 |     | <span class='neutral'>}</span>
 42 |     | <span class='neutral'></span>

</code>
<br />

